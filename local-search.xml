<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于休息</title>
    <link href="/2020/06/02/%E5%85%B3%E4%BA%8E%E4%BC%91%E6%81%AF/"/>
    <url>/2020/06/02/%E5%85%B3%E4%BA%8E%E4%BC%91%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>如何正确的休息（不是修仙！！！！）</p><a id="more"></a><h1 id="不应该做的"><a href="#不应该做的" class="headerlink" title="不应该做的"></a>不应该做的</h1><ol><li>上网浏览新闻</li><li>看小说</li><li>打游戏</li><li>与朋友聊天</li><li>看电影</li></ol><h1 id="应该做的"><a href="#应该做的" class="headerlink" title="应该做的"></a>应该做的</h1><ol><li>冥想<ol><li>由畅通的气流</li></ol></li><li>短时间的剧烈运动<ol><li>有氧运动，如跑步</li></ol></li><li>吃</li><li>小睡<ol><li>10-15min</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些想说的</title>
    <link href="/2020/06/01/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84/"/>
    <url>/2020/06/01/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>我感到恐慌，焦虑，害怕</p><p>也同时期待着，盼望着，畅想着</p><p>只要没有闲下来，一切，仍旧是美好的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>期末考试</title>
    <link href="/2020/05/30/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"/>
    <url>/2020/05/30/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>复习安排</p><a id="more"></a><table><thead><tr><th>科目</th><th>复习途径</th><th>复习重点</th><th>考试时间</th></tr></thead><tbody><tr><td>中国近代史</td><td>大作业，紧急DDL，课本</td><td>整理课本</td><td></td></tr><tr><td>高等数学</td><td>往年的期末题，今年的作业题</td><td>公式，不同的题型</td><td></td></tr><tr><td>电子电路</td><td>往年的期末题，今年的作业题</td><td>公式，e的指数幂，电路分析</td><td></td></tr><tr><td>大学物理</td><td>往年的期末题，今年的作业题</td><td>公式，适用范围。</td><td></td></tr><tr><td>大学英语（听说</td><td>课本的题目</td><td>单词且单词</td><td></td></tr><tr><td>大学英语（读写</td><td>课本单词</td><td>单词，且单词</td><td></td></tr><tr><td>离散数学</td><td>往年的期末题，今年的作业题</td><td>看书，纯英文的的课本必须多看，然后作业题也是重点</td><td></td></tr><tr><td>西方音乐史</td><td>大作业</td><td></td><td></td></tr></tbody></table><p>复习日程表</p><table><thead><tr><th>科目</th><th>复习时间</th><th align="left">做的事情</th></tr></thead><tbody><tr><td>离散数学</td><td>5月30日 —— 6月1日</td><td align="left">看完课本</td></tr><tr><td>高等数学</td><td>5月31日 —— 结束</td><td align="left">往年的期末考试题</td></tr><tr><td>大学物理</td><td>5月31日开始</td><td align="left">重看PPT，整理笔记，写之前的作业</td></tr><tr><td>大学英语（听说，读写</td><td>5月31日 —— 6月4日</td><td align="left">背单词，每个模块的 Topic 复习</td></tr><tr><td>中国近代史</td><td>6月1日 ——6月3日</td><td align="left">大作业写完</td></tr><tr><td>计算导论——第一阶段</td><td>5月31日</td><td align="left">学习多线程</td></tr><tr><td>计算导论——第二阶段</td><td>6月1日</td><td align="left">看录课，做设计</td></tr><tr><td>计算导论——第三阶段</td><td>6月3日</td><td align="left">写完</td></tr><tr><td>电子电路</td><td>先走走上面的的内容吧</td><td align="left"></td></tr><tr><td></td><td></td><td align="left"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（十）</title>
    <link href="/2020/05/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <url>/2020/05/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>AVL树的详细内容，单旋转 和 双旋转 作为 一眼看不懂的东西，明天再填</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>左子树和右子树的高度最多差1的二叉查找树</p><p>每一个节点中都保留着自身的高度信息</p><p>由这个特点可以直到，除了插入以外，所有操作的时间复杂度为logN（即本身的深度），而插入操作因为可能破坏树的平衡，而很麻烦。</p><h1 id="所以，我们怎么对待插入"><a href="#所以，我们怎么对待插入" class="headerlink" title="所以，我们怎么对待插入"></a>所以，我们怎么对待插入</h1><p>对树做旋转操作。</p><p>在插入之后，只有从插入点到根节点的路径上的节点的平衡可能被改变。找到第一个新平衡破坏了AVL的节点，对它旋转，然后就完成了。</p><h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><p>任意节点最多两个儿子，所以高度不平衡时，两棵子树的高度差能且只能为2</p><ol><li>在左儿子的左子树上插入</li><li>在左儿子的右子树上插入</li><li>在右儿子的左子树上插入</li><li>在右儿子的右子树上插入</li></ol><p>对于1，4，对树进行单旋转，</p><p>对于2，3，对树进行双旋转</p><h3 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第四章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（九）</title>
    <link href="/2020/05/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <url>/2020/05/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>二叉查找树的平均情形分析，以及AVL树的初步</p><a id="more"></a><h1 id="平均情形分析"><a href="#平均情形分析" class="headerlink" title="平均情形分析"></a>平均情形分析</h1><p>对二叉查找树，初始化耗时为N，其余所有操作耗时均为logN（<em>实际上是树的深度</em>），所以下证明树的平均深度为logN</p><p>证毕（假装自己看懂了）</p><h1 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h1><h2 id="为什么要AVL树"><a href="#为什么要AVL树" class="headerlink" title="为什么要AVL树"></a>为什么要AVL树</h2><p>一棵树，当向其输入预先排好序的数据后，这个树会变成一条直线而非树，<strong><em>参考插入算法</em></strong></p><p>这时候时间开销就很大了，所以为了防止这种情况，需要增加一个称为平衡的附加结构条件：任何节点的深度均不得过深。这样可以防止刚刚那种情况的的发生。</p><p>AVL树，就是最老的一种平衡查找树</p><h2 id="AVL树的详细定义"><a href="#AVL树的详细定义" class="headerlink" title="AVL树的详细定义"></a>AVL树的详细定义</h2><p>带有平衡条件的二叉查找树</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第四章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的Habitica中的冒险</title>
    <link href="/2020/05/26/%E6%88%91%E7%9A%84Habitica%E4%B8%AD%E7%9A%84%E5%86%92%E9%99%A9/"/>
    <url>/2020/05/26/%E6%88%91%E7%9A%84Habitica%E4%B8%AD%E7%9A%84%E5%86%92%E9%99%A9/</url>
    
    <content type="html"><![CDATA[<p>此处是我的Habitica的人设等等，车一张卡</p><a id="more"></a><blockquote><p>网站：<a href="https://habitica.com/" target="_blank" rel="noopener">https://habitica.com/</a></p></blockquote><p>人设背景：上古卷轴5</p><p>人物名称：王富贵</p><p>人物种族：诺德人</p><p>人物表面形象：在雪漫城卖菜的小贩</p><p>人物隐藏背景：天际省的最后一位龙裔</p><p>目前人物状态：被逮捕，正在运往海加尔</p><p>人物小传：王富贵出生的时候，整个泰姆瑞尔都在回荡着吼声，是年，从出生起就居住于白银塔中的天选史官第一次违心的记载，迈德历18年，天下丰收，神喜，故吼而歌。</p><p>富贵的前15年的人生平平无奇的过去。直到软弱无耻的迈德二世面对高精灵的步步紧逼，皇帝步步后退，甚至在打赢了战争之后仍签署了丧权辱国的《白金协定》。王富贵的塔洛斯信仰被裁定为非法，诺德族的英雄泰伯被视为不可说的人。悲愤至极的王富贵揭竿而起，加入了风暴斗篷的反抗大军。随着乌弗瑞克的四处征战，</p><p>四年后，也就是今年，乌弗瑞克在穿过天际边界去落锤省寻找援军时，不幸被帝国俘虏，王富贵作为同行人员，也被俘虏。</p><p>现在，在王富贵走上了断头台，天空中突然出现了吼声，是龙！千百年的传说再次出现在人们眼前，龙，是真实存在的。跪在断头台前的王富贵挣扎着逃出了枷锁。</p><p>末代龙裔的故事，从此开始。</p><p><img src="http://img1.gamersky.com/image2011/12/20111219m_1/01.jpg" srcset="/img/loading.gif" alt="img"></p><p>第一章：</p><p>逃离海加尔</p>]]></content>
    
    
    <categories>
      
      <category>Habitica</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（八）</title>
    <link href="/2020/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <url>/2020/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>上次还是10天前……</p><p>包括树的遍历，二叉树，查找树</p><a id="more"></a><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="遍历的类型"><a href="#遍历的类型" class="headerlink" title="遍历的类型"></a>遍历的类型</h2><p>时间复杂度为O（n）；</p><p>在处理儿子节点前先处理本身。</p><p>先序遍历：首先访问根节点，然后遍历左子树，再遍历右子树</p><p>中序：左   根   右  //排序后就像从左往右写</p><p>后序： 左  右   根 </p><p>//以上三个序是考虑根的位置</p><p>层序：从上到下从左往右。</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul><li>二叉树的每个节点的儿子都不多于两个</li><li>平均深度为根号N</li><li>最坏为N-1</li></ul><h2 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><p>一个结构体有三个元素，本身的值，指向左儿子的指针，指向右儿子的指针。</p><h2 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h2><ul><li>之所以存在表达式树是因为一个表达式可以把树叶用操作数表示，用其他节点表示操作符。</li><li>通过递归计算左右子树，即可得到结果</li><li>将中序遍历用于表达式树，可以得到中缀表达式（正常的表达式）</li><li>后序遍历用于表达式树，可以得到逆波兰表达式（后缀表达式，用栈计算的那个）</li></ul><h3 id="构造一棵表达式树"><a href="#构造一棵表达式树" class="headerlink" title="构造一棵表达式树"></a>构造一棵表达式树</h3><p>一个字符一个字符的读入表达式，若字符是操作数，则压入栈（指向这个单节点树的指针）中，若字符是操作符，则弹出（指向前两个树节点的指针）两棵树，同时注意，先弹出的是右儿子。</p><h1 id="查找树ADT"><a href="#查找树ADT" class="headerlink" title="查找树ADT"></a>查找树ADT</h1><ul><li>特点，对于树中的每个节点X，其中有自身的关键字（比如，int a=100），左子树中的所有关键字均小于X的关键字的值（即，小于100），右子树则大于X的关键字的值（即，大于100）.</li><li>对于上面的特点，重要补充：是节点的所有的左右子树，而非自己的两个子树，包括子树的子树。</li></ul><h2 id="包括的操作"><a href="#包括的操作" class="headerlink" title="包括的操作"></a>包括的操作</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>递归的写，初始化当前树则需要先初始化他的左右子树</p><p>结束条件是树为空指针</p><p>构建树的时候，必须要把树叶的左右都赋值为NULL</p><h3 id="寻找特定值"><a href="#寻找特定值" class="headerlink" title="寻找特定值"></a>寻找特定值</h3><p>天然的二分查找</p><ul><li>注意，先判断当前的树是否为空树</li><li>然后所查找的值大于当前的树则从右边找，否则左边</li><li>结束条件是当前的值</li></ul><h3 id="寻找最小，最大的"><a href="#寻找最小，最大的" class="headerlink" title="寻找最小，最大的"></a>寻找最小，最大的</h3><p>同寻找特定值，不过是一直往左or一直往右</p><p>递归不递归都行</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>可以像寻找特定值一样，做同样的操作。</p><p>找啊找，找了好久，找到一个空节点（NULL）</p><p>则在当前这个空节点，开辟一个空间（指针指向NULL，不等于指针的地址是NULL）</p><p>然后赋值，同时把这个空间的左右儿子都变成NULL</p><p>递归的实现。</p><p>返回值是指向新树根的指针</p><blockquote><p>对于重复元</p><p>可以在结构体里保留附加域，表示重复了几次，也可以其他的数据结构</p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="如果节点有零个儿子（一片树叶）"><a href="#如果节点有零个儿子（一片树叶）" class="headerlink" title="如果节点有零个儿子（一片树叶）"></a>如果节点有零个儿子（一片树叶）</h4><p>立即删除</p><h4 id="如果节点有一个儿子"><a href="#如果节点有一个儿子" class="headerlink" title="如果节点有一个儿子"></a>如果节点有一个儿子</h4><p>把父亲指向该节点的儿子（指向孙子），然后free该节点</p><h4 id="如果节点有两个儿子"><a href="#如果节点有两个儿子" class="headerlink" title="如果节点有两个儿子"></a>如果节点有两个儿子</h4><ul><li>第一步：用其右子树的最小数据代替被删节点的数据，、</li><li>第二步：删除右子树的最小数据节点（将右子树的最小数据节点的父亲，指向最小节点数据的左子树。或者右子树本身就是树叶）</li><li><strong>通过上面的第二步可以看出，实际上是在递归的删除右子树，整个过程可以写成递归</strong></li><li>但是效率不高，所以可以考虑单独写一个删除右子树最小值的函数</li></ul><h3 id="懒惰删除"><a href="#懒惰删除" class="headerlink" title="懒惰删除"></a>懒惰删除</h3><p>做一个删除记号即可</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第四章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>光学</title>
    <link href="/2020/05/22/%E5%85%89%E5%AD%A6/"/>
    <url>/2020/05/22/%E5%85%89%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>重点内容</p><a id="more"></a><ul><li>光的波动性：干涉，衍射，偏振</li><li>粒子性：黑体辐射，光电效应，康普顿效应</li><li>我们只学光的干涉和衍射</li></ul><h1 id="光的干涉"><a href="#光的干涉" class="headerlink" title="光的干涉"></a>光的干涉</h1><h2 id="光的相干性"><a href="#光的相干性" class="headerlink" title="光的相干性"></a>光的相干性</h2><ul><li>相干条件：频率相同，振动方向相同，相位差恒定，</li><li>电磁波近轴光学相干条件补充：振幅差别不能太大，光的光程差不能太大</li></ul><h3 id="光的单色性"><a href="#光的单色性" class="headerlink" title="光的单色性"></a>光的单色性</h3><ul><li><p>单色光，只含单一频率的光</p></li><li><p>复色光，不同频率单色光的混合</p></li><li><p>颜色与波长（真空）与频率对应</p></li><li><p>谱线宽度：光强大于I/2 的成分成分</p></li><li><p>准单色光：谱线宽度窄</p></li><li><p>单色性与相关性为两码事</p></li><li><blockquote><p>复色光也可以获得干涉条纹</p></blockquote></li></ul><h3 id="原子的发光机制"><a href="#原子的发光机制" class="headerlink" title="原子的发光机制"></a>原子的发光机制</h3><ol><li>普通光源，自发辐射</li><li>激光光源：受激辐射</li></ol><h2 id="分波前干涉（重点，又名杨氏双缝干涉"><a href="#分波前干涉（重点，又名杨氏双缝干涉" class="headerlink" title="分波前干涉（重点，又名杨氏双缝干涉"></a>分波前干涉（重点，又名杨氏双缝干涉</h2><h3 id="杨氏双缝干涉"><a href="#杨氏双缝干涉" class="headerlink" title="杨氏双缝干涉"></a>杨氏双缝干涉</h3><ul><li>单缝的作用，保证s1,s2,进行干涉的光是同源的，两者振动方向，频率，初相位都相同</li></ul><h4 id="明纹与暗纹条件"><a href="#明纹与暗纹条件" class="headerlink" title="明纹与暗纹条件"></a>明纹与暗纹条件</h4><ul><li>双缝间距为d</li><li>双缝到屏幕的距离为D</li><li>D远大于d</li><li>相位差为2Π/λ     *波程差</li><li>1，2之间的波程差为r2-r1==d*x/D</li><li>明纹波程差δ=kλ</li><li>暗纹波程差δ=（k+1/2）λ</li><li>解出x的值可得到明暗纹的位置</li></ul><h4 id="条纹特点与变化"><a href="#条纹特点与变化" class="headerlink" title="条纹特点与变化"></a>条纹特点与变化</h4><ul><li>单色光入射<ul><li>明暗相间的平行条纹</li><li>角度不是很大时，条纹等间距</li><li>中间级次低，两边级次高</li><li>Δx=D/d    *λ</li><li>改变S的位置or上下平移双缝，会改变零级明纹的位置，其他不变</li><li>第k级亮纹对应着k倍的D/d   *λ</li></ul></li><li>白光入射<ul><li>可以干涉</li><li>中间为白色，其余明文形成内紫外红的彩带</li><li>清晰可见，为k级红光位置==k+1级紫光的位置</li></ul></li></ul><h4 id="光强曲线"><a href="#光强曲线" class="headerlink" title="光强曲线"></a>光强曲线</h4><p>I=I<del>1</del>+I<del>2</del>+2根号下I<del>1</del>I<del>2</del> cosΔφ</p><p>因为I一般是相等的</p><p>所以I = 4 I<del>0</del> cos^2^ Δφ/2</p><h4 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h4><p>V= （最大光强-最小光强）/（最大光强+最小光强）</p><p>当I相等时，对比度好，V=1</p><p>不相等时，对比度&lt;1,不好</p><h4 id="相干长度"><a href="#相干长度" class="headerlink" title="相干长度"></a>相干长度</h4><p>光程差大于相干长度，可能导致两个波列完全遇不到</p><p>所以只讨论近轴光学</p><h3 id="类双缝干涉"><a href="#类双缝干涉" class="headerlink" title="类双缝干涉"></a>类双缝干涉</h3><h4 id="菲涅尔双棱镜实验"><a href="#菲涅尔双棱镜实验" class="headerlink" title="菲涅尔双棱镜实验"></a>菲涅尔双棱镜实验</h4><h4 id="菲涅尔双面镜实验"><a href="#菲涅尔双面镜实验" class="headerlink" title="菲涅尔双面镜实验"></a>菲涅尔双面镜实验</h4><h4 id="洛埃镜实验"><a href="#洛埃镜实验" class="headerlink" title="洛埃镜实验"></a>洛埃镜实验</h4><ul><li>零级条纹为暗纹，因为发生了半波损失，明暗完全相反，因为只用了一个镜子 </li></ul><h2 id="光程，光程差"><a href="#光程，光程差" class="headerlink" title="光程，光程差"></a>光程，光程差</h2><ul><li>光程：光的等效的真空路程</li><li>光再介质中传播r和在真空中传播nr引起的相位差相同，所以称nr为与介质中路程r相应的光程L=nr</li><li>光通过了多种介质，则将每个介质中的光程相加</li><li>光通过两条光路的光程相减，就能得到光程差</li><li>光程差×2Π/λ 为相位差，λ为真空中的波长</li><li>放水中波长变短</li><li>相位差变大，相邻明暗纹的间距变小</li><li><ul><li>透镜不产生附加光程差。</li></ul></li></ul><h2 id="分振幅干涉（重点，又名薄膜干涉"><a href="#分振幅干涉（重点，又名薄膜干涉" class="headerlink" title="分振幅干涉（重点，又名薄膜干涉"></a>分振幅干涉（重点，又名薄膜干涉</h2><h3 id="薄膜干涉"><a href="#薄膜干涉" class="headerlink" title="薄膜干涉"></a>薄膜干涉</h3><p>例子：昆虫翅膀，彩色花纹，阳光油膜</p><h4 id="薄膜干涉的成因"><a href="#薄膜干涉的成因" class="headerlink" title="薄膜干涉的成因"></a>薄膜干涉的成因</h4><ul><li><p>对于单色入射光，光程差决定明暗情况</p></li><li><p>复色光就变成了彩色光</p></li><li><p>产生干涉的两个光，来自同一束入射光</p><ul><li>入射光的能量被分成了反射光的能量和透射光的能量</li><li>因为能量大小正比于振幅没所以振幅被分割成立两部分</li><li>两次反射形成的反射光相干，两次透射的投射光也相干</li><li>再往后面的就不考虑了，光强太弱了。</li></ul></li><li><p>为什么膜要薄？</p><ul><li><p>太厚无法形成相干现象</p></li><li><p>因为波列长度（相干长度）所限</p></li><li><p>薄厚是相对的，却决于光源的单色性，单色性越好，可以越厚</p><h4 id="两束反射光线的光程差"><a href="#两束反射光线的光程差" class="headerlink" title="两束反射光线的光程差"></a>两束反射光线的光程差</h4></li></ul></li></ul><p><strong>透镜不产生附加光程差</strong></p><ul><li><p>设薄膜的厚度为e，</p><ul><li><p>以下四种是反射光的情况！！！！！！！！！</p></li><li><p>第一种情况，中间是n<del>2</del>，两边的折射率都是n<del>1</del> 且两边折射率小于中间，n<del>2</del> 即为膜</p><ul><li><p>需要透镜使反射管叠加，相干</p></li><li><p>写出到，相干点，的光程差</p></li><li><blockquote><p>考虑半波损失：<strong>光疏到光密，有半波损</strong>。从n1到n2，有半波损。光疏为n小，空气最小</p></blockquote></li><li><p>将AB BC AD 均用i，r和e表示出来</p><ul><li>且考虑到折射定律n1sini=n2sin2</li><li>i表示入射角，r表示折射角</li></ul></li><li><p>光程差==2en<del>2</del> cosr + λ/2（但因为一般我们不知道折射角，所以</p><ul><li>n<del>2</del>cosr用根号下n<del>2</del>^2^ -n<del>1</del>2^2^sini 来表示（由折射定律平方得到的结果</li></ul></li><li><p>当光程差=kλ时，明纹（λ为波长</p></li><li><p>当光程差为λ/2的奇数倍的时候，暗纹</p></li></ul></li><li><p>第二种情况，折射率不断增大，均有半波损失，导致光程差里无，λ/2</p></li><li><p>第三种情况，不断减小，均无半波损失，导致光程差里无。</p></li><li><p>第四种情况，中间最小，两边更大，（中间空气，两边玻璃板），有，光程差里也有。</p></li><li><p>对于透射光的情况，与反射光相反</p></li></ul></li></ul><h4 id="增透膜，增反膜"><a href="#增透膜，增反膜" class="headerlink" title="增透膜，增反膜"></a>增透膜，增反膜</h4><ul><li><p>当n<del>1</del> &lt; n<del>2</del> &gt; n<del>1</del>时，透射光的光程差无半波损，反射光有，导致相位差相差Π，导致明暗情况相反。</p><ul><li>所以，若透射光干涉相长，则反射光一定干涉相消（增透膜</li><li>若反射光干涉相长，则透射光干涉相消（增反膜</li><li>为能量守恒导致的必然结果。</li></ul></li><li><p>为什么镜头呈现紫红色？</p><ul><li>呈现紫红色实质是在说反射光是紫红色。</li><li>原本的目的是为了让黄绿光增透，但也就导致了紫红色的光被增反了</li><li>黄绿光透射相长了，导致其反射光反射相消了</li><li>让黄绿光透射过来，但是同时紫红色被增反了，</li><li>在折射率依次增大的条件下，反射光无半波损，而透射光有了半波损<ul><li>使用公式反射光的 光程差==2en<del>2</del> cosr，其中 n<del>2</del>cosr用根号下n<del>2</del>^2^ -n<del>1</del>2^2^sini代替</li><li>因为光是垂直入镜头（生活常识<ul><li>所以i=0</li><li>所以反射光的光程差==2en<del>2</del></li></ul></li><li>使黄绿光满足相消条件，则可以得到增添膜的厚度</li><li>然后将这个e带入相长式子，带入不同的k。求λ，得到对应紫红色光的波长</li><li>光学中称这两种光为互补色</li></ul></li></ul></li></ul><h4 id="例题，与其他需要注意的"><a href="#例题，与其他需要注意的" class="headerlink" title="例题，与其他需要注意的"></a>例题，与其他需要注意的</h4><p>1埃==10^-10^ 米</p><h3 id="两种干涉（等厚度，等倾角"><a href="#两种干涉（等厚度，等倾角" class="headerlink" title="两种干涉（等厚度，等倾角"></a>两种干涉（等厚度，等倾角</h3><ul><li>前提：光程差是关于e和i的二元韩式，所以针对e和i的不同情况，分出这样的两类</li></ul><h4 id="等厚干涉（固定入射角）"><a href="#等厚干涉（固定入射角）" class="headerlink" title="等厚干涉（固定入射角）"></a>等厚干涉（固定入射角）</h4><p>同一个厚度，对应同一级的条纹——等厚条纹</p><h5 id="劈尖"><a href="#劈尖" class="headerlink" title="劈尖"></a>劈尖</h5><ul><li>定义：夹角很小的两个平面所构成的薄膜，因为夹角很小，所以两个入射角都视为0</li><li>发生干涉的两列光是空气薄膜的上下表面的两列光</li><li>有半波损</li></ul><h6 id="条纹特点及变化"><a href="#条纹特点及变化" class="headerlink" title="条纹特点及变化"></a>条纹特点及变化</h6><ul><li>劈棱处，e=0，波程差λ/2 暗纹</li><li>其他暗纹，代公式即可得到</li><li>相邻暗/明纹的厚度差为λ/2n，（为竖着的差值）</li><li>相邻条纹（明纹与明纹，暗纹与暗纹）的间距，因为Δe=bsinθ=bθ，所以<ul><li>b=Δe/θ=λ/2nθ</li><li>θ减小，则条纹间距变大，则条纹变散，反之也反<ul><li>因为零级暗纹不动，所以可以用它来分析</li></ul></li><li>增大减小版间距，则看零级暗纹是怎么走的<ul><li>只是条纹整体平移</li></ul></li></ul></li><li>每移动一个条纹，膜厚的改变量就是相邻条纹的厚度差，膜厚增加，各处的级次都在升高</li></ul><h6 id="劈尖的应用"><a href="#劈尖的应用" class="headerlink" title="劈尖的应用"></a>劈尖的应用</h6><ol><li>测量条纹间距求波长，折射率，细小物体的厚度，微小的变化</li><li>测量表面平整度，同一条纹对应空气空气薄膜的厚度相同，所以看条纹的偏着方向，判断待测平面上是否有突起，凹陷</li></ol><h5 id="牛顿环"><a href="#牛顿环" class="headerlink" title="牛顿环"></a>牛顿环</h5><p>底部为平晶，上部为曲率半径（<strong>为了空气薄膜足够薄</strong>）超大的平凸透镜，底部与上部接触。反射光。</p><p><em>以上为本节中讨论的基本情况</em></p><blockquote><p>有多种变体</p><ol><li>改变形状<ol><li>柱体<ol><li>直条纹</li></ol></li><li>球形<ol><li>同心圆</li></ol></li></ol></li><li>底部与顶部的位置<ol><li>接触</li><li>不接触</li></ol></li><li>从圆心看过去<ol><li>内薄外厚</li><li>内厚外薄</li></ol></li><li>光的类型<ol><li>反射光</li><li>透射光</li></ol></li><li>折射率大小<ol><li>分为四种情况</li></ol></li></ol></blockquote><p>针对<em>基本情况</em></p><p>光程差为2en+λ/2，因为n为1，所以光程差为2e+λ/2</p><p>然后把膜厚e用r表示出来，通过勾股一通，加上忽略忽略，得到e=r^2^/2R，这样，光程差=r^2^/R+λ/2</p><h6 id="条纹特点及变化-1"><a href="#条纹特点及变化-1" class="headerlink" title="条纹特点及变化"></a>条纹特点及变化</h6><ul><li>一系列不同r的圆环——牛顿环</li><li>各级暗环半径，光程差==λ/2的奇数倍，得到半径公式为根号下kRλ（<em>仅针对基本情况</em>）<ul><li>明环，也易求</li></ul></li><li>级次：内低外高<ul><li>正比于根号k，</li><li>中心为0级暗纹 </li></ul></li><li>条纹间距：内疏外密（因为与上面的平凸透镜的斜率有关<ul><li>条纹间距=λ/2Πθ，斜率大，则θ大，则条纹间距小，则密</li><li><em>基本情况</em> 中，条纹间距正比于根号k和根号（k-1）的差值</li></ul></li><li>白光入射：内紫外红</li><li>平凸透镜<ul><li>理解方法：将牛顿环视为两个劈尖尖对尖，然后迎刃而解</li><li>上移：内陷</li><li>下移：冒出</li><li>公式的推导：上移d导致再光程差里+2d<ul><li>当r不变时，δ增大，则k大了<ul><li>k与δ是一一对应的</li></ul></li></ul></li><li>每冒出一个条纹，厚度增减λ/2n（<em>即一个条纹间距</em>）</li></ul></li><li>透射光，与反射光的亮暗纹相反，完全相反</li></ul><h6 id="牛顿环的应用"><a href="#牛顿环的应用" class="headerlink" title="牛顿环的应用"></a>牛顿环的应用</h6><ol><li>已知波长，测量曲率半径</li><li>已知曲率半径，测量波长</li><li>检验透镜的表面质量</li></ol><blockquote><p>用Δk来求，k^2^ -k<del>1</del>^2^</p></blockquote><h4 id="等倾干涉（固定厚度）"><a href="#等倾干涉（固定厚度）" class="headerlink" title="等倾干涉（固定厚度）"></a>等倾干涉（固定厚度）</h4><p>同一个倾角，对应同一个级次的条纹——等倾条纹</p><ul><li>等倾干涉条纹的半径公式为r=f tg i   ，f为焦距，tg i  为i的正切值 tan，与明暗无关</li></ul><h6 id="条纹特点"><a href="#条纹特点" class="headerlink" title="条纹特点"></a>条纹特点</h6><ul><li>形状，同心圆环</li><li>条纹级次分布<ul><li>内高外低，由公式得到，k高则δ（<em>光程差</em>）高，则i小，则r小</li><li>正入射，级次最高</li></ul></li><li>圆环中心，级次为k=2ne/λ +1/2 ，若k为整数，则明纹，若半整数，则暗纹，否则则是之间的</li><li>波长对同级条纹的影响：k，e一定，λ22增加，则i减小，则r减小，则在里面，所以内红外紫</li><li>条纹间隔：δ=2ne * cosγ +λ/2 =kλ，对k，γ，然后dk取-1，（<em>因为内高外低</em>）求微分<ul><li>得到角间距，一通推理</li><li>内疏外密（所有都是内疏外密）</li></ul></li><li>膜厚的变化对条纹的影响<ul><li>厚度增加，冒出</li><li>膜厚减小，内陷</li><li>怎么思考<ul><li>内高外低的级次分布</li><li>劈尖背对背</li><li>厚度增加等价于往外移动，冒出</li><li>或者用光程差公式来考虑</li></ul></li><li>冒出一个条纹，膜厚增加λ/2ne</li></ul></li></ul><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p><img src="https://i.loli.net/2020/05/29/jVMgDtKBTac2Rrp.png" srcset="/img/loading.gif" alt="image-20200529141108395"></p><p><img src="https://i.loli.net/2020/05/29/AWfFXtNUsyYzCq8.png" srcset="/img/loading.gif" alt="image-20200529141740713"></p><h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><p>薄膜干涉可以使用扩展光源，增大条纹亮度</p><ul><li>不管哪个点光源，只要入射角i相同，就会汇聚到一个圆环上，从而条纹更亮了</li></ul><p>等倾干涉用来凸透镜，定域于无限远处，等厚干涉不用透镜</p><h2 id="迈克尔逊干涉仪"><a href="#迈克尔逊干涉仪" class="headerlink" title="迈克尔逊干涉仪"></a>迈克尔逊干涉仪</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>太神奇了，不可思议，难以置信，尤其是空气虚膜，简直了</p><ul><li>当M<del>1</del>^’^与M<del>2</del> 平行时，等倾条纹</li><li>当M<del>1</del>^’^与M<del>2</del> 由小夹角时，等厚条纹</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>测量波长，微小位移</p><p>测量介质折射率</p><blockquote><p>产生的附加光程差为2(n-1)L=Nλ，因为来回两次</p></blockquote><h1 id="光的衍射"><a href="#光的衍射" class="headerlink" title="光的衍射"></a>光的衍射</h1><h2 id="惠更斯——菲涅尔原理"><a href="#惠更斯——菲涅尔原理" class="headerlink" title="惠更斯——菲涅尔原理"></a>惠更斯——菲涅尔原理</h2><blockquote><p>子波干涉</p></blockquote><h3 id="光的衍射现象"><a href="#光的衍射现象" class="headerlink" title="光的衍射现象"></a>光的衍射现象</h3><ul><li>定义：光在传播过程中绕过障碍物而偏离直线传播的现象</li></ul><h3 id="衍射的分类"><a href="#衍射的分类" class="headerlink" title="衍射的分类"></a>衍射的分类</h3><h4 id="菲涅耳衍射（不学习）（近场衍射"><a href="#菲涅耳衍射（不学习）（近场衍射" class="headerlink" title="菲涅耳衍射（不学习）（近场衍射"></a>菲涅耳衍射（不学习）（近场衍射</h4><ul><li>定义：光源    <strong><em>||</em></strong>   屏幕           与障碍物有限远</li></ul><h4 id="夫琅禾夫衍射（远场衍射）"><a href="#夫琅禾夫衍射（远场衍射）" class="headerlink" title="夫琅禾夫衍射（远场衍射）"></a>夫琅禾夫衍射（远场衍射）</h4><ul><li>定义：光源   <strong><em>&amp;&amp;</em></strong>   屏幕           与障碍物无限远<ul><li>即平行光的衍射</li></ul></li></ul><h3 id="惠更斯——菲涅尔原理主要内容"><a href="#惠更斯——菲涅尔原理主要内容" class="headerlink" title="惠更斯——菲涅尔原理主要内容"></a>惠更斯——菲涅尔原理主要内容</h3><blockquote><p>基本不用这个原理</p></blockquote><ul><li>惠更斯原理：<ul><li>波前的任何一点都是子波的波源</li></ul></li><li>菲涅尔<ul><li>各子波在空间某点的相干叠加，决定了该点波的强度</li></ul></li></ul><p>倾斜因子k，当θ=0时，k最大，θ大于90°，k==0</p><ul><li>点波源发出的球面波，Kθ==   (1+cosθ) / 2</li></ul><p>利用菲涅尔衍射积分公式，原则上可以计算任意形状 的波阵面衍射问题，but非常复杂</p><p>所以菲涅尔提出半波带法，在处理有对称性的问题时，方便且物理图像清晰</p><h2 id="单缝的夫琅禾夫衍射（重点"><a href="#单缝的夫琅禾夫衍射（重点" class="headerlink" title="单缝的夫琅禾夫衍射（重点"></a>单缝的夫琅禾夫衍射（重点</h2><h3 id="半波带法"><a href="#半波带法" class="headerlink" title="半波带法"></a>半波带法</h3><blockquote><p>正入射</p></blockquote><ul><li>θ：衍射角，屏幕上的p点与轴线中心的连线，与轴线的夹角</li><li>a：单缝的宽度，（是窄的部分</li><li>仅考虑通过单缝边缘的两条边的光程差<ul><li>做的是真的垂面，不像双缝，是近似</li></ul></li><li>光程差为：a×sinθ<ul><li>当θ==0时，中央明纹中心，最亮的地方</li><li>当光程差==λ时，通过<ul><li>此时，上面与中间的光程差是半波长，然后整体下平移，不难得出，每条光都有与他λ/2 的</li><li>此时是第一级暗纹</li></ul></li></ul></li><li>δ为λ * 3/2<ul><li>三个半波带，相邻两个相消，剩下一个不抵消</li><li>次级明纹 </li></ul></li><li>实际上刺激明纹中心的位置略微偏向主极大一侧</li><li>当正好为奇数个半波带时，屏幕上的强度，并不知极大的</li><li>衍射光强随着θ角的增大而减小</li><li>δ==2 λ时，<ul><li>第二级暗纹</li></ul></li></ul><h3 id="用旋转矢量法推导光强公式"><a href="#用旋转矢量法推导光强公式" class="headerlink" title="用旋转矢量法推导光强公式"></a>用旋转矢量法推导光强公式</h3><p>将缝分成N个窄带</p><p>则每个窄带的（子波）的宽度就是确定的，为a/N</p><p>则相邻窄带之间的光程差为Δxsinθ，</p><p>则相邻窄带到p点的相位差也是确定的，相位差等于光程差×角波数（2Π/λ）</p><p>同时各窄带的宽度相同，所以在p点引起的振幅相同</p><blockquote><p>由上可推</p></blockquote><p>p点处N个同方向、同频率、同振幅、相位依次差Δφ的简谐振动的合成</p><p>使用旋转矢量</p><p>得到</p><ul><li>E<del>p</del> = 2 R sin(ΔΩ/2)</li><li>ΔΩ=NΔφ=2Π/λ  *  asinθ</li><li>弧长E=NΔE<del>0</del> </li></ul><p>光强公式</p><p><img src="https://i.loli.net/2020/06/02/DSGl8fRYXdzrqsy.png" srcset="/img/loading.gif" alt="image-20200602180030770"></p><ol><li><p>主极大（中央明纹中心</p><ol><li>θ==0，相位差为0，旋转矢量排成直线</li></ol></li><li><p>极小的时候，ΔΩ==2kΠ，β为ΔΩ/2，==kΠ，则一通推导，得到光程差为偶数倍的那个结论</p></li><li><p>次级大（中心）位置</p><ol><li>tgβ=β</li></ol></li><li><p>光强曲线</p><ol><li>图像<ol><li><img src="https://i.loli.net/2020/06/02/rXst3f56lNFAL7u.png" srcset="/img/loading.gif" alt="image-20200602181228209"></li></ol></li></ol></li></ol><h3 id="衍射条纹宽度及变化"><a href="#衍射条纹宽度及变化" class="headerlink" title="衍射条纹宽度及变化"></a>衍射条纹宽度及变化</h3><h4 id="中央明纹的宽度"><a href="#中央明纹的宽度" class="headerlink" title="中央明纹的宽度"></a>中央明纹的宽度</h4><p>   由半波带法的内容可知，asinθ=1·λ，然后用θ近似sinθ</p><p>   半角宽=λ/a</p><p>   角宽度=2λ/a</p><p>   线宽度=2f·tanθ=2f λ/a</p><h4 id="次级大宽度"><a href="#次级大宽度" class="headerlink" title="次级大宽度"></a>次级大宽度</h4><p>   x<del>k</del>=f · tgθ<del>k</del>=f sin θk=f kλ/a          (由asinθ<del>k</del>=kλ得到)，x<del>k</del> 为第k级暗纹的位置</p><p>   Δx=x<del>k+1</del>-x<del>k</del>=fλ/a=上文线宽度的一半</p><h4 id="缝宽变化对条纹宽度的影响"><a href="#缝宽变化对条纹宽度的影响" class="headerlink" title="缝宽变化对条纹宽度的影响"></a>缝宽变化对条纹宽度的影响</h4><p>   缝宽越小，明纹越宽——衍射反比定律</p><p>   当λ/a 趋于1时，第一级暗纹的位置的角 趋于90°，第一级暗纹趋于无穷远，则屏幕上只有主极大</p><p>   当λ/a趋于0时，角度趋于0，各级明纹向中央靠拢，单缝的几何光学像</p><h4 id="波长λ对条纹宽度的影响"><a href="#波长λ对条纹宽度的影响" class="headerlink" title="波长λ对条纹宽度的影响"></a>波长λ对条纹宽度的影响</h4><p>   波长越长，明纹宽度越宽，白光入射，各级明纹内紫外红</p><h4 id="改变光源或透镜位置的影响"><a href="#改变光源或透镜位置的影响" class="headerlink" title="改变光源或透镜位置的影响"></a>改变光源或透镜位置的影响</h4><p>   光源下移，则相当于透镜上移，发现整体向上移动</p><h4 id="改变单缝位置的影响"><a href="#改变单缝位置的影响" class="headerlink" title="改变单缝位置的影响"></a>改变单缝位置的影响</h4><p>   单缝上下移动 ，条纹不动，但是两侧呈现的条 纹的数目不同</p><h2 id="光学仪器的分辨本领"><a href="#光学仪器的分辨本领" class="headerlink" title="光学仪器的分辨本领"></a>光学仪器的分辨本领</h2><h3 id="圆孔的夫琅禾夫衍射"><a href="#圆孔的夫琅禾夫衍射" class="headerlink" title="圆孔的夫琅禾夫衍射"></a>圆孔的夫琅禾夫衍射</h3><p>会产生中央亮斑，叫艾里斑</p><p>r/f =1.22 λ/D   波长短or圆孔（D，圆孔直径）大，艾里斑变小。</p><p>衍射越强，分辨本领越弱</p><h3 id="透镜的分辨本领"><a href="#透镜的分辨本领" class="headerlink" title="透镜的分辨本领"></a>透镜的分辨本领</h3><h4 id="物与像的关系"><a href="#物与像的关系" class="headerlink" title="物与像的关系"></a>物与像的关系</h4><ul><li>几何光学<ul><li>象是几何点</li></ul></li><li>波动光学<ul><li>象是艾里斑</li></ul></li><li>两个物点成像<ul><li>两个艾里斑非相干叠加</li><li>有可能就无法分辨了</li></ul></li></ul><h4 id="瑞利判据"><a href="#瑞利判据" class="headerlink" title="瑞利判据"></a>瑞利判据</h4><ul><li>内容：两个等光强的非相干物点，如果一个相伴的中心恰好落在另一个象斑的边缘（第一级暗纹处），则他们刚好可以分辨 </li></ul><h4 id="分辨本领"><a href="#分辨本领" class="headerlink" title="分辨本领"></a>分辨本领</h4><ul><li>满足瑞利判据时，两物点间的距离，就是光学仪器的  <strong>最小分辨距离</strong></li><li><strong>最小分辨距离</strong>对透镜中心的张角为<strong>最小分辨角</strong>（越小越好<ul><li>也就是第一级暗纹的衍射角，叫做θ<del>1</del> 1.22 λ/D </li><li>不是2θ<del>1</del></li><li>D是透镜的孔径，与最小分辨角θ<del>1</del> 反比关系<ul><li>孔径越大，最小分辨越小，越易于分辨 </li></ul></li><li>物体实际张开的夹角（叫做θ）小于θ<del>1</del>，则不可分辨（<em>显然，实际张开角，越大越好</em> ）</li><li>若两物点之间相距d，物点与透镜相距L，则θ=d/L</li></ul></li><li>举例：夜间观看汽车灯，远看是一个亮点，近看才是两个灯，因为远看的时候L超大，θ超小，θ就小于θ<del>1</del> 了，就不可分辨了</li></ul><blockquote><p>最小分辨角的倒数称为仪器的<strong><em>分辨本领</em></strong></p><p>用R表示</p><p>R=D/1.22 λ</p></blockquote><p>增大D或者减小λ，均能增大分辨本领，同时都会造成艾里斑半径变小，也就是使得衍射效应不明显</p><p><em>圆孔衍射</em>的衍射公式对<em>抛物面式</em>的天线雷达均成立。  </p><ul><li>对于望远镜，λ不可选择，所以只能增大R</li><li>对于显微镜，D不能很大，用更短的λ来增大分辨本领</li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ol><li>人眼的分辨本领</li></ol><h2 id="光栅衍射（最重点"><a href="#光栅衍射（最重点" class="headerlink" title="光栅衍射（最重点"></a>光栅衍射（最重点</h2><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>单缝衍射，次级大宽度f λ/a</p><p>假如缝宽太小，则条纹间距大，但条纹变暗，看不清</p><p>如果缝宽大，则条纹间距小，条纹亮，看不清</p><p>所以为了得到亮度大，分得开，宽度窄的明条纹，需要光栅所形成的衍射图样——光栅光谱</p><h3 id="什么是光栅"><a href="#什么是光栅" class="headerlink" title="什么是光栅"></a>什么是光栅</h3><p>大量等宽，等间距的平行狭缝构成的光学元件，叫做光栅</p><p>a：狭缝宽度</p><p>b：缝间不透光部分的宽度</p><p>d=a+b：光栅常数，即相邻两缝对应点之间的距离，表示光栅的空间周期性</p><h3 id="光栅的夫琅禾夫衍射"><a href="#光栅的夫琅禾夫衍射" class="headerlink" title="光栅的夫琅禾夫衍射"></a>光栅的夫琅禾夫衍射</h3><p>光栅演示=单缝衍射+多缝干涉</p><h4 id="多光束干涉"><a href="#多光束干涉" class="headerlink" title="多光束干涉"></a>多光束干涉</h4><p>N个缝，每个缝发的光在固定点的光振动的振幅都是E<del>p</del>，因为到达同一个点，要求这 些光从缝中出来后的角度相同，这样才能到达同一个点上，也就是取任意点，也可以说是任取衍射角θ的大小，相邻缝发出的光的光程差δ=dsinθ，则相位差Δφ为2Π/λ   ×   dsinθ从而可知，p点处是N个同方向，同频率，同振幅，相位依次差Δφ的简谐振动的合成，为可以构成正多边形的简谐振动的合成</p><h5 id="干涉主极大"><a href="#干涉主极大" class="headerlink" title="干涉主极大"></a>干涉主极大</h5><p>相位差为 2kΠ，则旋转矢量构成一条直线，则总和为NE<del>p</del></p><ul><li>干涉主极大的条件是dsinθ=+-kλ，此为正入射时的光栅方程</li><li>主极大位置与N无关，相邻主极大的角间距为λ/d，线间距为 fλ/d <ul><li>单缝衍射次级明纹的角宽度为λ/a  线宽度fλ/a</li><li>双缝干涉角间距λ/a  线间距Dλ/d</li><li>主极大衍射中央包络的半角宽是λ/a</li></ul></li><li>主极大和光强与N^2^E^2^成正比，缝越多，合光强越大</li></ul><h5 id="干涉暗纹"><a href="#干涉暗纹" class="headerlink" title="干涉暗纹"></a>干涉暗纹</h5><p>振幅矢量构成闭合多边形，NΔφ=2k‘ Π （k’！=0，&amp;&amp;！=Nk</p><p>当k‘==0时，δφ==0，为主极大</p><p>当k‘==NK时，N可以被消除，又为主极大（干涉暗纹的条件d sinθ==k’/N   *  λ</p><ul><li><p>干涉暗纹的条件d sinθ==k’/N   *  λ</p></li><li><p>相邻暗纹间距Δθ‘ ==λ/Nd </p><ul><li>这也是次级明纹的宽度，也主极大的半角宽 </li><li>所以两个主极大之间有N-1个暗纹，每两个安稳之间，有1个次级明纹</li><li>所以两个主极大之间有N-2个次级大<ul><li>次级大对应和矢量为外接圆直径</li></ul></li></ul></li></ul><h5 id="结论与例子"><a href="#结论与例子" class="headerlink" title="结论与例子"></a>结论与例子</h5><p>光栅缝越多，每根谱线（主极大）越细（主极大的半角宽为Δθ‘ ==λ/Nd ），谱线间的暗纹越多（N-1个暗纹），次级明纹的强度非常非常低，谱线越尖锐明亮（N^2^E^2^），越便于观测</p><p>例子：<img src="https://i.loli.net/2020/06/09/FsvhQ3R6LbicxDK.png" srcset="/img/loading.gif" alt="例子"></p><h4 id="每个缝的衍射效应对干涉主极大强度的调制"><a href="#每个缝的衍射效应对干涉主极大强度的调制" class="headerlink" title="每个缝的衍射效应对干涉主极大强度的调制"></a>每个缝的衍射效应对干涉主极大强度的调制</h4><p>因为单缝上下移动，条纹位置不变，所以每个缝的衍射光重叠的</p><p>总强度的分布，是穿过各缝的衍射光的相干叠加，</p><p>在衍射暗纹位置，因为到达此处的衍射光强为0，所以无论此点相长or相消，干涉后强度仍然为0，因而<strong><em>当干涉主极大的位置与衍射暗纹的位置重合时，是暗纹</em></strong></p><h3 id="光栅衍射的条纹特点与变化"><a href="#光栅衍射的条纹特点与变化" class="headerlink" title="光栅衍射的条纹特点与变化"></a>光栅衍射的条纹特点与变化</h3><h4 id="缺级现象（重要"><a href="#缺级现象（重要" class="headerlink" title="缺级现象（重要"></a>缺级现象（重要</h4><p>干涉主极大位置与衍射暗纹位置重合，则缺级</p><p>干涉主极大dsinθ=kλ</p><p>衍射暗纹asinθ‘ =k’λ</p><p>由θ==θ’ 可知，d/a=k/k‘</p><p>此时出现干涉条纹缺级</p><p>k=d/a  k’   出现缺级现象，比如d=2a，则偶数级都缺</p><p>主极大衍射中央包络的半角宽是λ/a</p><p>d/a决定了衍射中央包络的干涉主极大的数目</p><p><img src="https://i.loli.net/2020/06/09/7WnAzmaLGHiIZKk.png" srcset="/img/loading.gif" alt="image-20200609165431507"></p><p>d/a 的值向上取整数</p><h4 id="d、a对条纹的影响"><a href="#d、a对条纹的影响" class="headerlink" title="d、a对条纹的影响"></a>d、a对条纹的影响</h4><ul><li>若a不变，则单缝衍射的轮廓线不变<ul><li>d减小，则干涉主极大间距变大（相邻主极大的角间距为λ/d）</li><li>则单缝衍射中央亮纹中的干涉主极大数目减少，若出现缺级，则缺级的级次（d/a）变低</li></ul></li><li>若d不变，干涉主极大的位置不变<ul><li>a减小，单缝衍射的轮廓线变宽（单缝衍射次级明纹的角宽度为λ/a）</li><li>衍射中央包络内干涉主极大增多， 缺级的级次变高</li><li>当a趋于λ时，各主极大光强几乎相同</li></ul></li></ul><h4 id="缝数N对条纹的影响"><a href="#缝数N对条纹的影响" class="headerlink" title="缝数N对条纹的影响"></a>缝数N对条纹的影响</h4><p>缝数越多，越亮，干涉主极大越尖细（干涉主极大半角宽为λ/Nd），相邻干涉主极大之间，暗纹越多</p><p>例题：<img src="https://i.loli.net/2020/06/09/s2nU3pXICSEqP8K.png" srcset="/img/loading.gif" alt="image-20200609171202312"></p><h4 id="复色光入射"><a href="#复色光入射" class="headerlink" title="复色光入射"></a>复色光入射</h4><p>中央零级明条纹为白光，其他主极大由各种颜色的条纹组成，内紫外红的分布</p><p>级次越高，分的越开</p><h4 id="斜入射的光栅方程"><a href="#斜入射的光栅方程" class="headerlink" title="斜入射的光栅方程"></a>斜入射的光栅方程</h4><p>δ=d（sinθ-sini），1-2的相位差，是2-1的光程差，θ为衍射角，i为入射角</p><blockquote><ul><li><p>相位差为2Π/λ     *波程差</p></li><li><p>1，2之间的波程差为r2-r1==d*x/D</p></li></ul></blockquote><p>关于角度的正负</p><ul><li>由法线转向光线，逆时针为正</li></ul><p>斜入射的光栅方程，</p><p>δ=+-kλ （斜入射干涉主极大条件</p><ul><li>斜入射可获得更高级次的条纹，分辨率更好</li></ul><h3 id="光栅衍射的光强公式（正入射，了解即可）"><a href="#光栅衍射的光强公式（正入射，了解即可）" class="headerlink" title="光栅衍射的光强公式（正入射，了解即可）"></a>光栅衍射的光强公式（正入射，了解即可）</h3><p>p点处是N个同方向，同频率，同振幅，相位依次差Δφ的简谐振动的合成，为可以构成正多边形的简谐振动的合成</p><p><img src="https://i.loli.net/2020/06/09/IDeuk5l1zNqypUd.png" srcset="/img/loading.gif" alt="image-20200609173647839"></p><blockquote><p><strong>下图中I<del>0单</del>是E<del>0单</del> 的平方</strong></p></blockquote><p><img src="https://i.loli.net/2020/06/09/nLG7Jye5DtbOWPz.png" srcset="/img/loading.gif" alt="image-20200609173923455"></p><h2 id="X射线衍射（不学"><a href="#X射线衍射（不学" class="headerlink" title="X射线衍射（不学"></a>X射线衍射（不学</h2>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
      <category>光学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理科</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法公开课（三）</title>
    <link href="/2020/05/21/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/05/21/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天凑活听一听吧</p><a id="more"></a><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>STL中的函数</p><p>lower_bound ,返回第一个符合条件的元素的位置，第一个大于等于这个数的位置</p><p>upper_bound 返回最后一个符合条件的元素的位置，第一个大于这个数的位置</p><p>（返回的是指针</p><ul><li>取区间中点为了不爆int，应该l+（r-l）</li><li>为了不死循环，看【1，2】，【2，3】</li><li>关于浮点数误差，循环除二然后比较</li><li>当有些问题进行验证更简单的时候，就用二分来验证</li></ul><p><img src="https://i.loli.net/2020/05/21/bX34mARTNrykWKE.png" srcset="/img/loading.gif" alt="image-20200521201922883"></p><p>假设有一个ans的，小于ans的直接晾干，大于ans时列式子计算用时，然后加起来看跟ans的关系</p><h2 id="最大值的最小or最小值的最大值"><a href="#最大值的最小or最小值的最大值" class="headerlink" title="最大值的最小or最小值的最大值"></a>最大值的最小or最小值的最大值</h2><p>二分，或贪心。</p><h2 id="N行4列的数，每一列选一个数，问使他们的和为0的情况有多少种"><a href="#N行4列的数，每一列选一个数，问使他们的和为0的情况有多少种" class="headerlink" title="N行4列的数，每一列选一个数，问使他们的和为0的情况有多少种"></a>N行4列的数，每一列选一个数，问使他们的和为0的情况有多少种</h2><ol><li>暴力，n^4^</li><li>先加前三列，然后第四列排序，然后查找是否有前三列和的相反数，n^3^</li><li>两列，两两相加，然后一列排序，然后查找相反数，复杂度n^2^ logn，（可用两个指针，然后从两头开始往中间走，若和为负则xxxx，若和为正则xxxx）</li><li></li></ol><h2 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h2><p>求单峰，单谷函数，求极值点</p><p>将左右界切成三分，然后每次删1/3，</p><p>或者对导数二分，</p><p>而导数用两个点求k，Δx很小</p><h2 id="01分数规划"><a href="#01分数规划" class="headerlink" title="01分数规划"></a>01分数规划</h2><p>一堆物品，有一个收益，有一个代价，给出一个方案，使得收益/代价 最大。</p><ol><li>首先证明以单个的受益/代价 的贪心是错的</li><li>先假设最大值大于等于x</li><li>然后移项可得<ol><li>收益-x代价大于等于0</li><li>所以贪心应为收益-x代价必须全选正的，</li><li>所以二分x，看求和结果是不是大于x</li><li>若不成立，说明这个x取大了</li><li>x为和，为最后的结果</li></ol></li><li>若为不是若干个而是k个，则应该让大于零的数应该有k个 </li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>倍增：</p><p>a的b次方膜p的值</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>二分，三分，01分数规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电磁振荡和电磁波</title>
    <link href="/2020/05/19/%E7%94%B5%E7%A3%81%E6%8C%AF%E8%8D%A1%E5%92%8C%E7%94%B5%E7%A3%81%E6%B3%A2/"/>
    <url>/2020/05/19/%E7%94%B5%E7%A3%81%E6%8C%AF%E8%8D%A1%E5%92%8C%E7%94%B5%E7%A3%81%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<p>不是很重要，简单看一看</p><a id="more"></a><h1 id="振荡电路"><a href="#振荡电路" class="headerlink" title="振荡电路"></a>振荡电路</h1><h2 id="振动电路：产生电磁振荡的电路"><a href="#振动电路：产生电磁振荡的电路" class="headerlink" title="振动电路：产生电磁振荡的电路"></a>振动电路：产生电磁振荡的电路</h2><p>LC电磁振荡电路</p><p>不断在L充电，C充电之间循环</p><p>振荡方程：振荡量的变化所遵循的方程</p><h2 id="无阻尼的电磁振荡的振荡方程"><a href="#无阻尼的电磁振荡的振荡方程" class="headerlink" title="无阻尼的电磁振荡的振荡方程"></a>无阻尼的电磁振荡的振荡方程</h2><p>q=Qcos（wt+φ）</p><p>T=2Π根号下LC</p><h2 id="无阻尼电磁振荡的能量"><a href="#无阻尼电磁振荡的能量" class="headerlink" title="无阻尼电磁振荡的能量"></a>无阻尼电磁振荡的能量</h2><p>总能量是守恒的， </p><p>W总=Q^2^ /2C=1/2 L I^2^</p><p>电场能量==1/2 C U^2^</p><h2 id="LC电磁振荡与弹簧振子类比"><a href="#LC电磁振荡与弹簧振子类比" class="headerlink" title="LC电磁振荡与弹簧振子类比"></a>LC电磁振荡与弹簧振子类比</h2><p><img src="https://i.loli.net/2020/05/19/grTFKXn71EfcuaU.png" srcset="/img/loading.gif" alt="image-20200519174433144"></p><h1 id="电磁波"><a href="#电磁波" class="headerlink" title="电磁波"></a>电磁波</h1><h2 id="电磁波的产生与传播"><a href="#电磁波的产生与传播" class="headerlink" title="电磁波的产生与传播"></a>电磁波的产生与传播</h2><p>满足的条件</p><ol><li>电路开放</li><li>振动频率足够高<ol><li>辐射能量与频率的四次方正比</li><li>减小LC</li><li>直接变成振荡电偶极子</li></ol></li></ol><p>E×H的方向是电磁波传播的方向 </p><p>电磁波往x方向走，则电场在y方向（竖着，一般认为的Z方向）振荡，磁场在z方向振荡</p><ul><li>在赤道方向，最强</li><li>南北极方向，无电磁波</li><li>EH之间有比例关系。</li><li>真空中E=CB</li></ul><p>离电偶极子很远，认为是平面波</p><h2 id="电磁波的能量和能流"><a href="#电磁波的能量和能流" class="headerlink" title="电磁波的能量和能流"></a>电磁波的能量和能流</h2><p>辐射能量：以电磁波形式传播的能流</p><p>平均能流密度S=1/2  EH</p><p>坡印廷矢量S=E×H</p><h2 id="电磁波的应用"><a href="#电磁波的应用" class="headerlink" title="电磁波的应用"></a>电磁波的应用</h2>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
      <category>电磁振荡与电磁波</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理科</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法公开课（二）</title>
    <link href="/2020/05/18/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/05/18/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>突然发现，学习STL之后链表的各种C实现就不用费劲写了，只用好好想重点逻辑就好了</p><a id="more"></a><h2 id="分治求解问题"><a href="#分治求解问题" class="headerlink" title="分治求解问题"></a>分治求解问题</h2><p>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p><h2 id="递归求解"><a href="#递归求解" class="headerlink" title="递归求解"></a>递归求解</h2><p>写递归的时候要注意不能自己一个一个桃，就直接定好之后管tm</p><h3 id="例一汉诺塔"><a href="#例一汉诺塔" class="headerlink" title="例一汉诺塔"></a>例一汉诺塔</h3><ol><li>首先三个柱子进行分析</li><li>前n个从A到C<ol><li>则首先前n-1从A到B</li><li>然后第n个从A到C</li><li>最后前n-1个从B到C<ol><li>则（即进入递归）</li></ol></li></ol></li><li>数学表达式 f(n)=2f(n-1)+1</li></ol><h3 id="给出二叉树求前序中序和后序"><a href="#给出二叉树求前序中序和后序" class="headerlink" title="给出二叉树求前序中序和后序"></a>给出二叉树求前序中序和后序</h3><p>二叉树：每个节点最多有两个子树（节点分左右</p><p>满二叉树：除了最后一层无子节点，其他都满了</p><p>完全二叉树，除了最后一层外，每一层均达到最大值，最后一层值缺少右边的若干个</p><p>性质：左=根*2，右=根*2+1,这样的二叉树用数组就能直接存下来</p><p>先序遍历：首先访问根节点，然后遍历左子树，再遍历右子树</p><p>中序：左   根   右  //排序后就像从左往右写</p><p>后序： 左  右   根 </p><p>//以上三个序是考虑根的位置</p><p>层序：从上到下从左往右。</p><p><strong>题目实质</strong> 根据已知信息画出树的全貌</p><p>中序遍历给出从左往右怎么排序</p><p>前序遍历给出那些是根，从而得到树的全貌</p><p><em>已知前序后序，中序不唯一</em></p><p>具体实现的时候，先写出遍历函数，然后递归遍历左子树右子树，输出时先左后右。</p><p><strong><em>作为人类，只需要想一层</em></strong></p><h3 id="归并排序，快速排序"><a href="#归并排序，快速排序" class="headerlink" title="归并排序，快速排序"></a>归并排序，快速排序</h3><h4 id="再谈基数排序"><a href="#再谈基数排序" class="headerlink" title="再谈基数排序"></a>再谈基数排序</h4><p>当我们把桶竖着放的时候，顺序是显然的</p><p>所谓的增加的基数，可以开99个桶，然后塞进去</p><h4 id="初探计数排序"><a href="#初探计数排序" class="headerlink" title="初探计数排序"></a>初探计数排序</h4><p>对桶求前缀和，</p><p>可以轻松知道某个大小的数在第几位</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>待排子区间一分为二，讲子区间排序，然后讲已经排好序的两个序列合并</p><ul><li>怎么合并呢<ul><li>从首位比较，然后放好小的之后，小的那个指针后移，到所在序列的下一项</li></ul></li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>选择一个基准，小于基准放左边，大于基准放右边，然后对左右继续上述操作</p><p>复杂度均为nlog（n）</p><ul><li>每一次为n，然后有log（n）层。</li></ul><h3 id="求一个序列第k大数"><a href="#求一个序列第k大数" class="headerlink" title="求一个序列第k大数"></a>求一个序列第k大数</h3><p>先选一个基准，假设基准右边&lt;=k，则第k大一定在左边，则右边直接丢掉</p><p>复杂度logn，不断二分序列</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h3><p>_Tp min(_Tp a,_Tp b)</p><p>_Tp为模板类，传进去什么传出来什么</p><p>sort（a,a+10）,传进去的是指针，然后是左闭右开的a和a+10，</p><p>对结构体排序</p><ul><li>自定义比较函数，返回bool值，return a.x&lt;b.x; 无等号，</li><li>重定义&lt;运算符</li><li>写在结构体里面</li><li>bool operator &lt; (ty b)</li><li>{</li><li>return     x&lt;b;</li><li>}</li></ul><p>求下一个排列</p><p>把 123 变成 132 213</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>分治and递归&amp;&amp;STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客算法题解（二）</title>
    <link href="/2020/05/17/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/05/17/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>5月17号，补充了第一题的题解，放在了（一）里</p><a id="more"></a>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>鸽子记录</title>
    <link href="/2020/05/16/%E9%B8%BD%E5%AD%90%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/05/16/%E9%B8%BD%E5%AD%90%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>此处目前单纯记载我的鸽（断）子（更）记录</p><a id="more"></a><p>没有记录的断更记录可能是因为文章被隐藏了哦，找找看吧</p><p>2020年5月16日，周六，被迫断更</p><p>2020年5月20日，周三，再次断更</p><p>2020年5月23日，周六，只要我写了鸽子记录，就不算断更</p><p>2020年5月24日，周日，今天困了，早点睡吧</p><p>2020年6月11日，先停更几天吧</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（七）</title>
    <link href="/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>不能咕咕！树的预备知识</p><a id="more"></a><p>树的大部分操作的运行时间平均为O（logN）</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>树的递归定义：由根节点和多个子树构成，每个子树的根都被来自跟集结点的一条有向线段连接。一棵树实际上是N个结点和N-1条边的集合</p><p>名词定义</p><ul><li>root：根，根节点</li><li>edge：边，有向，为连接点的直线</li><li>child：根r的儿子，每一个子树的根叫做根r的儿子</li><li>parent：父亲，r是每一个子树的根的父亲 </li><li>leaf：树叶，没有儿子的节点</li><li>sibling：兄弟，具有相同父亲节点</li><li>grandparent：同上类似定义</li><li>grandchild：同上类似定义</li><li>path：路径，从节点n<del>1</del>到n<del>k</del>的路径定义为节点n<del>1</del>，n<del>2</del>,  n<del>3</del>   …………n<del>k</del>  的一个序列，使得对于1&lt;=i&lt;k，有节点n<del>i</del> 是n<del>i+1</del> 的父亲<ul><li>length：路径的长，edge的个数且=k-1</li></ul></li><li>depth：深度，从根到n<del>i</del>的唯一路径的长</li><li>height：高，节点n<del>i</del> 到一片树叶的最长路径的长，一颗树的高等于其根的高</li><li>ancestor：祖先，存在n<del>1</del> 到n<del>2</del>的一条路径，则n<del>1</del> 为n<del>2</del>的一位祖先</li><li>descendant：后裔，上文中n<del>2</del>为n<del>1</del>的后裔，n<del>1</del>！=n<del>2</del> 的时候为真祖先真后裔</li></ul><h1 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h1><p>假设用一个数据结构，在结构中有指向所有儿子的指针。这样不可行是因为每个节点的儿子的个数未知</p><p><strong>可行的方法</strong>是</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree</span></span><span class="hljs-class"></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> i;ptrToNode firstChild;ptrToNode nextSibling；&#125;</code></pre><p>并不直接连接各个儿子，而是只连接第一个儿子，然后让第一个儿子去找他的兄弟们</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第四章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客算法题解（一）</title>
    <link href="/2020/05/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/05/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>5.15号，第一题的暴力解法，优化过程，出过的错误，以及对拍随机数代码。</p><a id="more"></a><p>题目内容</p><p>/*</p><p><em>链接：<a href="https://ac.nowcoder.com/acm/problem/14583" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/14583</a></em></p><p><em>来源：牛客网</em></p><p><em>从前，有n只萌萌的糖糖，他们分成了两组一起玩游戏。他们会排成一排，第i只糖糖会随机得到一个能力值bi。从第i秒的时候，第i只糖糖就可以消灭掉所有排在他前面的和他不是同一组的且能力值小于他的糖糖。</em></p><p><em>为了使游戏更加有趣，糖糖的爸爸，娇姐，会发功m次，第i次发功的时间为ci，则在第ci秒结束后，b1,b2,…..,bci都会增加1.</em></p><p><em>现在，娇姐想知道在第n秒后，会有多少只糖糖存活下来。</em></p><p><em>*/</em></p><h1 id="我的暴力模拟法"><a href="#我的暴力模拟法" class="headerlink" title="我的暴力模拟法"></a>我的暴力模拟法</h1><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">int</span> T,n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span> (T&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">int</span> temp=n;        temp++;        <span class="hljs-keyword">int</span> t[n];  <span class="hljs-comment">//那一组</span>        <span class="hljs-keyword">int</span> ts[n]; <span class="hljs-comment">//能力值</span>        <span class="hljs-keyword">int</span> fg[m];        <span class="hljs-built_in">memset</span>(t,<span class="hljs-number">0</span>,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));        <span class="hljs-built_in">memset</span>(ts,<span class="hljs-number">0</span>,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));        <span class="hljs-built_in">memset</span>(fg,<span class="hljs-number">0</span>,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;        n++;        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)        &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;t[i], &amp;ts[i]);            i++;            n--;        &#125;        i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (m&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;fg[i]);            i++;            m--;        &#125;        i=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> fgs=<span class="hljs-number">0</span>;<span class="hljs-comment">//发功次数</span>        n=temp;        <span class="hljs-keyword">while</span> (i&lt;n)        &#123;            <span class="hljs-comment">//i为秒数</span>            <span class="hljs-keyword">int</span> temp1=i<span class="hljs-number">-1</span>;            <span class="hljs-keyword">while</span> (temp1&gt;=<span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span> (t[temp1]!=t[i])                &#123;                    ts[temp1]=ts[temp1]&gt;=ts[i]?ts[temp1]:<span class="hljs-number">0</span>;                &#125;                <span class="hljs-comment">//此处必然可以优化</span>                temp1--;            &#125;            <span class="hljs-comment">//以上在消灭灭糖糖</span>            <span class="hljs-comment">//一下是发功</span>            <span class="hljs-comment">//啊啊啊啊，这些本来都该用for循环来着</span>            temp=<span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (i==fg[fgs])            &#123;                <span class="hljs-keyword">while</span> (temp&lt;=i)                &#123;                    <span class="hljs-keyword">if</span> (ts[temp]!=<span class="hljs-number">0</span>)                    &#123;                        ts[temp]++;                    &#125;                                        temp++;                &#125;                fgs++;            &#125;            i++;                    &#125;        <span class="hljs-keyword">int</span> temp1=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (temp1&lt;n)        &#123;            <span class="hljs-keyword">if</span> (ts[temp1]!=<span class="hljs-number">0</span>)            &#123;                ans++;            &#125;            temp1++;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);        T--;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="在写的时候遇见的问题（按照恶心程度排序"><a href="#在写的时候遇见的问题（按照恶心程度排序" class="headerlink" title="在写的时候遇见的问题（按照恶心程度排序"></a>在写的时候遇见的问题（按照恶心程度排序</h2><ol><li>糖糖从1开始而不是从0开始</li><li>相等的时候不杀</li><li>没了</li></ol><p>但是这个debug用了我快1h，还是在有对拍的情况下。</p><p>说到对拍，结尾会附上这道题的对拍随机数代码</p><h2 id="开始挠头想优化"><a href="#开始挠头想优化" class="headerlink" title="开始挠头想优化"></a>开始挠头想优化</h2><h3 id="分析算法的复杂度"><a href="#分析算法的复杂度" class="headerlink" title="分析算法的复杂度"></a>分析算法的复杂度</h3><p>读入数据为n+m</p><p>消灭糖糖为1^2^+2^2^……=n^3^</p><p>给糖糖升级，为n^2^ </p><p>输出结果为n</p><p>题目的数据范围为1&lt;=n&lt;=50000，(5*10^4^ )^2^ =10^9^ ,明显是不可接受的算法</p><p>然后开始做优化。</p><p>当然是从消灭和升级入手</p><p>消灭的</p><pre><code class="hljs smali">while (temp1&gt;=0)&#123;    <span class="hljs-built_in">if </span>(t[temp1]!=t[i])        &#123;            ts[temp1]=ts[temp1]&gt;=ts[i]?ts[temp1]:0;            &#125;        temp1--;&#125;</code></pre><p>这部分实际上是在通过一个O（n）的遍历来判断<code>ts[temp1]</code>前面的数据的大小如何。</p><h3 id="思想（并没有按照可行性排序"><a href="#思想（并没有按照可行性排序" class="headerlink" title="思想（并没有按照可行性排序"></a>思想（并没有按照可行性排序</h3><p>二维数组or结构体，不同的组放入不同的数组里，但是被放入的数组中仍保留着自己是第几个元素，这样的话平均，可以少遍历一半的内容,之后陷入僵局</p><h3 id="从另一个角度想（从后往前遍历"><a href="#从另一个角度想（从后往前遍历" class="headerlink" title="从另一个角度想（从后往前遍历"></a>从另一个角度想（从后往前遍历</h3><p>增加战力，实际上不改变第i个人与前面每个人的差值，所以我们先不让人死，同时加完战力</p><blockquote><p>举例:50,1,2,3,4,5,6,7,8,9,20,30,53.</p><p>同时50与后面不同组。在第3秒，第4秒，第5秒……都加了战力</p><p>正常而言，前面都杀不死他，到了53，自然杀不死。</p><p>而假如：50，49，48，47，53.</p><p>能通过加战力使得后面杀不死他的本身就确实是杀不死的，所以这种想法有可行性</p></blockquote><h4 id="分析复杂度"><a href="#分析复杂度" class="headerlink" title="分析复杂度"></a>分析复杂度</h4><p>读入为n+m，添加战力是m*n，然后从后往前比较</p><blockquote><p>如果第<em>i</em>个人的战力小于后面另一个队的最大战力值，则一定会死</p></blockquote><p>假如我可以写出O（1）的算法，知道i，立刻知道后面队的最大战力，就能把复杂度降低为n。</p><p>方法，在读入数据的时候用另一个数组直接存就ok了。</p><p>那这么看，添加战力这玩意好烦，</p><p>再优化。</p><p>所谓添加战力，实际上就是数列修改问题。</p><p>所以用一个数组维护差值，再对差分数组求前缀和就ok了。这样O（1）得到修改后的值。</p><h3 id="总结优化思路"><a href="#总结优化思路" class="headerlink" title="总结优化思路"></a>总结优化思路</h3><p>从后往前遍历最大值，一个数组维护最大值，一个数组求差分，一个数组求前缀后</p><h3 id="c的实现"><a href="#c的实现" class="headerlink" title="c的实现"></a>c的实现</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TANGTANG</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> zu;    <span class="hljs-keyword">int</span> power;    <span class="hljs-keyword">int</span> different;    <span class="hljs-keyword">int</span> sum;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>;    <span class="hljs-comment">//struct TANGTANG *nextDifferentPosition;</span>    <span class="hljs-keyword">int</span> nextDifferentPosition;&#125;tt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span> (T&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n为糖糖的个数，m为发功次数</span>        <span class="hljs-keyword">int</span>  temp;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        n=<span class="hljs-number">5</span>;        m=<span class="hljs-number">4</span>;<span class="hljs-comment">//测试用数据</span>        n++;        tt one[<span class="hljs-number">7</span>];        <span class="hljs-keyword">int</span> *next[n];        temp=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (temp&lt;n)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;one[temp].zu,&amp;one[temp].power);            <span class="hljs-keyword">if</span> (temp&gt;<span class="hljs-number">1</span>)            &#123;                one[temp].different=one[temp].power-one[temp<span class="hljs-number">-1</span>].power;                one[temp].sum=one[temp<span class="hljs-number">-1</span>].sum+one[temp].different;                 &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp==<span class="hljs-number">1</span>)            &#123;                one[temp].different=<span class="hljs-number">0</span>;                one[temp].sum=<span class="hljs-number">0</span>;            &#125;            <span class="hljs-comment">//sum,是在对差分数组求前缀和。此处不能求最大值，因为我要的最大值是从后往前</span>                                            temp++;        &#125;        temp=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-comment">//用于next</span>        <span class="hljs-keyword">int</span> changeNumeber[<span class="hljs-number">500</span>]=&#123;<span class="hljs-number">0</span>&#125;;        next[i]=&amp;changeNumeber[i];        i++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++)        &#123;            changeNumeber[i]=i;            next[i]=&amp;changeNumeber[i];        &#125;                <span class="hljs-keyword">while</span> (temp&lt;n<span class="hljs-number">-1</span>)        &#123;                        <span class="hljs-keyword">if</span> (one[temp].zu==one[temp+<span class="hljs-number">1</span>].zu)            &#123;                one[temp].nextDifferentPosition=*next[i];            &#125;<span class="hljs-keyword">else</span>            &#123;                changeNumeber[i]=temp+<span class="hljs-number">1</span>;                next[i]=&amp;changeNumeber[i];                i++;            &#125;            temp++;                    &#125;                temp=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> addpower[m];        <span class="hljs-keyword">while</span> (temp&lt;m)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;addpower[temp]);            temp++;        &#125;        temp=n;        <span class="hljs-keyword">while</span> (temp&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">if</span> (temp==n)            &#123;                one[temp].<span class="hljs-built_in">max</span>=one[temp].power;            &#125;<span class="hljs-keyword">else</span>            &#123;                one[temp].<span class="hljs-built_in">max</span>=one[temp+<span class="hljs-number">1</span>].<span class="hljs-built_in">max</span>&gt;one[temp].power?one[temp+<span class="hljs-number">1</span>].<span class="hljs-built_in">max</span>:one[temp].power;            &#125;            temp--;        &#125;                                T--;    &#125;    &#125;</code></pre><p>问题：爆空间了，没能处理好怎么加能力，没处理好分组的问题</p><h1 id="大佬的解法与学习"><a href="#大佬的解法与学习" class="headerlink" title="大佬的解法与学习"></a>大佬的解法与学习</h1><p>关于添加能力</p><blockquote><p>有影响的一定是1 - ci1，我们可以维护一个前缀和，Csum[i] 表示第i<em>i</em> 项前面有几次操作，这样做的意义是什么呢，对于Csum[j-1]-Csum[i-1]且j&gt;=i表示位置<em>i</em> 的糖糖比位置<em>j</em>多了几次赋值+1的操作。</p></blockquote><p>关于处理最大值</p><blockquote><p>当且仅当i+1&lt;=j&lt;=n位置存在和糖糖i不是一队且B[i]+Csum[j-1]-Csum[i-1]&lt;B[j]的时候，位置i的糖糖才会被击败，将式子移项即可发现，B[i]-Csum[i-1]&lt;B[j]-Csum[j-1]</p></blockquote><p>也就是比较B-Csum的值</p><p>关于分组</p><blockquote><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--)&#123;    <span class="hljs-keyword">int</span> sum = Max[team[i] ^ <span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span> (sum &lt;= B[i] - Csum[i - <span class="hljs-number">1</span>])        cnt++;    Max[team[i]] = <span class="hljs-built_in">max</span>(Max[team[i]], B[i] - Csum[i - <span class="hljs-number">1</span>]);&#125;</code></pre></blockquote><p>不用考虑分组？？用的倒序遍历，因为找到了要比较的东西。实际上我自己写的内容还没到比较的部分，也没想到再开一个单纯的数组存储最大值，异或1为取反，对每一个zu，直接取反就能得到另外组的最大值</p>]]></content>
    
    
    <categories>
      
      <category>算法题目</category>
      
      <category>牛客</category>
      
      <category>第一次</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法公开课（一）</title>
    <link href="/2020/05/14/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/05/14/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>内容包括：尺取法，前缀和，差分，贪心</p><a id="more"></a><ol><li>养成写题解的习惯</li><li>存在每日一题，要做，刷题不能手生。</li><li>至少独立思考半小时，不要对着别人的代码</li></ol><h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><h3 id="怎么评价一个算法"><a href="#怎么评价一个算法" class="headerlink" title="怎么评价一个算法"></a>怎么评价一个算法</h3><ol><li>正确性</li><li>可读性</li><li>容错性（不考虑）</li><li>时间复杂度</li><li>空间复杂度</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(1), 常数算法，与输入数据规模无关</p><p>O（logn）</p><p>O（根号n）</p><p>O（n）线性时间复杂度</p><p>将数据大小代入O中的n，得到的结果若10^8^ 级别的则时可以接受的算法，</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>512M 一个int类型的数组，这个数组最大能开到512×1024×1024×8/32 ==10^8^这么大数组，第一个1024时kb，第二个是字节，第三个8是位数，int为32位。得出结果</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ol><li>定义<ol><li>要点：不重复，不遗漏</li><li>一一列举</li></ol></li><li>优化枚举的思路——减少枚举次数<ol><li>选择合适的枚举对象（找人，先枚举班级，然后枚举）</li><li>选择合适的枚举方向（从前往后or从后往前）</li><li>选择合适的数据维护方法（数据结构）</li></ol></li><li>例题</li></ol><h3 id="例题1：最大正方形"><a href="#例题1：最大正方形" class="headerlink" title="例题1：最大正方形"></a>例题1：最大正方形</h3><p><img src="https://i.loli.net/2020/05/14/adi9EWp74lToxFq.png" srcset="/img/loading.gif" alt="image-20200514202949847"></p><ul><li>思考，几个点确定一个正方形：两个点即可，所以可以枚举两个点，然后计算出另外两个坐标，将另外两个点比较是否为‘#’</li></ul><h3 id="例题2：数列求和（前缀和）"><a href="#例题2：数列求和（前缀和）" class="headerlink" title="例题2：数列求和（前缀和）"></a>例题2：数列求和（前缀和）</h3><p><img src="C:%5CUsers%5C%E7%8E%8B%E5%96%86%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200514203431390.png" srcset="/img/loading.gif" alt="image-20200514203431390"></p><ul><li><p>想法：先考虑暴力怎么做。</p></li><li><p>优化</p><ul><li><p>主要时间复杂度瓶颈在哪里？</p></li><li><blockquote><p>每次求和都要遍历区间</p></blockquote></li><li><p>所以可以用sum[i]存储前n个数的和，sum[i]=sum[i-1]+a[i]</p></li><li><p>sum[i]称为<strong>前缀和</strong>，单次查询的复杂度优化为O（1）</p></li><li><p>能够用前缀xx的都要满足一个类似于“sum[i]=sum[i-1]+a[i]”的条件</p></li></ul></li></ul><h3 id="例题3：数列修改问题（差分法）"><a href="#例题3：数列修改问题（差分法）" class="headerlink" title="例题3：数列修改问题（差分法）"></a>例题3：数列修改问题（差分法）</h3><p><img src="https://i.loli.net/2020/05/14/XzaRwjklZ4W9SEI.png" srcset="/img/loading.gif" alt="image-20200514204033460"></p><ul><li><p>优化：</p><ul><li><p>将对区间的修改变为对区间端点的修改（因为时间复杂度来自对区间的遍历）</p><ul><li><p>具体思考：考虑区间加的过程中什么值是区间段点处发生了变化，而区间内没有变化的</p></li><li><blockquote><p>每个数与前面的差值</p></blockquote></li></ul></li><li><p>具体实现为用一个数组维护第i个数和前一个数的差值</p><ul><li>重点：还要再对delta数组做一个前缀和，才能O（1）后得到修改后的值</li></ul></li><li><p>这种方法叫做<strong>差分</strong></p></li></ul></li></ul><h3 id="例题4：校门外的树（离散化操作）"><a href="#例题4：校门外的树（离散化操作）" class="headerlink" title="例题4：校门外的树（离散化操作）"></a>例题4：校门外的树（离散化操作）</h3><p><img src="https://i.loli.net/2020/05/14/1KTVApWtOlPYqBj.png" srcset="/img/loading.gif" alt="image-20200514204627106"></p><ul><li>暴力算法 easy</li><li>计算每个节点被多少区间覆盖了。然后节点为0的个数</li><li>第三种算法：<ul><li>离散化操作</li><li>区间为[1，100],[1000,2000],[5,110].</li><li>并不用开2000大小的数组，而是将上面的数组重新编号，变成连续的数组</li></ul></li></ul><h3 id="例题5类似于最大子序列和（尺取法）"><a href="#例题5类似于最大子序列和（尺取法）" class="headerlink" title="例题5类似于最大子序列和（尺取法）"></a>例题5类似于最大子序列和（尺取法）</h3><p><img src="https://i.loli.net/2020/05/14/XlwgxE4UKp32DbF.png" srcset="/img/loading.gif" alt="image-20200514205604877"></p><ul><li>暴力的算法是n^3^</li><li>用前缀和可以减去求和，变成n^2^</li><li>用和<strong>最大子序列和的算法四</strong>相同的思想，发现<ul><li>用区间和作为尺子，不断地向后平移。</li><li>首先确定一个L，然后得到一个R，当L向后再平移的时候，R必然不能往前移动，只能往后面移动or原地不动</li><li><strong>Two-pointer/尺取法/追逐法</strong></li></ul></li></ul><h3 id="例题6：按灯泡开关"><a href="#例题6：按灯泡开关" class="headerlink" title="例题6：按灯泡开关"></a>例题6：按灯泡开关</h3><p><img src="https://i.loli.net/2020/05/14/JPTXMYO4sEopRWF.png" srcset="/img/loading.gif" alt="image-20200514210645631"></p><ul><li>每个灯只按一次（因为2次恢复原样，3次同1次）</li><li>仔细分析，发现第一列开关怎么按确定后，后面的所有的灯怎么按动已经确定了。因为第二列的开关可以弥补第一列开关的操作，但是最后一列不行。没有再后面一列弥补了。<ul><li>得到，枚举对象应该为第一列的灯的按动方法</li></ul></li><li>计算时间复杂度</li><li>第一列开关按法为2^n^然后再×N×M，</li><li>具体枚举方法，将亮灭看为2进制字符串，然后转化为十进制整数，然后枚举整数</li><li>名字叫<strong>状态压缩</strong></li></ul><h2 id="位运算介绍"><a href="#位运算介绍" class="headerlink" title="位运算介绍"></a>位运算介绍</h2><p>左移右移等价于*/2 </p><p>| 或</p><p>&amp; 与</p><p>~ 取反</p><p>^ 异或 是不是不一样，相同为0，不同为1，可以视为不带进位的加法。异或0，为本身，异或1，为取反</p><p>应该达到的水平，对int进行位运算的时候，眼中只有01串，看为01串，不用管本身是什么。</p><p>去掉二进制最后一位，右移一位</p><p>最后一位加0，左移一位</p><p>最后加一个1，左移一位+1</p><p>最后一位变成1，或1</p><p>最后一位变成0，先或1，再减掉1</p><p>最后一位取反，异或1</p><p>右数第k位变成1，先把1左移k-1位，然后或1</p><p>右数第k位变成0</p><pre><code class="hljs x&(~(1<<(k-1)))```">右数第k位取反&#96;&#96;&#96;x^(1&lt;&lt;(k-1))</code></pre><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>简而言之，每次都选局部最优解</p><p>能够使用贪心算法的问题都能严格证明局部最优解就是全局最优解</p><h3 id="第一题（没听全，应该很简单）"><a href="#第一题（没听全，应该很简单）" class="headerlink" title="第一题（没听全，应该很简单）"></a>第一题（没听全，应该很简单）</h3><p><img src="https://i.loli.net/2020/05/14/JLrp1k2AvK6zysm.png" srcset="/img/loading.gif" alt="image-20200514213918707"></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><img src="https://i.loli.net/2020/05/14/1emXREjvYl4zDTK.png" srcset="/img/loading.gif" alt="image-20200514214126456"></p><p>按照字典序排序。但这个不是正确的  3 31 39. 最大为 39 33 1.对于这种情况的，先连接起来，再比较大小也就是比较331 313的大小。</p><h3 id="第三题-区间覆盖（工作安排）"><a href="#第三题-区间覆盖（工作安排）" class="headerlink" title="第三题 -区间覆盖（工作安排）"></a>第三题 -区间覆盖（工作安排）</h3><p><img src="https://i.loli.net/2020/05/14/5XGu2vfFcbUYNkE.png" srcset="/img/loading.gif" alt="image-20200514214744728"></p><p>贪心策略：选择结束时间尽量早的。</p><p>证明：离散数学课本</p><h3 id="第四题-活动安排"><a href="#第四题-活动安排" class="headerlink" title="第四题 活动安排"></a>第四题 活动安排</h3><p><img src="https://i.loli.net/2020/05/14/cEevu5jfbVBHiJg.png" srcset="/img/loading.gif" alt="image-20200514215441725"></p><p>先取两件事AB</p><p>当A在B前面，求出A的扣分，B 的扣分</p><p>当B在A前面，求出B的扣分，A的扣分</p><p>假设A在B前是最优解，解出要求</p><h3 id="第五题-国王游戏"><a href="#第五题-国王游戏" class="headerlink" title="第五题 国王游戏"></a>第五题 国王游戏</h3><p><img src="https://i.loli.net/2020/05/14/89Oedhx7ZszHQmk.png" srcset="/img/loading.gif" alt="image-20200514220239896"></p><p><img src="https://i.loli.net/2020/05/14/BSyZX4oYTraGmQ5.png" srcset="/img/loading.gif" alt="image-20200514220312802"></p><p>同理，取AB两个人，交换这两个人的顺序不影响结果</p><p>A在B前面，表示出A获得的奖赏①，B获得的奖赏②</p><p>A在B前面，表示出A获得的奖赏③，B获得的奖赏④</p><p>max(①，②)&lt;=max(③，④)</p><p>则 max(③，④)=③，且③&gt;=max(①，②)</p><p>解方程得到贪心的方法。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>枚举贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（六）</title>
    <link href="/2020/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2020/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>关于栈的其他运用，后缀表达式，函数调用,以及队列ADT</p><a id="more"></a><h1 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h1><h2 id="计算后缀表达式的c实现"><a href="#计算后缀表达式的c实现" class="headerlink" title="计算后缀表达式的c实现"></a>计算后缀表达式的c实现</h2><ul><li><input disabled="" type="checkbox"> 再次待办</li></ul><h2 id="将中缀表达式变为后缀表达式的c实现"><a href="#将中缀表达式变为后缀表达式的c实现" class="headerlink" title="将中缀表达式变为后缀表达式的c实现"></a>将中缀表达式变为后缀表达式的c实现</h2><ul><li><input disabled="" type="checkbox"> 再次待办</li></ul><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>一个奇妙的想法，函数调用类似于平衡符号，因为都是又开放括号（进入函数）封闭括号（return）</p><ul><li>栈溢出为什么会无法调试，程序崩溃。因为栈的信息被冲毁了，返回地址凉凉了，找不到了。</li></ul><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>定义：最后一行的递归调用，可以通过将递归调用变成goto语句并且在其前方加上对函数每个参数的赋值语句而手动消除</p><p class="note note-waring">不要这么做，编译器会帮你这么优化的# 队列ADT<p>没什么好说的</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（五）</title>
    <link href="/2020/05/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2020/05/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天啊，今天是奋力不咕咕的一天,虽然创建文档的时间是晚上十一点，但真正开始动笔已经是第二天0点12分了。今天的内容，关于栈。</p><a id="more"></a><h1 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h1><p>进栈，出栈。是后进先出的ADT</p><ul><li>一个特性：<strong>唯一可见元素是首元素</strong></li></ul><h1 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h1><p>栈这种结构本身是一个表，所以数组，链表（指针），都可以用于实现栈。一个是顺序，一个非顺序</p><p class="note note-warning"> 对于栈来说，顺序or非顺序存储，没有区别，但是数组的栈的总大小是确定的 </p><p>具体的c代码实现……再次列入待办事项中</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>栈的各种操作都是常数时间，但是栈超出界限的时候，就会程序崩溃，所以仔细检查是有必要的。</p><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="符号配对"><a href="#符号配对" class="headerlink" title="符号配对"></a>符号配对</h2><p>检测是否每个 “{” ，都有对应的 “}”，同时我联想到，/* 与 */ 也可这样判定。只用将两个符号组成的结构体压入栈中，并且处理好前进后退</p><h3 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h3><p>自然语言实现</p><p>做一个空栈，读入字符直到文件末尾，读入的过程是这样的，从首字符开始，读入栈中，做判断，判断是保留还是弹出。</p><p>更实际的描述为开放的符号比如  <em>(、{、[、</em> ，push到栈里，如果字符为封闭字符 <em>）、}、]</em> ，且为空栈，则报错。若非空栈，则pop出栈里面的这个开放字符，跟封闭符号进行比较。若不配对，报错。当读到文件尾巴时，若非空栈，仍报错。</p><p class="note note-warning">栈中只有开放符号！<p>c语言实现</p><p class="note note-primary">进入待办事项吃灰吧</p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>待办事项们</title>
    <link href="/2020/05/12/%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%E4%BB%AC/"/>
    <url>/2020/05/12/%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%E4%BB%AC/</url>
    
    <content type="html"><![CDATA[<p>我期待的事情，等待||正在发生</p><a id="more"></a><ul><li><input disabled="" type="checkbox"> 多项式的链表实现</li></ul><ul><li><input disabled="" type="checkbox"> 基数排序的链表实现</li></ul><ul><li><input disabled="" type="checkbox"> 多重表的链表实现</li><li><input disabled="" type="checkbox"> 栈的c语言实现，包括链表和数组</li><li><input disabled="" type="checkbox"> 算法第一题优化后的c实现</li><li><input disabled="" type="checkbox"> 后缀表达式的c实现</li><li><input disabled="" type="checkbox"> 中缀表达式变为后缀表达式</li><li><input checked="" disabled="" type="checkbox"> 牛客题目</li></ul><hr><p>备忘的一些写法</p><pre><code class="hljs markdown">&#123;% cb text, checked?, incline? %&#125;//默认后面就直接换行</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"label label-primary"</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"note note-primary"</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>/*可选的有primarysecondarysuccessdangerwarninginfolight*/</code></pre>]]></content>
    
    
    <categories>
      
      <category>我期待的</category>
      
    </categories>
    
    
    <tags>
      
      <tag>待办事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（四）</title>
    <link href="/2020/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2020/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第四天学习的内容，实现桶排序，看了多重表，跳过游标实现链表</p><a id="more"></a><h1 id="关于桶排序"><a href="#关于桶排序" class="headerlink" title="关于桶排序"></a>关于桶排序</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bucketsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> count)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//桶排序，空间占用极大</span>    <span class="hljs-keyword">int</span> b[count];    <span class="hljs-keyword">int</span> count2;<span class="hljs-comment">//此为整数的个数</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;count2);    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,count*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count2; i++)    &#123;        <span class="hljs-keyword">int</span> temp;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;temp);        b[temp]+=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> t = <span class="hljs-number">0</span>; t &lt; b[i]; t++)        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,i);<span class="hljs-comment">//i就是temp，b[i]的值为有多少个temp</span>        &#125;    &#125;&#125;</code></pre><p>对于桶排序，我认为最好的方式是读入的同时就往桶里塞，这样有两个好处</p><ol><li>减小空间占用</li><li>减少读入数组的时间</li></ol><p>需要注意的是memset函数的最后一项参数，要有sizeof（int），因为memset的原理是把指定的空间变成指定值，这个空间需要我们自己来算。</p><h2 id="桶排序的问题"><a href="#桶排序的问题" class="headerlink" title="桶排序的问题"></a>桶排序的问题</h2><p>占用空间大，桶排序的桶的个数是由待排序数组的最大项决定的，也就是说即便是给0，1，99这样的三个数排序，也需要构建99个桶，这是无法忍受的。</p><blockquote><p>每种算法都有适合自己发光发热的地方，比如稠密的多项式用数组实现就很好，稠密的待排序序列用桶也很好。</p><p>比如对单词进行排序<del>然而我们直接有strcmp</del></p></blockquote><h2 id="桶排序的时间复杂度"><a href="#桶排序的时间复杂度" class="headerlink" title="桶排序的时间复杂度"></a>桶排序的时间复杂度</h2><p>O（M+N），M为整数的范围，N为整数的个数，</p><p>证明：N为填入桶中用的时间，下面的两重循环的值最大超不过M，超不过整数的范围</p><p class="note note-warning">    暂时存疑</p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>目前对于基数排序，我做到是基本理解其过程，但是还没有想到怎么用链表实现。</p><p>基数排序从最低位开始，填入基数个桶中。也就是说我们需要将待排序的数拆分成好几个基构成的。</p><p>比如十进制的数，天然以10为基，所以先按照个位填入桶中，然后，再按照十位填入桶中，填入桶的顺序是刚刚按照个位填入桶的顺序。</p><p><strong>举例子</strong> </p><p>​            512 216 第二次都应该投入1这个桶中，按照什么顺序投入呢，因为2&lt;6 所以先投入512，再投入216</p><p><strong>具体使用</strong></p><p>​            三十二位计算机，2<sup>11</sup> 个桶，给该计算机能表示的所有整数排序，最多三趟就能排完。 先按照前11位，再中间，最后结尾11位</p><div class="note note-success">            <p>暂时存疑too. </p>          </div><p><strong>代码实现</strong> </p><p>​            还存在一丢丢困难</p><p>​            放入代办中吧先。</p><h1 id="多重表"><a href="#多重表" class="headerlink" title="多重表"></a>多重表</h1><p>没什么好说的，非常奇技淫巧，同样期待着我的代码实现</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机械波</title>
    <link href="/2020/05/12/%E6%9C%BA%E6%A2%B0%E6%B3%A2/"/>
    <url>/2020/05/12/%E6%9C%BA%E6%A2%B0%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<p>关于波动的笔记</p><a id="more"></a><h1 id="机械波"><a href="#机械波" class="headerlink" title="机械波"></a>机械波</h1><h2 id="波的分类与描述"><a href="#波的分类与描述" class="headerlink" title="波的分类与描述"></a>波的分类与描述</h2><h3 id="波动现象"><a href="#波动现象" class="headerlink" title="波动现象"></a>波动现象</h3><ul><li>机械波，需介质</li><li>电磁波，真空</li><li>物质波，微观粒子的波粒二象性</li><li>引力波，时空结构的扰动的传播</li></ul><p><strong>另一种分类方法</strong></p><ul><li>横波，振动方向与传播方向垂直，有偏振（不学），波峰波谷，为振动相位为0orΠ</li><li>纵波，振动方向与传播方向平行，疏部，密部，振动相位为 Π/2</li></ul><h3 id="描述波动的物理量"><a href="#描述波动的物理量" class="headerlink" title="描述波动的物理量"></a>描述波动的物理量</h3><ul><li>波速u，取决于媒质性质and波的类型，</li><li>波长λ</li><li>周期T，向前传播一个波长所需时间，等于振动的周期，只与振动源有关</li></ul><h3 id="波的几何描述"><a href="#波的几何描述" class="headerlink" title="波的几何描述"></a>波的几何描述</h3><ul><li>波面： 任一时刻相位相同的点组成的面，又称为<strong>同向面</strong></li><li>波前：某一时刻传到最前面的波面</li><li>波线：指向波传播方向的有向线段，（在各向同性介质中）垂直于波面</li></ul><h3 id="波的分类"><a href="#波的分类" class="headerlink" title="波的分类"></a>波的分类</h3><h4 id="振动方向"><a href="#振动方向" class="headerlink" title="振动方向"></a>振动方向</h4><p>横波纵波</p><h4 id="波面形状"><a href="#波面形状" class="headerlink" title="波面形状"></a>波面形状</h4><p>平面波 面源</p><p>柱面波 线源</p><p>球面波 点源</p><h4 id="持续时间"><a href="#持续时间" class="headerlink" title="持续时间"></a>持续时间</h4><p>脉冲波</p><p>连续波</p><h4 id="是否传播"><a href="#是否传播" class="headerlink" title="是否传播"></a>是否传播</h4><p>行波</p><p>驻波</p><h4 id="复杂程度"><a href="#复杂程度" class="headerlink" title="复杂程度"></a>复杂程度</h4><p>简谐波</p><p>复波</p><h2 id="简谐波的波函数（重点）"><a href="#简谐波的波函数（重点）" class="headerlink" title="简谐波的波函数（重点）"></a>简谐波的波函数（重点）</h2><ul><li>简谐波：简谐振动传播形成的波，只有单一的频率，是单色波</li><li>右行波：往右边跑的波，对t求导后，振动速度，再次求导是加速度</li><li>角波数k=2Π/λ：2Π长度内所含波长个数</li></ul><p><img src="https://i.loli.net/2020/05/12/k9OMhZKS8Ado2av.png" srcset="/img/loading.gif" alt="image-20200512180122861"></p><p>注意u=λ/T  u=w/k</p><blockquote><p>当向右为x正向时，左行为加，右行为减</p></blockquote><p><img src="https://i.loli.net/2020/05/12/oqk9fbT2cmWdXih.png" srcset="/img/loading.gif" alt="image-20200512181229394"></p><p>在t<del>0</del> 时刻，相位差φ<del>1</del> -φ<del>2</del> 体现为路程差就是k（x<del>2</del> -x<del>1</del> ）</p><ul><li>波函数的时间空间双重周期性</li><li>波动微分方程，任何物理量与坐标，时间的关系满足波动方程，就是以波的形式传播 </li></ul><h2 id="波的能量与能流"><a href="#波的能量与能流" class="headerlink" title="波的能量与能流"></a>波的能量与能流</h2><h3 id="波的能量及能量密度"><a href="#波的能量及能量密度" class="headerlink" title="波的能量及能量密度"></a>波的能量及能量密度</h3><p>使用微元法 </p><ul><li>计算一通，得到结论，光强和势能平方正比</li><li><img src="https://i.loli.net/2020/05/15/kSWLsfpT47qgAub.png" srcset="/img/loading.gif" alt="image-20200515133029949"></li><li>首先固定X，考察动能密度，势能密度随时间的变化<ul><li>随时间同相位变化</li><li>同时最大，同时最小，没有转化</li><li>随时间变化，能量不守恒</li></ul></li><li>固定t<ul><li>y=0时，动能密度，势能密度最大</li><li>y最大的时候，都为0 </li></ul></li></ul><blockquote><p>对于振动，振动本身是孤立的振子，而波这里是各个质元相互作用，振动的势能只取决于弹簧形变量，而波这里取决于各个质元之间作用的情况。看作橡皮筋</p></blockquote><p>能量是一包一包的传播</p><h3 id="能流密度，波的强度"><a href="#能流密度，波的强度" class="headerlink" title="能流密度，波的强度"></a>能流密度，波的强度</h3><ul><li><p>能流（能通量）标量</p><ul><li>定义：单位时间内垂直通过S面的能量</li><li>用能量/Δt</li><li>P=wus<ul><li>w是能量密度</li><li>u是波速</li><li>s是横截面积大小</li></ul></li></ul></li><li><p>能流密度，矢量</p><ul><li>定义：单位时间内垂直通过单位面积的能量</li><li>P/s=wu</li></ul></li><li><p>平均能流密度（波的强度）矢量</p><ul><li>能流密度的时间平均值</li><li>对于任意简谐波，波的强度与振幅平方正比</li><li>在同性介质中，方向与波速方向相同</li></ul></li><li><p>介质的特性阻抗</p><ul><li><p>Z=ρu，反映介质的特性</p></li><li><p>两介质比较，Z小叫波疏介质</p></li><li><blockquote><p>对于光波，折射率小叫光疏介质——光速大</p></blockquote></li></ul></li></ul><h3 id="柱面波与球面波的波函数"><a href="#柱面波与球面波的波函数" class="headerlink" title="柱面波与球面波的波函数"></a>柱面波与球面波的波函数</h3><p>振幅会减小，但不是因为能量少了，而是因为能量分布的更散了</p><h2 id="惠更斯原理（了解）"><a href="#惠更斯原理（了解）" class="headerlink" title="惠更斯原理（了解）"></a>惠更斯原理（了解）</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>用惠更斯作图法定性处理波的传播方向</p><p>把波前的每一点看作发射子波的波源</p><ul><li>不足 ，不能说明为什么指向前传播</li><li>不能解释强度问题，不能解释干涉</li></ul><h3 id="用惠更斯作图法导出光的折射定律"><a href="#用惠更斯作图法导出光的折射定律" class="headerlink" title="用惠更斯作图法导出光的折射定律"></a>用惠更斯作图法导出光的折射定律</h3><h2 id="波的叠加与干涉"><a href="#波的叠加与干涉" class="headerlink" title="波的叠加与干涉"></a>波的叠加与干涉</h2><h3 id="波的叠加原理"><a href="#波的叠加原理" class="headerlink" title="波的叠加原理"></a>波的叠加原理</h3><ul><li>几列波可以保持各自的特点，同时通过同一介质并且不改变自身</li></ul><h3 id="波的干涉"><a href="#波的干涉" class="headerlink" title="波的干涉"></a>波的干涉</h3><ul><li>在空间出现稳定的正东加强和减弱的分布</li><li>相干条件<ul><li>频率相同</li><li>振动方向相同（比如都上下振来振去）</li><li>有固定的相位差</li></ul></li><li>相干波：能产生干涉的两列波</li><li>相干波源：相干波的波源</li><li>相长和相消</li></ul><p>相长的条件 相位差2nΠ</p><p>相消 （2n+1）Π</p><p>初相位相同的时Δφ=2Π/λ  × 波程差    即</p><p><img src="https://i.loli.net/2020/05/15/oiBzxV2AglukypO.png" srcset="/img/loading.gif" alt="image-20200515144148146"></p><p> 相长为波程差的整数倍</p><p>相消为半波程差的奇数倍</p><h2 id="驻波（重点）"><a href="#驻波（重点）" class="headerlink" title="驻波（重点）"></a>驻波（重点）</h2><h3 id="驻波的形成及特点"><a href="#驻波的形成及特点" class="headerlink" title="驻波的形成及特点"></a>驻波的形成及特点</h3><p>两列相干，且沿相反方向传播叠加形成的驻波</p><h4 id="驻波的描述"><a href="#驻波的描述" class="headerlink" title="驻波的描述"></a>驻波的描述</h4><p>对于两列振幅相等的行波，分别沿x轴正向反向传播</p><p>则合振动为直接相加然后和差化积y=2Acoskx coswt</p><p>不同相位差不同驻波方程</p><blockquote><p>需要背和差化积</p></blockquote><p>特点</p><ul><li>各地啊均为角频率为w的简谐振动，振幅随位置x而不同</li><li>A<del>合</del> =2Acoskx 的绝对值，</li><li>当kx为与y轴锐角，则y=A<del>合</del> coswt，kx为钝角时y=A<del>合</del> cos（wt+Π）</li></ul><h4 id="驻波的特点"><a href="#驻波的特点" class="headerlink" title="驻波的特点"></a>驻波的特点</h4><ol><li>振幅：A<del>合</del> =2Acoskx 的绝对值==2Acos（2Π/λ）x<ol><li>当x × 2Π/λ == nΠ时，n=0，+-1<ol><li>A<del>合</del> =2A，波腹的位置，此时x=nλ/2</li><li>Δφ=2nΠ，相长</li></ol></li><li>当x × 2Π/λ ==（2n+1）×Π/2 的时候，<ol><li>A<del>合</del> =0，波节，此时x=（2n+1）λ/4</li><li>Δφ=（2n+1）Π，相消</li></ol></li><li>相邻的波节（波腹）的间距是Δx=λ/2，所以测波节间距能得出行波波长</li></ol></li><li>相位<ol><li>以波节为分界点，波节的一侧都是wt，另一侧是wt+Π</li><li>统一段的振动相位相位相同，相邻段振动相位相反</li><li>以两相邻波节为一段，分段震动</li><li><strong><em>驻波没有相位依次传播</em></strong></li></ol></li><li>能量<ol><li>平均来说，驻波中没有能量传播，但是各个质元之间有能量的交换</li><li>初始<ol><li>以势能的形式集中在波节附近</li><li>以动能的形式集中在波腹 且==0</li><li>由两端往中间串</li></ol></li><li>运动到各个质元均处于平衡位置，<ol><li>势能均为0，动能均最大，</li><li>波腹处的动能是最大的最大</li></ol></li><li>又弯曲<ol><li>由中间往两端穿</li></ol></li></ol></li></ol><h4 id="振幅不相等"><a href="#振幅不相等" class="headerlink" title="振幅不相等"></a>振幅不相等</h4><p>成为驻波合行波的叠加</p><h3 id="反射波及半波损失"><a href="#反射波及半波损失" class="headerlink" title="反射波及半波损失"></a>反射波及半波损失</h3><h4 id="从波疏介质到波密介质"><a href="#从波疏介质到波密介质" class="headerlink" title="从波疏介质到波密介质"></a>从波疏介质到波密介质</h4><p>在分界点会有反射波，而反射波和入射波在分界点的相位差是Π，则存在半个波长这样的波程差，故而称之为半波损失</p><blockquote><p>注意：在波疏介质入射到波密介质的时候，所形成的反射波有斑驳损失</p><p>界面上总是波节</p></blockquote><p>对于绳波，中间存在一个固定端点，也会有半波损失</p><h4 id="从波密介质到波疏介质"><a href="#从波密介质到波疏介质" class="headerlink" title="从波密介质到波疏介质"></a>从波密介质到波疏介质</h4><p>相位不变</p><p>界面总是波腹，无半波损失</p><p>绳波在自由端为波腹</p><h4 id="半波损失的解释"><a href="#半波损失的解释" class="headerlink" title="半波损失的解释"></a>半波损失的解释</h4><p> 根据界面关系列方程</p><ol><li>入射波＋反射波的引起的振动==透射波的振动</li><li>两侧的应力相等（进入超纲环节）</li></ol><p>解得</p><p><img src="https://i.loli.net/2020/05/19/MthrV5CFO7odylW.png" srcset="/img/loading.gif" alt="image-20200519165444262"></p><h3 id="简正模式"><a href="#简正模式" class="headerlink" title="简正模式"></a>简正模式</h3><p>波在一定边界内传播时由于边界处的反射会形成驻波</p><ul><li><p>长为L两端固定的弦；两端固定即为波节</p><ul><li>因为相邻波节的间距为λ/2 ，则L= n * λ/2</li><li>计算一下能得到驻波系统的固有频率，</li><li>每一个n有一个固有频率，对应一种稳定的振动方式，称为系统的一个简正模式<ul><li>而固有频率=根号下，弦中的张力/弦的线密度</li></ul></li><li>n=1 基频 二次斜频，三次斜频</li></ul></li><li><p>一端固定，一段开放</p><ul><li><p>因为固定端为波节，开放段为波腹，波节波腹之间间距为λ/4</p><ul><li><p>所以L=n λ<del>n</del>  /4    n取1，3，5</p></li><li><p>n取2则两边均为波节 </p></li><li><blockquote><p>见上文相邻波节间的间距：为λ/2</p></blockquote></li></ul></li></ul></li><li><p>中间固定，两端开放</p><ul><li>L=n*λ/2</li><li>同样n不能取偶数</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
      <category>振动与波动</category>
      
      <category>机械波</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理科</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于项目的思考，包括计算器和雏燕</title>
    <link href="/2020/05/12/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E5%92%8C%E9%9B%8F%E7%87%95/"/>
    <url>/2020/05/12/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E5%92%8C%E9%9B%8F%E7%87%95/</url>
    
    <content type="html"><![CDATA[<p>闲下来的（大学英语课上），早就想写的关于项目的策划</p><a id="more"></a><h1 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h1><h2 id="首先要做的"><a href="#首先要做的" class="headerlink" title="首先要做的"></a>首先要做的</h2><p>手绘出GUI，然后使用tkinter或者其他的python图形化的库，绘制好按钮，安排好按钮的位置，也就是在视觉上实现GUI</p><blockquote><p>这是较为轻松的操作，但是wsl不好操作，还是需要图形化的系统才能简单实现………………比如Windows下………………因为黑框框的wsl跟GUI天然不兼容…………虽然能够通过pip3经过一系列操作安装上tkinter库，但是…………难以调出GUI…………</p></blockquote><h2 id="然后要做的"><a href="#然后要做的" class="headerlink" title="然后要做的"></a>然后要做的</h2><p>给每一个按钮写自己的方法。此处分工完成就好了。<strong><em>感觉应该同时包括把结果输出在屏幕上。</em></strong></p><p>难点：大量数据的计算必然要用的算法，人类直觉想到的算法一般时间复杂度为O（n^3），或者n^2，复杂度极高，<del>甚至满足不了也不是不能用</del>，所以需要善用搜素引擎，寻找诸如求幂，排序等的快速算法，快排啊，快速幂啊什么的。当然，python中也是有已经实现好了的算法库的。可以用pip3 install 库名 来安装</p><h2 id="最后要做的"><a href="#最后要做的" class="headerlink" title="最后要做的"></a>最后要做的</h2><p>封装成一般用户可以使用的样子</p><p>此处内容在书中的第十八章程序打包有相关的描述</p><h1 id="我的雏燕计划"><a href="#我的雏燕计划" class="headerlink" title="我的雏燕计划"></a>我的雏燕计划</h1><p>按照相同的处理思想，模块化的来写。</p><h2 id="先写出底部三个页面的接口，然后写三个页面的内容"><a href="#先写出底部三个页面的接口，然后写三个页面的内容" class="headerlink" title="先写出底部三个页面的接口，然后写三个页面的内容"></a>先写出底部三个页面的接口，然后写三个页面的内容</h2><h3 id="正经的写法"><a href="#正经的写法" class="headerlink" title="正经的写法"></a>正经的写法</h3><p>学习html，css，xml等内容，or 读微信开发者文档，强行上手，</p><p>我们的目标是，只写出按钮，并不实现按下按钮后能够做什么</p><h3 id="不正经的写法"><a href="#不正经的写法" class="headerlink" title="不正经的写法"></a>不正经的写法</h3><p>直接PS绘制出图形然后直接html 用img标签放进去就完事</p><h2 id="结束了……"><a href="#结束了……" class="headerlink" title="结束了……"></a>结束了……</h2><p>反正暂缓结题了，就在学习算法数据结构之余，随便写写得了</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>项目策划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（三）</title>
    <link href="/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第三天学习的内容，链表的复习，多项式ADT</p><a id="more"></a><h1 id="需要注意的内容"><a href="#需要注意的内容" class="headerlink" title="需要注意的内容"></a>需要注意的内容</h1><ol><li>声明指向一个结构体的指针并不能创造该结构体，只是给了足够的空间来容纳该指针。所以必须要malloc</li><li>而对于free而言，free之后，指针指向的地址没变，但是此处的内容已经无意义了，不再受到保护，随时都会发现值被改变</li><li>malloc的sizeof应该是结构体的大小，而不是指针的大小</li><li>对于删除操作，删除前应该先记下下一个节点的位置</li></ol><h1 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h1><h2 id="多项式ADT"><a href="#多项式ADT" class="headerlink" title="多项式ADT"></a>多项式ADT</h2><p><strong><em>多项式可以用于实现大整数的四则运算</em></strong></p><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> coedffArray[maxDegree+<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> highPower;&#125;  * polynomial;</code></pre><p>在数组中存储多项式各项的系数，然后进行加减乘除即可</p><p>其中maxDegree是已知的多项式可能存在的最大的次数，而highPower为目前一个特定多项式的最大项的次数。</p><h4 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h4><p>这样对多项式做加减法之前，先将数组赋值为0之后再给每一个特定的多项式赋值。然后进行加减的途中先比较最大项那个更大一些。然后加减</p><h4 id="乘除"><a href="#乘除" class="headerlink" title="乘除"></a>乘除</h4><p>乘除法需要注意</p><ol><li>是否超过了可能存在的最大次数</li><li>乘除认为做了分配律，第一个多项式的每一项 ÷ || ×  第二个多项式，具体的实现就是两个套着的循环</li></ol><h4 id="数组实现的问题"><a href="#数组实现的问题" class="headerlink" title="数组实现的问题"></a>数组实现的问题</h4><p>对于稠密的多项式，数组非常ok，但是对于不稠密的，大量的时间用在了乘0，效率极低。</p><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><ul><li><input disabled="" type="checkbox"> 等待之后几天做练习题的时候再实现</li></ul><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="前提：桶排序"><a href="#前提：桶排序" class="headerlink" title="前提：桶排序"></a>前提：桶排序</h3><ul><li><input disabled="" type="checkbox"> 等待实现的数组桶排序</li><li><input disabled="" type="checkbox"> 等待实现的基数排序</li></ul><h2 id="多重表"><a href="#多重表" class="headerlink" title="多重表"></a>多重表</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（二）</title>
    <link href="/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第二天学习的内容，关于欧几里得算法求最大公因数，以及快速幂</p><a id="more"></a><h1 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m ,<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> rem;    <span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>)    &#123;        rem=m%n;        m=n;        n=rem;    &#125;    <span class="hljs-keyword">return</span> m;&#125;</code></pre><p>称之为辗转相除法也可。时间复杂度为logn</p><p>通过定理</p><blockquote><p>如果M&gt;N,则M mod N &lt; M/2</p><p>分两种情况证明</p></blockquote><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qiumi</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//复杂度为log（n）</span>    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">if</span> (n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">//偶数</span>    &#123;        <span class="hljs-keyword">return</span> qiumi(x*x,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//求x方的n/2次幂。然后x的四次方的n/4次幂，以此类推，得到x的n次幂。</span>    &#125;<span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> qiumi(x*x,(n)/<span class="hljs-number">2</span>)*x;    &#125;&#125;</code></pre><p>时间复杂度为 logn</p><p>一般的循环做法时间复杂度为n</p><p>求2^10次方，可以变为2^5 *2 ^5 </p><p>然后2^5 可以为2 ^2 *2^2 *2</p><p>也就是先计算2×2，然后 4×4×2，然后32×32，总共四次乘法</p><p>然后写递推的思路，求x^n，若n为偶数，则先求 x^(n/2) ，然后对其 平方。</p><p>然后如果n为奇数，则求x的n-1次方，再乘x</p><p>下面按照此思路再写一遍代码</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kuaisumi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b==<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> kuaisumi(a,n/<span class="hljs-number">2</span>)*kuaisumi(a,n/<span class="hljs-number">2</span>);    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> kuaisumi(a,n<span class="hljs-number">-1</span>)*a;&#125;</code></pre><p>我们发现第六行与正确答案不一样，我们应该用正确答案的写法。</p><p>因为</p><pre><code class="hljs c">kuaisumi(a,n/<span class="hljs-number">2</span>)*kuaisumi(a,n/<span class="hljs-number">2</span>);</code></pre><p>会造成调用两个递归，而不是一个递归。影响效率</p><h1 id="明天的学习目标"><a href="#明天的学习目标" class="headerlink" title="明天的学习目标"></a>明天的学习目标</h1><p>学习完3.1，3.2</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第二章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（一）</title>
    <link href="/2020/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第一天学习的内容，关于最大子序列的和四种算法</p><a id="more"></a><h1 id="一般能想到的算法"><a href="#一般能想到的算法" class="headerlink" title="一般能想到的算法"></a>一般能想到的算法</h1><h2 id="O（n-3）的算法"><a href="#O（n-3）的算法" class="headerlink" title="O（n^3）的算法"></a>O（n^3）的算法</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nOfCubed</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *a*[],<span class="hljs-keyword">int</span> *n*)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  *<span class="hljs-comment">//从第0项开始加，0，01，012，0123，012……n，1，12，123，这样遍历*</span>  <span class="hljs-keyword">int</span> sum,maxsum,j,k;  maxsum=<span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  &#123;​    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> t = i; t &lt; n; t++)​    &#123;​      sum=<span class="hljs-number">0</span>;​      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> k = i; k &lt;=t; k++)​      &#123;​        sum+=a[k];​      &#125;​      <span class="hljs-keyword">if</span> (sum&gt;maxsum)​      &#123;​        maxsum=sum;​      &#125;​      ​      ​    &#125;​      &#125;  <span class="hljs-keyword">return</span> maxsum;  &#125;</code></pre><h2 id="O（n-2）的算法"><a href="#O（n-2）的算法" class="headerlink" title="O（n^2）的算法"></a>O（n^2）的算法</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//0然后比较，01，比较，0123，比较，也就是在一次循环中同时做了加和比较两件事情，使得立方运行时间变成了平方</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  sum,<span class="hljs-built_in">max</span>;    <span class="hljs-built_in">max</span>=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> t = i; t &lt; n; t++)        &#123;            sum+=a[t];            <span class="hljs-keyword">if</span> (sum&gt;<span class="hljs-built_in">max</span>)            &#123;                <span class="hljs-built_in">max</span>=sum;            &#125;                &#125;            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;   &#125;</code></pre><h2 id="n-2与n-3-算法的区别"><a href="#n-2与n-3-算法的区别" class="headerlink" title="n^2与n^3 算法的区别"></a>n^2与n^3 算法的区别</h2><p>对于n^3的算法，每次计算子序列的和需要重新从首项开始加，耗费了大量时间，所以在n^2的算法里，我们在每一次求出和之后立马进行比较，少了一次从首项开始加，从而成功减小时间复杂度。</p><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fenzhi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> maxOfLeft=<span class="hljs-number">0</span>,maxOfRight=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxLeftB=<span class="hljs-number">0</span>,maxRightB=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> leftBSum=<span class="hljs-number">0</span>,rightBSum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> center=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;    <span class="hljs-comment">//下面为基准情形，用于退出递归</span>    <span class="hljs-keyword">if</span> (left==right)    &#123;        <span class="hljs-keyword">if</span> (a[left])        &#123;            <span class="hljs-keyword">return</span> a[left];        &#125;<span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    center=(left+right)/<span class="hljs-number">2</span>;    maxOfLeft=fenzhi(a,left,center);<span class="hljs-comment">//通过递归求出纯左边的最大子序列</span>    maxOfRight=fenzhi(a,center+<span class="hljs-number">1</span>,right);<span class="hljs-comment">//通过递归求出纯右边的最大子序列</span>    maxLeftB=<span class="hljs-number">0</span>;    leftBSum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( i = center; i &gt;= left; i--)    &#123;        leftBSum+=a[i];        <span class="hljs-keyword">if</span> (leftBSum&gt;maxLeftB)        &#123;            maxLeftB=leftBSum;        &#125;    &#125;    maxRightB=<span class="hljs-number">0</span>;    rightBSum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( i = center+<span class="hljs-number">1</span>; i &lt;= right; i++)    &#123;        rightBSum+=a[i];        <span class="hljs-keyword">if</span> (rightBSum&gt;maxRightB)        &#123;            maxRightB=rightBSum;        &#125;    &#125;   <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxOfLeft,maxOfRight,maxRightB+maxLeftB) ;<span class="hljs-comment">//此处需要注意，每次返回的值应该是左边的or右边or中间的最大值，此处的左边右边中间指的是进入此函数的数组a，也是进行二分之后的数组的那部分。</span>&#125;</code></pre><p>分治算法，分而治之。</p><h2 id="分"><a href="#分" class="headerlink" title="分"></a>分</h2><p>将问题分为两个大致相等的子问题</p><h2 id="治"><a href="#治" class="headerlink" title="治"></a>治</h2><p>将两个子问题的解合在一起，附加少量工作，得到答案</p><h2 id="在本问题的表现"><a href="#在本问题的表现" class="headerlink" title="在本问题的表现"></a>在本问题的表现</h2><p>最大子序列只能在输入数据的左边，右边，中间三部分出现。然后左边，右边可以递归求解。中间可以变成特别的左边右边的最大子序列的和。</p><blockquote><p>特别的左边右边子序列指的是，包含左边最后一个元素的子序列，包含右边第一个元素的子序列</p></blockquote><h1 id="线性时间的算法"><a href="#线性时间的算法" class="headerlink" title="线性时间的算法"></a>线性时间的算法</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xianxingjiansuanfa</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,<span class="hljs-built_in">max</span>=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        sum+=a[i];        <span class="hljs-keyword">if</span> (sum&gt;<span class="hljs-built_in">max</span>)        &#123;            <span class="hljs-built_in">max</span>=sum;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&lt;<span class="hljs-number">0</span>)        &#123;            sum=<span class="hljs-number">0</span>;        &#125;                    &#125;    &#125;</code></pre><p>此算法正确性的推导</p><p>一个最大和的子序列，必然不能负数作为开头的，因为负数只会减少和。同时，最大子序列，也不能是由一个负的和的子序列作为开头的。</p><p>假设某个子序列是由负的和的子序列作为开头，则我们删除掉这个开头，得到的是更大的子序列</p><p>通过反证法，得到结果</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第二章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电磁</title>
    <link href="/2020/05/08/%E7%94%B5%E7%A3%81/"/>
    <url>/2020/05/08/%E7%94%B5%E7%A3%81/</url>
    
    <content type="html"><![CDATA[<p>关于电磁学的笔记</p><a id="more"></a><h1 id="圆盘"><a href="#圆盘" class="headerlink" title="圆盘"></a>圆盘</h1><h2 id="半径超大，无限大薄板"><a href="#半径超大，无限大薄板" class="headerlink" title="半径超大，无限大薄板"></a>半径超大，无限大薄板</h2><p>E=σ/2ε0</p><h1 id="平行板电容器"><a href="#平行板电容器" class="headerlink" title="平行板电容器"></a>平行板电容器</h1><p>两板间，E=σ/ε0<br>两版外场强，为0</p><h1 id="带电厚板"><a href="#带电厚板" class="headerlink" title="带电厚板"></a>带电厚板</h1><p>处理方法，切片后积分</p><p>板外  ρe/2ε0<br>板内 不匀强</p><h1 id="补偿法"><a href="#补偿法" class="headerlink" title="补偿法"></a>补偿法</h1><p>具体表述，大减小。</p><h1 id="叠加原理"><a href="#叠加原理" class="headerlink" title="叠加原理"></a>叠加原理</h1><p>点电荷 圆环 圆盘 大平板<br>点电荷 圆环 球面 球体<br>点电荷 直导线 柱面 柱体<br>点电荷 直导线 大平面</p><h1 id="理想模型"><a href="#理想模型" class="headerlink" title="理想模型"></a>理想模型</h1><p>点电荷<br>电偶极子<br>无限长直线<br>无限大平面</p><h1 id="电通量-高斯定理"><a href="#电通量-高斯定理" class="headerlink" title="电通量 高斯定理"></a>电通量 高斯定理</h1><p>有对称性<br>第二种计算场强的办法</p><h2 id="电通量"><a href="#电通量" class="headerlink" title="电通量"></a>电通量</h2><h3 id="电场线"><a href="#电场线" class="headerlink" title="电场线"></a>电场线</h3><p>切线方向是场强方向<br>疏密是大小<br>不能相交<br>不会在没有电荷的地方中断</p><h4 id="电场线密度"><a href="#电场线密度" class="headerlink" title="电场线密度"></a>电场线密度</h4><p>穿过垂直于电场线的面积元的条数/面积，反应电场线疏密程度，反应场强大小。</p><h4 id="静电场电场线"><a href="#静电场电场线" class="headerlink" title="静电场电场线"></a>静电场电场线</h4><p>有头有尾，起始于正，终结于负.</p><h3 id="电场强度通量"><a href="#电场强度通量" class="headerlink" title="电场强度通量"></a>电场强度通量</h3><p>面积矢量，大小是面积，方向是法向<br>Φ=E·S。</p><p>Φ为标量，有正负。</p><h4 id="非均匀电场的电通量"><a href="#非均匀电场的电通量" class="headerlink" title="非均匀电场的电通量"></a>非均匀电场的电通量</h4><p>dΦ=E·dS</p><p>非闭合曲面方向自选<br>闭合曲面方向，外法线方向为正。<br>穿入为负，穿出为正。</p><p>穿过闭合曲面体的电通量为0.</p><blockquote><p><em>穿过闭合曲面的电通量，等于该曲面所包围的电荷代数和除以ε。与曲面外电荷无关，当写成 EdS的时候，E是由所有电荷产生的场强，是面上的场强</em></p></blockquote><p>上为静电场的高斯定理。</p><blockquote><p>Φ为0，但E不一定为0.<br>Φ&gt;0,有净传出，内部有正电荷。<br>Φ&lt;0，有净传入，内部有负电荷。</p></blockquote><h4 id="高斯定理的导出"><a href="#高斯定理的导出" class="headerlink" title="高斯定理的导出"></a>高斯定理的导出</h4><p>库仑定律+场强叠加原理。</p><ul><li>单个点电荷<br>q在球心处。<br>Φ=q/ε</li><li>点电荷系</li><li>连续分布的源电荷</li></ul><h4 id="高斯定理的应用"><a href="#高斯定理的应用" class="headerlink" title="高斯定理的应用"></a>高斯定理的应用</h4><h5 id="计算带电体周围的电场强度"><a href="#计算带电体周围的电场强度" class="headerlink" title="计算带电体周围的电场强度"></a>计算带电体周围的电场强度</h5><p>选取适当高斯面</p><blockquote><p>适当高斯面一号：高斯面上各面元的法线方向与场强方向平行，且E的大小处处相等。</p></blockquote><p>此时Φ=ES</p><blockquote><p>适当高斯面二号：部分垂直，部分平行且大小处处相等。</p></blockquote><p>此时Φ=ES平行</p><p><strong><em>有对称性才能用高斯定理</em></strong></p><ol><li>球对称 均匀带电的球面球体多层同心球壳</li><li>轴对称 无限长均匀带电的直线，圆柱面，圆柱体</li><li>面对称 无限大的均匀带电的平面平板</li></ol><p>3月27日</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>无限大均匀带电平面 σ/2ε0<br>用高斯定理做</p><blockquote><p><em>穿过闭合曲面的电通量，等于该曲面所包围的电荷代数和除以ε。与曲面外电荷无关，当写成 EdS的时候，E是由所有电荷产生的场强，是面上的场强</em></p></blockquote><ol><li>对称性分析，判断出方向垂直平面。</li><li>画适当高斯面，柱形高斯面。（满足高斯面二号</li><li>计算，侧面高斯面垂直，为0，左底面，右底面直接等于ES，和等于2ES。</li><li>φ=2ES，由高斯定理得到2ES=σS/ε0，得出答案。</li><li>平面上，为0</li></ol><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>无限大带电厚板。</p><ol><li>分为板外板内的场强</li><li>板外E=ρd/2ε0</li><li>板内E=ρx/ε0</li></ol><h2 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h2><p>均匀带电球面</p><ol><li>分析场强方向</li><li>画高斯面 同心球面半径r</li><li>E4Πr^2=q总/ε0</li><li>分为球面内，球面外</li><li>球面外，等效为点电荷</li><li>球面内，q=0 E=0</li><li>球面上，同无限大平面</li></ol><h2 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h2><p>均匀带电球体</p><p>同面，但内部由电场 球外E=ρ/3ε0  *R^3/r^2<br>球内E=ρ/3ε0  *r</p><h2 id="例五"><a href="#例五" class="headerlink" title="例五"></a>例五</h2><p>无限长带电直线  E=λ/2Πεr<br>适当高斯面为圆柱面，只用侧面</p><h2 id="例六"><a href="#例六" class="headerlink" title="例六"></a>例六</h2><p>半径为r的无限长均匀带电圆柱体 λ为线密度<br>体内λr/2Πε0R^2<br>体外  λ/2Πε0r</p><h1 id="静电场的环路定理-电势"><a href="#静电场的环路定理-电势" class="headerlink" title="静电场的环路定理 电势"></a>静电场的环路定理 电势</h1><p>静电场力也是保守力<br>所以沿着闭合路径移动，做功为0</p><p>在静电场中，电场强度的环流为0</p><p>高斯定理得到静电场是有源场，环路定理知静电场是无旋场。<br>环路定理可以检验一个电场是不是静电场，做一个环路，求电势是不是0</p><p>电势能，电势</p><p>Wab=Ea-Eb</p><p>求某一点的电势就从该点搬到0点</p><p>零点的选择，</p><ol><li>无穷远处（源电荷有限范围</li><li>无限大，无限长时，零点选在有限远处。</li><li>实际选大地，仪器外壳。</li></ol><p>电势能不能描述电场本身性质<br>电势可以。</p><p>电势为从所求点搬到电势零点，选零点同电势能</p><p>电势差就是电压，v表示电势，u表示电压。谁减谁的差就是从谁搬到谁<br>dv=Edl</p><p>1v=1j/c</p><h2 id="电势的计算"><a href="#电势的计算" class="headerlink" title="电势的计算"></a>电势的计算</h2><h3 id="点电荷-q-4Πε0r-无穷远为0电"><a href="#点电荷-q-4Πε0r-无穷远为0电" class="headerlink" title="点电荷  q/4Πε0r (无穷远为0电)"></a>点电荷  q/4Πε0r (无穷远为0电)</h3><h3 id="点电荷系的电势-总场强矢量叠加后对l积分等同于单独的电势的代数和"><a href="#点电荷系的电势-总场强矢量叠加后对l积分等同于单独的电势的代数和" class="headerlink" title="点电荷系的电势  总场强矢量叠加后对l积分等同于单独的电势的代数和"></a>点电荷系的电势  总场强矢量叠加后对l积分等同于单独的电势的代数和</h3><h3 id="连续分布的电势-对dq积分"><a href="#连续分布的电势-对dq积分" class="headerlink" title="连续分布的电势 对dq积分"></a>连续分布的电势 对dq积分</h3><h3 id="已知场强分布，用定义式，已知电荷分布，用电势叠加原理"><a href="#已知场强分布，用定义式，已知电荷分布，用电势叠加原理" class="headerlink" title="已知场强分布，用定义式，已知电荷分布，用电势叠加原理"></a>已知场强分布，用定义式，已知电荷分布，用电势叠加原理</h3><p>3月31日</p><h1 id="均匀带电圆环在圆心场强为零电势不为零"><a href="#均匀带电圆环在圆心场强为零电势不为零" class="headerlink" title="均匀带电圆环在圆心场强为零电势不为零"></a>均匀带电圆环在圆心场强为零电势不为零</h1><h2 id="非均匀带电圆环环心得电势仍未q-4ΠεR，任取P点也同均匀。"><a href="#非均匀带电圆环环心得电势仍未q-4ΠεR，任取P点也同均匀。" class="headerlink" title="非均匀带电圆环环心得电势仍未q/4ΠεR，任取P点也同均匀。"></a>非均匀带电圆环环心得电势仍未q/4ΠεR，任取P点也同均匀。</h2><h1 id="均匀分布的带电圆盘，将圆环积分从0积分到R，无穷远同圆盘"><a href="#均匀分布的带电圆盘，将圆环积分从0积分到R，无穷远同圆盘" class="headerlink" title="均匀分布的带电圆盘，将圆环积分从0积分到R，无穷远同圆盘"></a>均匀分布的带电圆盘，将圆环积分从0积分到R，无穷远同圆盘</h1><h1 id="均匀带电球面球面内为等势的等于q-4Πεr"><a href="#均匀带电球面球面内为等势的等于q-4Πεr" class="headerlink" title="均匀带电球面球面内为等势的等于q/4Πεr"></a>均匀带电球面球面内为等势的等于q/4Πεr</h1><h1 id="非均匀带电球面的球心处的电势也为q-4Πεr。"><a href="#非均匀带电球面的球心处的电势也为q-4Πεr。" class="headerlink" title="非均匀带电球面的球心处的电势也为q/4Πεr。"></a>非均匀带电球面的球心处的电势也为q/4Πεr。</h1><h1 id="均匀带电球体，非导体，因为导体内部没有电荷。"><a href="#均匀带电球体，非导体，因为导体内部没有电荷。" class="headerlink" title="均匀带电球体，非导体，因为导体内部没有电荷。"></a>均匀带电球体，非导体，因为导体内部没有电荷。</h1><h1 id="无限长均匀带电直线-不能去无穷远作为势能零点"><a href="#无限长均匀带电直线-不能去无穷远作为势能零点" class="headerlink" title="无限长均匀带电直线 不能去无穷远作为势能零点"></a>无限长均匀带电直线 不能去无穷远作为势能零点</h1><h1 id="场强与电势的关系"><a href="#场强与电势的关系" class="headerlink" title="场强与电势的关系"></a>场强与电势的关系</h1><h2 id="等势面与电场线处处正交。电场线方向指向电势降落的方向"><a href="#等势面与电场线处处正交。电场线方向指向电势降落的方向" class="headerlink" title="等势面与电场线处处正交。电场线方向指向电势降落的方向"></a>等势面与电场线处处正交。电场线方向指向电势降落的方向</h2><h2 id="可以用电势求场强分布"><a href="#可以用电势求场强分布" class="headerlink" title="可以用电势求场强分布"></a>可以用电势求场强分布</h2><h1 id="静电场中的电偶极子"><a href="#静电场中的电偶极子" class="headerlink" title="静电场中的电偶极子"></a>静电场中的电偶极子</h1><h2 id="力矩r×f（矢量）"><a href="#力矩r×f（矢量）" class="headerlink" title="力矩r×f（矢量）"></a>力矩r×f（矢量）</h2><p>电偶极子所受力矩M=p×E<br>有稳定平衡与非稳定平衡<br>在非匀强电场中有转动有平动<br>p=ql<br>电势能E=-p点乘E<br>90° 电势能为0  力矩最大<br>0° 电势能最底  力矩为0<br>180° 电势能最高 力矩为0 非稳定平衡</p><h1 id="静电场中的导体"><a href="#静电场中的导体" class="headerlink" title="静电场中的导体"></a>静电场中的导体</h1><h2 id="静电感应-静电平衡"><a href="#静电感应-静电平衡" class="headerlink" title="静电感应 静电平衡"></a>静电感应 静电平衡</h2><h3 id="静电感应，金属中电子自己跑"><a href="#静电感应，金属中电子自己跑" class="headerlink" title="静电感应，金属中电子自己跑"></a>静电感应，金属中电子自己跑</h3><h3 id="静电平衡-内部场强为0，且表面电势为0-表面没有电荷的宏观定向移动。"><a href="#静电平衡-内部场强为0，且表面电势为0-表面没有电荷的宏观定向移动。" class="headerlink" title="静电平衡 内部场强为0，且表面电势为0 表面没有电荷的宏观定向移动。"></a>静电平衡 内部场强为0，且表面电势为0 表面没有电荷的宏观定向移动。</h3><h3 id="静电平衡的时候导体是等势体，表面是等势面"><a href="#静电平衡的时候导体是等势体，表面是等势面" class="headerlink" title="静电平衡的时候导体是等势体，表面是等势面"></a>静电平衡的时候导体是等势体，表面是等势面</h3><h3 id="静电平衡时导体上的电荷分布"><a href="#静电平衡时导体上的电荷分布" class="headerlink" title="静电平衡时导体上的电荷分布"></a>静电平衡时导体上的电荷分布</h3><ol><li>实心导体</li></ol><blockquote><p>内部场强为0，用高斯定理得到，内部电荷的代数和为0所以内部处处没有净电荷。所以电荷只能分布在表面上。所以导体不可能是均匀带电体，只能是带电面</p></blockquote><blockquote><p>形状简单的孤立导体（其他导体或带电体离他足够远，对他没有影响），表面各处电荷面密度与该处表面的曲率有关</p><blockquote><p>凸出 曲率为正 大 面密度大<br>平坦 曲率小 面密度小<br>凹进 曲率为负 面密度更小</p></blockquote></blockquote><h3 id="导体表面外附近的电场"><a href="#导体表面外附近的电场" class="headerlink" title="导体表面外附近的电场"></a>导体表面外附近的电场</h3><p>内部为0 上垂直</p><p>用高斯定理，用柱形高斯面 En=σ/ε0  σ是局域处电荷面密度 虽然σ为局域面密度，但与其他各处电荷分布有关<br>表面上的电场为En的一半</p><p>4月3日</p><h4 id="尖端放电"><a href="#尖端放电" class="headerlink" title="尖端放电"></a>尖端放电</h4><p>场强可以大到使空气电离。金属元件做成球形光滑为了避免尖端放电</p><h3 id="空腔导体与静电屏蔽"><a href="#空腔导体与静电屏蔽" class="headerlink" title="空腔导体与静电屏蔽"></a>空腔导体与静电屏蔽</h3><h4 id="空腔内无电荷"><a href="#空腔内无电荷" class="headerlink" title="空腔内无电荷"></a>空腔内无电荷</h4><p>假设有某处为正，则必然有一处为负。则可以画电场线，则有了电势差，则矛盾，则假设不成立，所以内表面不存在净电荷，且空腔内无电场。</p><h4 id="空腔内有电荷"><a href="#空腔内有电荷" class="headerlink" title="空腔内有电荷"></a>空腔内有电荷</h4><p>则内表面有了等量异号的电荷</p><blockquote><p>总结，内表面的电荷由内部电荷感应出来，外表面电荷由外部电荷感应出来。内外互不影响</p></blockquote><blockquote><p>空腔内表面的电荷与腔内电荷在腔外，导体外产生的电场也相互抵消</p></blockquote><p><strong>若空腔导体接地，则导体与大地接通，外表面的电荷会重新分布</strong></p><p>接地腔内腔外互不影响</p><p>不接地，腔内有电荷，腔内电荷回影响腔外电荷大小  +q</p><h3 id="有导体时静电场的计算"><a href="#有导体时静电场的计算" class="headerlink" title="有导体时静电场的计算"></a>有导体时静电场的计算</h3><blockquote><p>一般用到导体静电平衡的条件，静电场的高斯定理，电荷守恒定律，场强叠加原理。</p></blockquote><ol><li>任取两点，列静电平衡条件</li><li>列经典守恒定律</li><li>根据已知解题</li></ol><p>注！！！！接地只意味着电势为0，不意味着电荷都没了</p><p>4月7号</p><h1 id="静电场的能量"><a href="#静电场的能量" class="headerlink" title="静电场的能量"></a>静电场的能量</h1><h2 id="电容器的电能"><a href="#电容器的电能" class="headerlink" title="电容器的电能"></a>电容器的电能</h2><p>w=Q^2/2C. 为放完电or充完电的情况<br>上式为电容器的储能公式，还有1/2 CU^2，  1/2 QU<br>要看一下哪个物理量的变化，电源连接和电源断开。<br>W=1/2 εE^2V, w与介质，电场强度，体积V有关，能量储存在电场中。<br>能量密度，w=1/2 εE^2,非匀强电场则对体积元积分。积分区域，遍布电场分布的区域。</p><h2 id="带点体系的静电能"><a href="#带点体系的静电能" class="headerlink" title="带点体系的静电能"></a>带点体系的静电能</h2><p>不详细说明</p><h3 id="总静电能-每个带电体单独存在时的自能＋带电体之间的-互作用能"><a href="#总静电能-每个带电体单独存在时的自能＋带电体之间的-互作用能" class="headerlink" title="总静电能=每个带电体单独存在时的自能＋带电体之间的  互作用能"></a>总静电能=每个带电体单独存在时的自能＋带电体之间的  互作用能</h3><h1 id="磁"><a href="#磁" class="headerlink" title="磁"></a>磁</h1><h2 id="磁与电的发现"><a href="#磁与电的发现" class="headerlink" title="磁与电的发现"></a>磁与电的发现</h2><ol><li>分子电流</li><li>电流的磁现象</li></ol><h2 id="磁场-磁感应强度"><a href="#磁场-磁感应强度" class="headerlink" title="磁场 磁感应强度"></a>磁场 磁感应强度</h2><h3 id="磁场"><a href="#磁场" class="headerlink" title="磁场"></a>磁场</h3><p>运动电荷电流磁体周围存在磁场，磁场对磁体运动电荷 电流有磁场力的作用，磁场具有能量。</p><h3 id="磁感应强度"><a href="#磁感应强度" class="headerlink" title="磁感应强度"></a>磁感应强度</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>F=qv×b，B的单位是特斯拉，高斯,1T=10^4G</p><h2 id="毕奥-萨伐尔定律"><a href="#毕奥-萨伐尔定律" class="headerlink" title="毕奥-萨伐尔定律"></a>毕奥-萨伐尔定律</h2><h3 id="毕奥-萨伐尔定律详细内容"><a href="#毕奥-萨伐尔定律详细内容" class="headerlink" title="毕奥-萨伐尔定律详细内容"></a>毕奥-萨伐尔定律详细内容</h3><h4 id="电流元所产生的磁场的公式"><a href="#电流元所产生的磁场的公式" class="headerlink" title="电流元所产生的磁场的公式"></a>电流元所产生的磁场的公式</h4><p>电流元的方向，为电流的方向<br>B=μ/4Π idl × r/r^3<br>右手定则判断方向 l到r，r为电流元处到所求点的直线，×为向内，·为向外，类似射箭</p><blockquote><p>本定律是由实验抽象出来，不能实验直接证明</p></blockquote><h3 id="比萨定律应用举例"><a href="#比萨定律应用举例" class="headerlink" title="比萨定律应用举例"></a>比萨定律应用举例</h3><h4 id="载流长直导线"><a href="#载流长直导线" class="headerlink" title="载流长直导线"></a>载流长直导线</h4><p>方向，右手螺旋，直接握住</p><ol><li>无限长直线电流的磁场<br>B=μi/2Πr<br>E=λ/2Πεr</li><li>半无限长 Π到Π/2 or 0到Π/2<br>B=μi/4Πr</li><li>点再导线延长线上，B=0</li></ol><p>4月10号</p><p>载流圆线圈，其轴上的磁场仅延轴的方向，环心处为B=μI/2R，注意，无Π，<br>x&gt;&gt;R时，B=μIR^2/2x^3<br>磁矩m=is，s面积矢量的方向是右手螺旋的方向<br>B=μ/2Π  m/x^3</p><p><strong>无限长载流螺线管</strong><br>B=μnl，<br>管口处为0.5μnl</p><h3 id="运动电荷的磁场"><a href="#运动电荷的磁场" class="headerlink" title="运动电荷的磁场"></a>运动电荷的磁场</h3><p>B=μ/4Π · q×r/r^3,叉乘时方向用电流方向</p><h2 id="磁通量-磁场高斯定理"><a href="#磁通量-磁场高斯定理" class="headerlink" title="磁通量 磁场高斯定理"></a>磁通量 磁场高斯定理</h2><h3 id="磁感应线"><a href="#磁感应线" class="headerlink" title="磁感应线"></a>磁感应线</h3><ol><li>不相交，</li><li>无头无尾的闭合曲线（无限远到无限远也算）</li><li>与电流仙湖套连，服从右手螺旋。</li><li>曲线切线方向为磁感应强度方向</li><li>磁场强度由磁感应线的疏密来表示</li></ol><h3 id="磁通量"><a href="#磁通量" class="headerlink" title="磁通量"></a>磁通量</h3><p>Φ=B·S。<br>传入为负，传出为正</p><h3 id="磁场高斯定理"><a href="#磁场高斯定理" class="headerlink" title="磁场高斯定理"></a>磁场高斯定理</h3><p>通过任意闭合曲面的磁通量必定为0<br>磁感线为平行直线的空间，磁感应线上的各点磁感强度相等</p><h2 id="安培环路定理"><a href="#安培环路定理" class="headerlink" title="安培环路定理"></a>安培环路定理</h2><h3 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h3><p>稳恒电流产生的磁感应强度沿任意闭合环路L的线积分，等于穿过该环路的电流强度的<strong>代数和</strong>的μ倍。</p><ol><li>B的环流只有穿过环路的电流有关</li><li>环路上个点的磁场为所有电流的贡献</li><li>磁场有旋场，电流为磁场涡旋的中心。</li><li>与积分环路方向成右手螺旋的电流为正，反之为负</li><li>穿过积分的环电流必须和环路铰链（必须要套在一起）</li><li>稳恒电流必须是闭合的，安培环路定理只适用于闭合电路（无限长的直电流为闭合）</li><li>无电流空间区域内，磁感应线平行直线，那么磁场一定是匀强磁场</li></ol><p>4月14号</p><h2 id="安培环路定理的应用"><a href="#安培环路定理的应用" class="headerlink" title="安培环路定理的应用"></a>安培环路定理的应用</h2><p>条件：稳恒电流对称分布</p><h3 id="例一，无限长均匀载流圆柱面半径为R"><a href="#例一，无限长均匀载流圆柱面半径为R" class="headerlink" title="例一，无限长均匀载流圆柱面半径为R"></a>例一，无限长均匀载流圆柱面半径为R</h3><p>第一步，判断磁场方向，圆柱面同心圆的切线方向。<br>第二步，选取逆时针为环流方向。<br>第三步，求环路定理左边，磁感应强度沿闭合环路的线积分<br>第四步，分条件求右边。<br>圆柱面外，则电流为I，则为μI。<br>圆柱面内，则小同心圆里无电流，则B=0，无限长均匀载流圆柱面内磁场处处为0</p><h3 id="例二，同轴电缆（圆柱体）"><a href="#例二，同轴电缆（圆柱体）" class="headerlink" title="例二，同轴电缆（圆柱体）"></a>例二，同轴电缆（圆柱体）</h3><h3 id="例三，无限大均匀载流平面，周围磁场"><a href="#例三，无限大均匀载流平面，周围磁场" class="headerlink" title="例三，无限大均匀载流平面，周围磁场"></a>例三，无限大均匀载流平面，周围磁场</h3><blockquote><p>电流密度，I/截面面积，为体密度<br>I/l,为面密度，单位长度上。<br>将载流直线看成无限直线，<br>用矩形环路</p></blockquote><h3 id="例四，载流无限长直螺线管内任一点的磁场"><a href="#例四，载流无限长直螺线管内任一点的磁场" class="headerlink" title="例四，载流无限长直螺线管内任一点的磁场"></a>例四，载流无限长直螺线管内任一点的磁场</h3><p>右手定则判断方向 l到r，r为电流元处到所求点的直线，×为向内，·为向外，类似射箭</p><h4 id="例五，载流螺旋管（环形螺线管内的磁场）"><a href="#例五，载流螺旋管（环形螺线管内的磁场）" class="headerlink" title="例五，载流螺旋管（环形螺线管内的磁场）"></a>例五，载流螺旋管（环形螺线管内的磁场）</h4><h2 id="磁场对运动电荷的作用"><a href="#磁场对运动电荷的作用" class="headerlink" title="磁场对运动电荷的作用"></a>磁场对运动电荷的作用</h2><h3 id="洛伦兹力"><a href="#洛伦兹力" class="headerlink" title="洛伦兹力"></a>洛伦兹力</h3><p>F=qv×B</p><blockquote><p>记得负电荷</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>只对运动电荷有作用力</li><li>始终不做功</li></ol><h3 id="带电粒子在磁场中的运动"><a href="#带电粒子在磁场中的运动" class="headerlink" title="带电粒子在磁场中的运动"></a>带电粒子在磁场中的运动</h3><h4 id="速度方向鱼磁场方向平行"><a href="#速度方向鱼磁场方向平行" class="headerlink" title="速度方向鱼磁场方向平行"></a>速度方向鱼磁场方向平行</h4><p>粒子做匀速直线运动</p><h4 id="速度方向与磁场方向垂直"><a href="#速度方向与磁场方向垂直" class="headerlink" title="速度方向与磁场方向垂直"></a>速度方向与磁场方向垂直</h4><p>粒子做匀速圆周运动</p><h4 id="速度方向与磁场方向有夹角"><a href="#速度方向与磁场方向有夹角" class="headerlink" title="速度方向与磁场方向有夹角"></a>速度方向与磁场方向有夹角</h4><p>螺旋线向前运动，将速度适量分解。</p><blockquote><p>磁约束效应，强磁场可把带电粒子约束<br>螺距-粒子回转一周所前进的距离：与vy无关  </p></blockquote><h3 id="霍尔效应"><a href="#霍尔效应" class="headerlink" title="霍尔效应"></a>霍尔效应</h3><p>载流导体版，垂直于版面施加磁场，则版面两侧微弱电势差<br>霍尔系数Rh=1/nq<br>量子霍尔效应，低温，强磁<br>分数霍尔效应</p><ol><li>霍尔效应的应用。<br>Uab=1/nq   *IB/d</li></ol><blockquote><p>n为载流子浓度<br>通过测量电压判断载流子类型，求B I n  </p></blockquote><p>磁流体发电</p><h2 id="磁场对电流的作用"><a href="#磁场对电流的作用" class="headerlink" title="磁场对电流的作用"></a>磁场对电流的作用</h2><h3 id="磁场对载流导线的作用"><a href="#磁场对载流导线的作用" class="headerlink" title="磁场对载流导线的作用"></a>磁场对载流导线的作用</h3><p>电流元在磁场中收到的力等于体积内所有载流子受到的力，由此可以推出安培力公式<br>dF=Idl×B</p><blockquote><p>I=nqvs<br>对于一段载流导线，为积分<br>若磁场为匀强磁场，则B可以提出来<br>匀强磁场，闭合电流，则为F=0（匀强磁场中的线圈）</p></blockquote><blockquote><p>弯弯曲曲的一条先矢量积分就是a指向b的直线<br>电流同向相吸。</p></blockquote><p>4月17日</p><h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><p>通有电流的矩形线框 旁边是载流直线，求受力</p><blockquote><p>方法一：分别求左右两条对称边，上下两条对称边，得到结果<br>方法二：定性分析。</p></blockquote><h3 id="均匀磁场对平面载流线圈的作用"><a href="#均匀磁场对平面载流线圈的作用" class="headerlink" title="均匀磁场对平面载流线圈的作用"></a>均匀磁场对平面载流线圈的作用</h3><p>合力为0，无平动<br>力矩和不为0，有转动，力矩=F×r矢量叉乘</p><blockquote><p>M=m×B。磁力矩 等于磁偶极矩×磁通量<br>M=p×M</p></blockquote><h3 id="磁场力的功"><a href="#磁场力的功" class="headerlink" title="磁场力的功"></a>磁场力的功</h3><ol><li>磁场对载流导线的功，easy。<br>磁场力的功等于电流强度乘穿过回路的磁通量的增量or电流强度×导线切割磁力线的条数。</li><li>磁场对对载流线圈。同上</li><li>磁偶极子的势能，设磁矩与磁感应强度B相互垂直时为势能零点。 </li></ol><h1 id="变化电磁场"><a href="#变化电磁场" class="headerlink" title="变化电磁场"></a>变化电磁场</h1><h2 id="法拉第电磁感应定律"><a href="#法拉第电磁感应定律" class="headerlink" title="法拉第电磁感应定律"></a>法拉第电磁感应定律</h2><h3 id="总结实验现象得到，磁通量变化，会产生电动势"><a href="#总结实验现象得到，磁通量变化，会产生电动势" class="headerlink" title="总结实验现象得到，磁通量变化，会产生电动势"></a>总结实验现象得到，磁通量变化，会产生电动势</h3><p>电动势可以从非闭合，介质中产生。<br>感应电动势的大小来自磁通量变化率，方向要考虑磁通量时要增加还是减少。</p><h3 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h3><p>E=-dΦ/dt</p><blockquote><p>规定电动势方向与回路绕行方向一致时为正<br>S,与回路绕行方向成右手螺旋。即通过对回路绕行方向右手螺旋得到S的正方向</p></blockquote><h3 id="回路与环路的区别"><a href="#回路与环路的区别" class="headerlink" title="回路与环路的区别"></a>回路与环路的区别</h3><p>环路是人为画的，回路是确实存在的</p><h3 id="楞次定律"><a href="#楞次定律" class="headerlink" title="楞次定律"></a>楞次定律</h3><p>电磁学中的惯性定理，电磁学中的能量守恒定律</p><h3 id="全磁通"><a href="#全磁通" class="headerlink" title="全磁通"></a>全磁通</h3><p>总电动势等于各匝线圈磁通量的综合。<br>E=-dφ/dt<br> =-NdΦ/dt</p><h3 id="交流电"><a href="#交流电" class="headerlink" title="交流电"></a>交流电</h3><p>E=NBSwsinwt</p><h2 id="动生电动势"><a href="#动生电动势" class="headerlink" title="动生电动势"></a>动生电动势</h2><ol><li>导线运动引起的交动生电动势</li><li>切割磁感线才产生电动势</li><li>V×B,方向为搬用正电荷的方向</li></ol><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><ol><li>补全法（形状特殊的，补全成一个回路，则回路电动势为0</li><li>法拉第电机，圆盘切割磁感线等价于一个半径切磁感线</li></ol><h3 id="功能关系"><a href="#功能关系" class="headerlink" title="功能关系"></a>功能关系</h3><blockquote><p>实际洛伦兹力只传递能量。</p></blockquote><h2 id="感生电动势"><a href="#感生电动势" class="headerlink" title="感生电动势"></a>感生电动势</h2><h3 id="感生电场"><a href="#感生电场" class="headerlink" title="感生电场"></a>感生电场</h3><ol><li>变化的磁场激发感生电场，电场作用于电荷，引起感生电动势</li><li>磁棒插入非金属环，也能产生 电动势，但无电流.</li></ol><h3 id="感生电场及感生电动势的计算"><a href="#感生电场及感生电动势的计算" class="headerlink" title="感生电场及感生电动势的计算"></a>感生电场及感生电动势的计算</h3><ol><li>长直螺线管，管内和管外的感生电场</li></ol><blockquote><p>管内 E=r/2  dB/dt</p></blockquote><blockquote><p>管外 E=R^2/2r  dB/dt</p></blockquote><ol start="2"><li>无限长圆柱内有一根导体棒，求导体棒的感生电动势</li></ol><p>感生电动势=感生电场×dl（线元）<br>因而可得在圆柱的半径方向的感生电动势=0<br>不在半径方向的导体棒，连接成一个回路，则回路电动势=棒的电动势<br>螺线管外则变成扇形区域的面积。</p><h3 id="涡电流"><a href="#涡电流" class="headerlink" title="涡电流"></a>涡电流</h3><ol><li>热效应,电磁炉</li><li>机械效应 电磁阻尼</li><li>防止涡流的方法减小电流截面，增大电阻，插入绝缘薄片</li></ol><h3 id="电子感应加速器"><a href="#电子感应加速器" class="headerlink" title="电子感应加速器"></a>电子感应加速器</h3><h2 id="自感、互感"><a href="#自感、互感" class="headerlink" title="自感、互感"></a>自感、互感</h2><h3 id="自感"><a href="#自感" class="headerlink" title="自感"></a>自感</h3><h4 id="自感定义"><a href="#自感定义" class="headerlink" title="自感定义"></a>自感定义</h4><p>当线圈中的自身电流发生变化时产生感应电动势<br>单位为H 亨利</p><p>B=μnI，无限长螺线管，没有铁磁质<br>B正比于I，φ也正比于B（=bs），所以φ正比于I<br>则φ=LI，L为线圈回路的自感系数</p><h4 id="自感电动势计算"><a href="#自感电动势计算" class="headerlink" title="自感电动势计算"></a>自感电动势计算</h4><p>自感电动势E=-dφ/dt=-LdI/dt，此时自感系数为常熟，若自感系数也为变量，则需对两边同时求导</p><h4 id="电磁惯性"><a href="#电磁惯性" class="headerlink" title="电磁惯性"></a>电磁惯性</h4><p>自感具有保持原电流状态的能力，叫做电磁惯性</p><p>L是这种能力大小的量度</p><h4 id="自感系数的计算"><a href="#自感系数的计算" class="headerlink" title="自感系数的计算"></a>自感系数的计算</h4><p>L与回路的大小形状匝数磁介质有关<br>L=φ/I<br>L=dφ/dI=-E/（dI/dt）（实质为前面那个式子上下对t求导）</p><h4 id="自感例题"><a href="#自感例题" class="headerlink" title="自感例题"></a>自感例题</h4><ol><li>螺线管L=μn^2Sl<br>插入铁芯可以增大μ</li><li>圆柱面<br>单位长度的自感L=μ0μr/2Π  lnR2/R1</li></ol><h3 id="互感"><a href="#互感" class="headerlink" title="互感"></a>互感</h3><p>基本与自感一致</p><p>方便计算可用下式<br>M=根号下L1L2 （彼此磁场完全穿过）</p><p>M=k根号L1L2<br>k为耦合系数<br>k与线圈的相对位置有关<br>    无限远or垂直时，k=0，M=0</p><h2 id="磁场的能量"><a href="#磁场的能量" class="headerlink" title="磁场的能量"></a>磁场的能量</h2><p>电源转换为线圈中的储能</p><p>线圈 1/2 L I^2<br>电容 1/2 C U^2<br>Wm(单位体积内的磁场能量)= 1/2 BH<br>所以可以对体积元积分<br>和电场完全对称<br>W总=0.5DE +0.5BH</p><h2 id="位移电流"><a href="#位移电流" class="headerlink" title="位移电流"></a>位移电流</h2><p>原因：安培环路不成立</p><p>使用电流连续方程（电荷守恒定律）</p><p>全电流=传导电流＋位移电流<br>位移电流=电位移通量的导数<br>I=dφD/dt=S* dD/dt<br>I=ΠR^2 ε0 dE/dt<br>因为D=εE<br>B=μH<br>感应电动势=磁通量的导数</p><p>位移电流的本质是变化的电场</p><p>推广得到全电流环路定理</p><h2 id="麦克斯韦方程组"><a href="#麦克斯韦方程组" class="headerlink" title="麦克斯韦方程组"></a>麦克斯韦方程组</h2><p>静电场</p><p>静电场的高斯定理 DS=q<br>静电场的环路定理 El=0</p><p>稳恒磁场<br>磁场的高斯定理 BS=0<br>安培环路定理 Hl =Ic（传导电流）</p><p>对一切而言</p><p>环路定理 El=dB/dt  *S<br>H</p>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
      <category>电磁</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理科</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>振动</title>
    <link href="/2020/05/08/%E6%8C%AF%E5%8A%A8/"/>
    <url>/2020/05/08/%E6%8C%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>关于振动的笔记</p><a id="more"></a><h1 id="机械振动"><a href="#机械振动" class="headerlink" title="机械振动"></a>机械振动</h1><h2 id="什么是简谐振动"><a href="#什么是简谐振动" class="headerlink" title="什么是简谐振动"></a>什么是简谐振动</h2><h3 id="任何一个物理量在某一数值附近反复变化叫振动"><a href="#任何一个物理量在某一数值附近反复变化叫振动" class="headerlink" title="任何一个物理量在某一数值附近反复变化叫振动"></a>任何一个物理量在某一数值附近反复变化叫振动</h3><ol><li>受迫振动：受外力驱动产生的振动，带来共振</li><li>自由振动</li><li>1 阻尼振动 收到阻力</li><li>2 无阻尼自由振动</li><li>2.1 无阻尼自由非谐振动</li><li>2.2 无阻尼自由谐振动（简谐振动）</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol><li>弹簧振子</li></ol><p><em>注意，以平衡位置作为坐标原点</em><br>2. 单摆<br><em>默认逆时针为在</em></p><h3 id="简谐振动的特点"><a href="#简谐振动的特点" class="headerlink" title="简谐振动的特点"></a>简谐振动的特点</h3><p>运动方程由谐函数描述</p><ol><li>运动学：Q（t）=Qcos（）……Q为任何物理量</li><li>动力学：Q对t二阶导+w^2Q=0</li><li>线性恢复力：弹簧振子，单摆</li><li>振动能量 Ep+Ek时，总能量不变<br>满足上述四条之一就是简谐振动</li></ol><h3 id="振动例题"><a href="#振动例题" class="headerlink" title="振动例题"></a>振动例题</h3><p>以平衡位置坐标原点</p><h3 id="简谐运动的描述解析以及真的去"><a href="#简谐运动的描述解析以及真的去" class="headerlink" title="简谐运动的描述解析以及真的去"></a>简谐运动的描述解析以及真的去</h3><h2 id="简谐振动的特征量"><a href="#简谐振动的特征量" class="headerlink" title="简谐振动的特征量"></a>简谐振动的特征量</h2><p>振幅A，由初始条件确定<br>角频率， 系统固有的性质<br>相位、初相位 相位描写t时刻的振动状态。<br>初相位，为开始计时时刻的振动状态</p><p>初相位不等同于摆角。<br>相位对时间的导数为角频率，不为角速度<br>摆角对时间的导数为角速度</p><p>第一象限 x&gt;0,v&lt;0 0到90<br>第二象限 x,v 均小于0 90到180<br>第三象限 x&lt;0 v&gt;0 180到270<br>第四象限 x,v 均大于0 270到360</p><h2 id="旋转矢量法"><a href="#旋转矢量法" class="headerlink" title="旋转矢量法"></a>旋转矢量法</h2><p>将振幅看作矢量，以角速度w绕0逆时针旋转，则在x轴的投影p即代表简谐振动<br>相位差，对相位相减。（同频率<br>取小于Π的夹角<br>Δφ&gt;0 则x2比x1领先<br>Δφ&lt;0 则x2比x1落后<br>==2kΠ，同相<br>==(2k-1)Π，反相</p><h2 id="简谐振动的能量"><a href="#简谐振动的能量" class="headerlink" title="简谐振动的能量"></a>简谐振动的能量</h2><p>动能和弹性势能<br>公式易知<br>且k=mΩ^2<br>E总=1/2 k A^2<br>能量与振幅的平方成正比<br>平均动能，平均势能为最大值的一半<br>平衡位置动能max，势能min<br>最大位移，相反<br><strong>势能最低点附近的微小振动为简谐振动</strong></p><h2 id="简谐振动的合成"><a href="#简谐振动的合成" class="headerlink" title="简谐振动的合成"></a>简谐振动的合成</h2><h3 id="分震动在一条直线上"><a href="#分震动在一条直线上" class="headerlink" title="分震动在一条直线上"></a>分震动在一条直线上</h3><h4 id="同频率"><a href="#同频率" class="headerlink" title="同频率"></a>同频率</h4><h5 id="两个-干涉-双缝"><a href="#两个-干涉-双缝" class="headerlink" title="两个 干涉 双缝"></a>两个 干涉 双缝</h5><ol><li>解析法<br>x=x1+x2</li><li>旋转矢量法<br>合成了一个不变形的平行四边形</li><li>讨论干涉</li><li>1 振动同相时<br>此时合振幅最大，光学中为亮条纹中心，干涉相长</li><li>2 振动反相时<br>此时合振幅最小，暗条纹，干涉相消</li><li>3 非整数倍时<br>亮纹中心和暗纹之间</li></ol><h5 id="多个-衍射-单缝-光栅"><a href="#多个-衍射-单缝-光栅" class="headerlink" title="多个 衍射 单缝 光栅"></a>多个 衍射 单缝 光栅</h5><ol><li>仍然是简谐振动</li><li>同振幅，初相位等差数列时</li><li>1 此时构成正多边形的一部分,连接外接圆圆心，则顶角为公差的值</li><li>讨论 多光束干涉</li><li>1 各个分振动同向，主极大<br>δ=2kΠ</li><li>2 各个分振动闭合，极小值<br>Nδ=2kΠ k!=0 k!=mN（k不是n的整数倍）</li><li>3 合矢量为外接圆直径，次级大<br>Nδ=Π的奇数倍</li></ol><h4 id="不同频率-拍频"><a href="#不同频率-拍频" class="headerlink" title="不同频率 拍频"></a>不同频率 拍频</h4><p>矢量合成为变化的平行四边形，则振幅有变化，则非平行四边形<br>合振动的周期性的强弱变化称为拍<br>拍频：单位时间内振动强弱变化的次数<br>应用： 音叉校准乐器 ，测量超声波频率，测量无线电电波</p><h3 id="分震动在垂直方向上"><a href="#分震动在垂直方向上" class="headerlink" title="分震动在垂直方向上"></a>分震动在垂直方向上</h3><h4 id="同频率-偏振-线偏振-圆偏振-椭圆偏振"><a href="#同频率-偏振-线偏振-圆偏振-椭圆偏振" class="headerlink" title="同频率 偏振 线偏振 圆偏振 椭圆偏振"></a>同频率 偏振 线偏振 圆偏振 椭圆偏振</h4><p>呈现出椭圆形状<br>相位差为y-x<br>右旋（顺时针）<br>左旋（逆时针）<br>椭圆会被卡在矩形区域内<br>在正负A1，正负A2内</p><p>在正负A1，正负A2内，A1，A2分别为两个分运动的振幅</p><p><img src="https://i.loli.net/2020/05/12/BSGmKCtx8Tf2MuW.png" srcset="/img/loading.gif" alt="image-20200512165642623"></p><p>下面基于不同相位差来讨论，该讨论为偏振光的基础，但是我们不学偏振光</p><ol><li><p>同向的时候，（相位差为0时）</p><ol><li><p>轨迹为过原点斜率为正的的直线</p></li><li><p>运动为简谐振动，振幅为矢量和，初相位不变，角频率不变</p></li></ol></li><li><p>反相的时候</p><ol><li>轨迹为过原点，斜率为负的直线</li><li>运动为简谐振动，振幅为A<del>1</del> -A<del>2</del>矢量差，初相位为Φ<del>1</del>，角频率不变</li></ol></li><li><p>y比x领先Π/2 </p><ol><li><p>正椭圆方程，焦点再y轴上</p></li><li><p>右旋（顺时针），转一圈的周期等于分振动的周期</p></li></ol></li><li><p>y比x落后Π/2</p><ol><li>正椭圆，焦点仍在y轴上</li><li>左旋</li></ol></li></ol><blockquote><p>总结，y比x领先0，Π，右旋</p><p>反之，左旋</p></blockquote><h5 id="两个"><a href="#两个" class="headerlink" title="两个"></a>两个</h5><ol><li>两个频率相差很小时，近似为同频率，逐渐从直线变为椭圆再变成直线</li><li>相差大，但是有<strong>简单</strong>整数比的关系，闭合曲线   李萨如图</li></ol>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
      <category>振动与波动</category>
      
      <category>机械振动</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理科</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给小小白的python3安装说明</title>
    <link href="/2020/04/27/%E7%BB%99%E5%B0%8F%E5%B0%8F%E7%99%BD%E7%9A%84python3%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/"/>
    <url>/2020/04/27/%E7%BB%99%E5%B0%8F%E5%B0%8F%E7%99%BD%E7%9A%84python3%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>给小小的，白白的，python3包教包会指南。</p><a id="more"></a><h2 id="第一步，开启并且配置wsl"><a href="#第一步，开启并且配置wsl" class="headerlink" title="第一步，开启并且配置wsl"></a>第一步，开启并且配置wsl</h2><h3 id="为什么使用wsl"><a href="#为什么使用wsl" class="headerlink" title="为什么使用wsl"></a>为什么使用wsl</h3><ol><li>自带python3，和git。</li><li>易于解决因为GFW，导致下载速度过慢的bug</li></ol><h3 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h3><ol><li><p>win+q，输入控制面板，</p></li><li><p>打开控制面板，点击程序</p></li><li><p>在程序和功能一栏，可以看见启用或关闭Windows功能，点击它</p></li><li><p>选择适用于Linux的Windows子系统</p></li><li><p>重启电脑</p></li><li><p>win+q，输入应用商店，回车</p></li><li><p>选择Ubuntu，安装</p></li><li><p>win+q，输入wsl，回车。设置基本信息<strong>注意，输入密码是看不见东西是Linux系统的正常现象</strong></p></li></ol><h3 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a>注意！！</h3><p>此时你已经可以使用命令 </p><pre><code class="hljs bash">python3</code></pre><p>来进行python3的学习了，</p><p>若想要退出输入exit(),即可<br>下面的内容是后期调包，安装vscode等操作要用到的</p><h3 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h3><p><em>目的是避免GFW</em></p><p>输入命令</p><pre><code class="hljs bash">sudo vim /etc/apt/sources.list</code></pre><p>然后输入刚刚的密码<br>进入文件后，莫慌。<br>注意自己的输入法是不是在英文模式。<br>不是，就先调成是<br>先观察文件里有没有aliyun的字样<strong>也可以输入gg/aliyun 回车。看有没有选中文字</strong><br>如果有，请跳到下一部分。<br>如果没有，请看下文<br>输入ggdG<strong>注意大小写，用于清空文件</strong><br>之后按esc</p><p>之后复制下面这段文字</p><pre><code class="hljs bash">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>然后在wsl里按‘i’，接着右键，之后 输入<br>之后按esc</p><pre><code class="hljs bash">:wq</code></pre><p>接着输入命令</p><pre><code class="hljs bash">sudo apt-get update</code></pre><h3 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h3><pre><code class="hljs bash">sudo apt-get install code <span class="hljs-comment">#安装VScode</span></code></pre><pre><code class="hljs bash">sudo apt-get install python3-pip <span class="hljs-comment">#安装包管理器</span></code></pre><pre><code class="hljs bash">sudo mkdir ~/.pip<span class="hljs-built_in">cd</span> ~/.pipvim pip.conf</code></pre><p>复制下面内容</p><pre><code class="hljs bsah">[global]index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple[install]trusted-host&#x3D;mirrors.aliyun.com</code></pre><p>在wsl里右键</p><p>然后esc，之后输入</p><pre><code class="hljs bash">:wq</code></pre><p>之后//此步大该可以跳过吧……</p><pre><code class="hljs bash">pip3 install flake8pip3 install yapf</code></pre><p>安装两个插件</p><p>下一步为</p><pre><code class="hljs bash">code</code></pre><p>进入vscode界面后<br>Ctrl+Shift+X</p><p>若界面为汉语，则在搜索栏输入python<br>若为英语，则先zh-CN，安装，再搜索python<br>安装python。</p><p>Ctrl+Shift+E</p><p>新建一个文件夹。<br>然后应该能看到settings.json这个文件，</p><p>输入以下内容</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"python.linting.flake8Enabled"</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">"python.formatting.provider"</span>: <span class="hljs-string">"yapf"</span>,    <span class="hljs-attr">"python.linting.flake8Args"</span>: [<span class="hljs-string">"--max-line-length=248"</span>],    <span class="hljs-attr">"python.linting.pylintEnabled"</span>: <span class="hljs-literal">false</span>&#125;</code></pre><p>然后在 .vscode 文件夹外 <em>也就是你新建的这个文件夹</em>新建一个 .py文件<br>此时python插件会提醒你少几项配置，你选择分别yapf和flake8即可。若跳过了前面的那步，也是选择yapf和flake8，它会自动通过pip下载。如果下载失败……你可以考虑复制他的命令然后改成pip3试试……。</p><p>之后就可以开心写py文件了，代码补全啊，实时纠错也都有了，报错不知道怎么改把鼠标移动上去有错误代码，然后浏览器搜索一下就可以了。<br>Alt+Shift+F是自动格式化代码。</p><p>(ง •_•)ง</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>python3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>疫情期间的重逢</title>
    <link href="/2020/04/27/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4%E7%9A%84%E9%87%8D%E9%80%A2/"/>
    <url>/2020/04/27/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4%E7%9A%84%E9%87%8D%E9%80%A2/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="1ac612067a2a47091f18745e0304572dbb5696689602e3879ebc99d6c06eeda7">ab087b4ce5e3982bd203b2cd00c758f7bffbc32a68756b105623fdafdb026cb73af8dccdc720136945d7bf33491f2531cd8161e5781aa489af46b975b65667e0972c2e40e4e7bf1e8c5d25a54ac20ec3a0eb72812f155d185dec67bc02cc0bc3adf35b1e946c4a88383155bead55544ccee997d15d8a091884b34a4fd84da785834750ba974f5038f65375f9da94daeb781f93126ef2d4e15eceb5afdfea167f9602190eb2ba3ebfac18badfbde52d3e3fa97129f31696187d01032e720def6490d5df9e5a48da40ae32ce10e7416f647bb4c4023e2cf8136ce8df1370e4ebec09c2fdc52a221f7b677a681d0a6ba07dbd220223b26dd464c0b55bff3d505eaa83b1a2cebbbd1d0bd68dae150848075a1c04ff616d04fa45d2dd381a5aeadb7b34191b0a19252c66a754491b13dfc8321c39960c7ad4d1b11ae890f25d27e27bd29c622cbed96b3a26691dbccfe17207a90f0e36f484c5756c07c0b839efefa00fa7fb2228d4c3e2d23ddb95eafd46a741e5f7bb436c0d26174fea004f3c75a58b49f475c64efd4dbacc8d074fb744e27b3f6e0947f4167410210c608a728ef94ff11a2108cec8c902784cd17dcb673a6209ea601df65a3a36de57176c855255832a7946b6447e39801685dff66227a05afb1e624170327c39de54dfaaaa797bec0aef3b4251c5d9eec3f700b5eaeea0b66a2e8b1041ff759d36e1bc92903dca2801a4e6bbb67e5d47593e777cc7247b93e510c064ed7874e46299a0e36af54d4d4741aeb1f069f989353544d8f0f3b56aea87a1613c0638948c3dc5ee6ac85e024b650f8654f4205f29f96f4655ddc075c1cfb3faf22ec07a4f967ff0d7e246061ed2430b28ebd1594acca209761b54a7047f008e251643b9c642f28946213eeba93abbf2019ad2d1d8c1ca3dc9e7e10c403430c3ae65790247ecc7023b51547486d86a0b1ff36fc2f6243d47036c07928269dbc03cf0d2df2fbd9e96f6466f17b14b49bf93a76e5ee133b2445de2ee8c25f8ff8c8331861dce45e324d756db84eddb464922d98df0fe90a55627a716413f5968810acaff44064d90d66466499669e85e21275e637621cdf00f6ca5b1d62fc80cfa660cc5e44d1ef80ee2a29379b522b5b44326b7c3d641b6d6e0908906959cda027e4f8d67104bfc04e0f26b793f0740abe2e6d8948b6efd383c418240da916f90b06fe1b010311b5e6219050fee7ffdc7ff5ac812c0fc75420325825fe9e1d5682a07005d5f186868572569588104db291a8fb6d72131bb4d5925c81538f86a948044f0f752738e61067eea516b27e720d4ae493184297db5691941e951f7a780c1d1d93c9fdf03be12bd7e277f88516b4b3a79207c9293e22c114a1ded293cb38282db5c0e03c4628d82e85e05a94184829393d9f7281b2b8e0f996882645298bbf372d6f9bef70d473ebca22cffbbcaa3cad08851ad606920c7b65e6635dab4b67cd74b631d82e07cde38be3447cf0af51a80348fad971f1881afda20e433e62051e56ad7526d6990a8b59d895b9cebf7081bcd24d527c1b1b540925dba7dab7ad1407021923073ef70de037f5df1f06918e7d4f330c96749b81bdeabbe7f345142deeb3e63e8b72a9c40b6ff8a8f3a65ca4cbb97dd2b986e73ecf0d23b0e0931a5908fbdca5fa0eddf69c51784e9f1af701f03b775cad0760a45385d25838d7acc67fdc2d1b659d5be7cacdf54988c0bd2ffafc3f982cacdca4a5e7f81dd647570ddc21620aba1e0e00aa23f53d4e4409e5858bfef8434e73cdaa3b20a9f419d3148eca0f72465e73af344c74634740beca13ce686123fc4da85a2591baa83a7c23585ce42d740f6f0b22aa902aa8706a1bd971aeb04fa359a94d1d504887bf0a2933cfd3160d5a5536ab9d11bcad43f05ece7dca11842bcecb2a6b6eb8a1e9c3ae5eb414ed1b007424f10feef6ce5fb977f361274410d692cdcedbc733d52645fc4ed5553983cf1ecfeba58c62cecef50141c5786f0b6d62d3d233955bd58b5ba3cd1e757410e2b14fb10160c902692b0ba79f4f65dd97593f9b3519b725dd82c1a98b364eab1b4d386d3481ac6fb4472a162be8302c87f17a5d92cf04f72008a6da4544b878ab8e67c74d6b02114e36c378ee60df546bfca306e11ef2c6e700738eb6c990cb8326aa9c6bc197d06db330c3fc8d94d317e75ccf16bd08d81261ab445eaa4dbe716e7339024b4eed03ffb03d614642cc400eeab3e2a47ec3799ef41919477d1f9d190f5023c87b1cc22967a034b542a43d44f77bc093e73b1fe57e20280bd12a52aec9fcb58fa235d57524c2da97e693f176700ce5c7704adb65db08f5e40a5066788b0c0f3fe31345c3d92aa4ca5911b911a8f7dd6a493b6478dd80200e8bca33eb26fde20eafcc5bf1576a38e6e9d37e268af3830f7fced4446ffc052bc3f58778a2d8d7584aa818b1935524cf6fd311b79facf177441e775399a9276cb2d9f437a0c35cbb04938ae226e8094df6d4c7ecd967fc482f39494d471689cfa3d0f288eb2f6254dcbeed925d910aea82b5ddb0aed162ed98916fc293cab4f9446613110203d0ddef48c3d8f17a281e950e46ab89cdffe0658485079db7bd1bcb156360084dfb6a56c4c6843f77640d983ea3c6ffb399219269ac930b36e5e04fa4d01600be03874723afea72bdf0330a3fe07778e9700f2cb6ace700e44cfe72c64be9ee07d0ff1dc1b6c3f26a730b363c78562f5fb31cfec16ae97e67fd68afbf28af1253f5f0ebab4ac794d2c2b60425009d5e1a8e09b0e7891d53cab60f3288a47bacce91a02b32f1b093719233d82e3af08e376b02eb0debc01e391c5eb24290e2a5ead635021112220a5c022f23343b4abea63ab07e6732bd55d18f786bef3f2c4cfc4814f8089109bd3f6d6a9c6984067a4e8985635f0f2b0af7f3c0a8d14d657cdbcd40b399790de000f946b7efb74712b1be7eb5eca15a998ab495e4da4868e738ead0788fb094fa166c29b36c8c7613ed8cfcea38c16089be75eb3dc2a977b490dd9bbd1b7237c90d7264aa4ca4c960625e0a1bb52efb26c4792808d238e132b595fea3bddd5d0e545a6247dfd16cd35848d11c9f201afe093db7254653e1cc8ccdb4b750b5a2fecaf5ad4613459bf92fbc02a74202b7b8fb28b94b8e719724d591acd2b00541400df8e55d1af2bc9c21e8652699d117108fe00088439a04c0654cbee67b41d1f882651aadef6f6dffbd25b39d809362763fb24309d38956638e24d79fb711552a6a68ac4dc822902e89619be6c01924dfddf5ebd08151a0fb6b5facd11c88234dd45716c1070ef540f2f6d7af8ef82ec6b2574bec8278567916b5a5db3b56bfcf1f303ab956cde0d4c5e40c3c794acfc812e0f090c3d0315c68d3e351138cb7d5957e4852b772472ccf7466ede954f53e9b212683e356e4031c9ff930d252027e845ef9982f4d25128c17dfdf4e3b293c5da8c3f5d4e30c11d5bd94deaba298c8f966b39fcb01e60595d897c458338fb13de65fd2c5aaf8ea0fa9754f491db7b30bd4e7dfdbb3c5b458ff188f72355b11e87e3e82e5ca03ed06db53b684c408b41f6f938b9f2264f440db436efb2ac7b0fe3f869c63352136f15186c31a0fe0f877b58299ebaf93a566885e93171eb8341747c792c64cc198b5dbdd78cc4c4b8b3eb6adc6228c7348785c7aafe37e39875ba31c7c36d45579c606d3231687c8545d8d847f7435e70877d34602d1f2262d174db030c1f10d04a649e2dcf4bec466d2ae3094f21568394c42901d1c0080c6a102dfd8c717bbac9c45219159038f9428733ead8019bb670da5ea65530b1e23321749bb9d4977672416fc3e46b2200fc49f940bf957d02d89d8ae148c44648dc330d4da48e9896872da88725fb370ead3c8dc6a72d1c562113f150535c10e1e98413c05a943c6ee1c48f44242292b5bf5e9bf59b5105649c5cc13e0a022edd11925db351b8b0054b10a865a2ddaf98197e1cebfab773e0eb853a1dc60feffe8c2ad7a718eb82a25c52bd5d2033af941c59a1857c99cc8dad5bdfb971a1ad2b4107c1cf6c6754c34ffc9f257af9b0d6eb31e025bfa14ac3def13cc007dd63effd4e7b295b19a885b8bae267c954e0d012619d5212e7c11a282c7ab42ae81c6fd2894681c360a0721d4682ebe6923e46b83c757befe91dd756f99e734e4e9b98028dceeaf4661ce3069d75fdbc131db5111eea31d31e271f82e42290353b3a5953deef97b218a57a6099b352f3a4de01a43f9b1e85a6cd31480f6658d308cfa17be439cd76145a6c74aeab8fca2ce5e7776572805c376276be3e13f07adf023aa989d362cfb5aad62f823ffa8cf149cf7fd563cfce7733ded5c5ecace1d489463d27fd3eb6a0e0b0d4b8a06776bad2b2ea143e78ec8405e1cf</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
