<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>期末考试</title>
    <link href="/2020/05/30/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"/>
    <url>/2020/05/30/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>复习安排</p><a id="more"></a><table><thead><tr><th>科目</th><th>复习途径</th><th>复习重点</th><th>考试时间</th></tr></thead><tbody><tr><td>中国近代史</td><td>大作业，紧急DDL，课本</td><td>整理课本</td><td></td></tr><tr><td>高等数学</td><td>往年的期末题，今年的作业题</td><td>公式，不同的题型</td><td></td></tr><tr><td>电子电路</td><td>往年的期末题，今年的作业题</td><td>公式，e的指数幂，电路分析</td><td></td></tr><tr><td>大学物理</td><td>往年的期末题，今年的作业题</td><td>公式，适用范围。</td><td></td></tr><tr><td>大学英语（听说</td><td>课本的题目</td><td>单词且单词</td><td></td></tr><tr><td>大学英语（读写</td><td>课本单词</td><td>单词，且单词</td><td></td></tr><tr><td>离散数学</td><td>往年的期末题，今年的作业题</td><td>看书，纯英文的的课本必须多看，然后作业题也是重点</td><td></td></tr><tr><td>西方音乐史</td><td>大作业</td><td></td><td></td></tr></tbody></table><p>复习日程表</p><table><thead><tr><th>科目</th><th>复习时间</th><th align="left">做的事情</th></tr></thead><tbody><tr><td>离散数学</td><td>5月30日 —— 6月1日</td><td align="left">看完课本</td></tr><tr><td>高等数学</td><td>5月31日 —— 结束</td><td align="left">往年的期末考试题</td></tr><tr><td>大学物理</td><td>5月31日开始</td><td align="left">重看PPT，整理笔记，写之前的作业</td></tr><tr><td>大学英语（听说，读写</td><td>5月31日 —— 6月4日</td><td align="left">背单词，每个模块的 Topic 复习</td></tr><tr><td>中国近代史</td><td>6月1日 ——6月3日</td><td align="left">大作业写完</td></tr><tr><td>计算导论——第一阶段</td><td>5月31日</td><td align="left">学习多线程</td></tr><tr><td>计算导论——第二阶段</td><td>6月1日</td><td align="left">看录课，做设计</td></tr><tr><td>计算导论——第三阶段</td><td>6月3日</td><td align="left">写完</td></tr><tr><td>电子电路</td><td>先走走上面的的内容吧</td><td align="left"></td></tr><tr><td></td><td></td><td align="left"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（十）</title>
    <link href="/2020/05/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <url>/2020/05/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>AVL树的详细内容，单旋转 和 双旋转 作为 一眼看不懂的东西，明天再填</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>左子树和右子树的高度最多差1的二叉查找树</p><p>每一个节点中都保留着自身的高度信息</p><p>由这个特点可以直到，除了插入以外，所有操作的时间复杂度为logN（即本身的深度），而插入操作因为可能破坏树的平衡，而很麻烦。</p><h1 id="所以，我们怎么对待插入"><a href="#所以，我们怎么对待插入" class="headerlink" title="所以，我们怎么对待插入"></a>所以，我们怎么对待插入</h1><p>对树做旋转操作。</p><p>在插入之后，只有从插入点到根节点的路径上的节点的平衡可能被改变。找到第一个新平衡破坏了AVL的节点，对它旋转，然后就完成了。</p><h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><p>任意节点最多两个儿子，所以高度不平衡时，两棵子树的高度差能且只能为2</p><ol><li>在左儿子的左子树上插入</li><li>在左儿子的右子树上插入</li><li>在右儿子的左子树上插入</li><li>在右儿子的右子树上插入</li></ol><p>对于1，4，对树进行单旋转，</p><p>对于2，3，对树进行双旋转</p><h3 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第四章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（九）</title>
    <link href="/2020/05/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <url>/2020/05/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>二叉查找树的平均情形分析，以及AVL树的初步</p><a id="more"></a><h1 id="平均情形分析"><a href="#平均情形分析" class="headerlink" title="平均情形分析"></a>平均情形分析</h1><p>对二叉查找树，初始化耗时为N，其余所有操作耗时均为logN（<em>实际上是树的深度</em>），所以下证明树的平均深度为logN</p><p>证毕（假装自己看懂了）</p><h1 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h1><h2 id="为什么要AVL树"><a href="#为什么要AVL树" class="headerlink" title="为什么要AVL树"></a>为什么要AVL树</h2><p>一棵树，当向其输入预先排好序的数据后，这个树会变成一条直线而非树，<strong><em>参考插入算法</em></strong></p><p>这时候时间开销就很大了，所以为了防止这种情况，需要增加一个称为平衡的附加结构条件：任何节点的深度均不得过深。这样可以防止刚刚那种情况的的发生。</p><p>AVL树，就是最老的一种平衡查找树</p><h2 id="AVL树的详细定义"><a href="#AVL树的详细定义" class="headerlink" title="AVL树的详细定义"></a>AVL树的详细定义</h2><p>带有平衡条件的二叉查找树</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第四章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的Habitica中的冒险</title>
    <link href="/2020/05/26/%E6%88%91%E7%9A%84Habitica%E4%B8%AD%E7%9A%84%E5%86%92%E9%99%A9/"/>
    <url>/2020/05/26/%E6%88%91%E7%9A%84Habitica%E4%B8%AD%E7%9A%84%E5%86%92%E9%99%A9/</url>
    
    <content type="html"><![CDATA[<p>此处是我的Habitica的人设等等，车一张卡</p><a id="more"></a><blockquote><p>网站：<a href="https://habitica.com/" target="_blank" rel="noopener">https://habitica.com/</a></p></blockquote><p>人设背景：上古卷轴5</p><p>人物名称：王富贵</p><p>人物种族：诺德人</p><p>人物表面形象：在雪漫城卖菜的小贩</p><p>人物隐藏背景：天际省的最后一位龙裔</p><p>目前人物状态：被逮捕，正在运往海加尔</p><p>人物小传：王富贵出生的时候，整个泰姆瑞尔都在回荡着吼声，是年，从出生起就居住于白银塔中的天选史官第一次违心的记载，迈德历18年，天下丰收，神喜，故吼而歌。</p><p>富贵的前15年的人生平平无奇的过去。直到软弱无耻的迈德二世面对高精灵的步步紧逼，皇帝步步后退，甚至在打赢了战争之后仍签署了丧权辱国的《白金协定》。王富贵的塔洛斯信仰被裁定为非法，诺德族的英雄泰伯被视为不可说的人。悲愤至极的王富贵揭竿而起，加入了风暴斗篷的反抗大军。随着乌弗瑞克的四处征战，</p><p>四年后，也就是今年，乌弗瑞克在穿过天际边界去落锤省寻找援军时，不幸被帝国俘虏，王富贵作为同行人员，也被俘虏。</p><p>现在，在王富贵走上了断头台，天空中突然出现了吼声，是龙！千百年的传说再次出现在人们眼前，龙，是真实存在的。跪在断头台前的王富贵挣扎着逃出了枷锁。</p><p>末代龙裔的故事，从此开始。</p><p><img src="http://img1.gamersky.com/image2011/12/20111219m_1/01.jpg" srcset="/img/loading.gif" alt="img"></p><p>第一章：</p><p>逃离海加尔</p>]]></content>
    
    
    <categories>
      
      <category>Habitica</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（八）</title>
    <link href="/2020/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <url>/2020/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>上次还是10天前……</p><p>包括树的遍历，二叉树，查找树</p><a id="more"></a><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="遍历的类型"><a href="#遍历的类型" class="headerlink" title="遍历的类型"></a>遍历的类型</h2><p>时间复杂度为O（n）；</p><p>在处理儿子节点前先处理本身。</p><p>先序遍历：首先访问根节点，然后遍历左子树，再遍历右子树</p><p>中序：左   根   右  //排序后就像从左往右写</p><p>后序： 左  右   根 </p><p>//以上三个序是考虑根的位置</p><p>层序：从上到下从左往右。</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul><li>二叉树的每个节点的儿子都不多于两个</li><li>平均深度为根号N</li><li>最坏为N-1</li></ul><h2 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><p>一个结构体有三个元素，本身的值，指向左儿子的指针，指向右儿子的指针。</p><h2 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h2><ul><li>之所以存在表达式树是因为一个表达式可以把树叶用操作数表示，用其他节点表示操作符。</li><li>通过递归计算左右子树，即可得到结果</li><li>将中序遍历用于表达式树，可以得到中缀表达式（正常的表达式）</li><li>后序遍历用于表达式树，可以得到逆波兰表达式（后缀表达式，用栈计算的那个）</li></ul><h3 id="构造一棵表达式树"><a href="#构造一棵表达式树" class="headerlink" title="构造一棵表达式树"></a>构造一棵表达式树</h3><p>一个字符一个字符的读入表达式，若字符是操作数，则压入栈（指向这个单节点树的指针）中，若字符是操作符，则弹出（指向前两个树节点的指针）两棵树，同时注意，先弹出的是右儿子。</p><h1 id="查找树ADT"><a href="#查找树ADT" class="headerlink" title="查找树ADT"></a>查找树ADT</h1><ul><li>特点，对于树中的每个节点X，其中有自身的关键字（比如，int a=100），左子树中的所有关键字均小于X的关键字的值（即，小于100），右子树则大于X的关键字的值（即，大于100）.</li><li>对于上面的特点，重要补充：是节点的所有的左右子树，而非自己的两个子树，包括子树的子树。</li></ul><h2 id="包括的操作"><a href="#包括的操作" class="headerlink" title="包括的操作"></a>包括的操作</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>递归的写，初始化当前树则需要先初始化他的左右子树</p><p>结束条件是树为空指针</p><p>构建树的时候，必须要把树叶的左右都赋值为NULL</p><h3 id="寻找特定值"><a href="#寻找特定值" class="headerlink" title="寻找特定值"></a>寻找特定值</h3><p>天然的二分查找</p><ul><li>注意，先判断当前的树是否为空树</li><li>然后所查找的值大于当前的树则从右边找，否则左边</li><li>结束条件是当前的值</li></ul><h3 id="寻找最小，最大的"><a href="#寻找最小，最大的" class="headerlink" title="寻找最小，最大的"></a>寻找最小，最大的</h3><p>同寻找特定值，不过是一直往左or一直往右</p><p>递归不递归都行</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>可以像寻找特定值一样，做同样的操作。</p><p>找啊找，找了好久，找到一个空节点（NULL）</p><p>则在当前这个空节点，开辟一个空间（指针指向NULL，不等于指针的地址是NULL）</p><p>然后赋值，同时把这个空间的左右儿子都变成NULL</p><p>递归的实现。</p><p>返回值是指向新树根的指针</p><blockquote><p>对于重复元</p><p>可以在结构体里保留附加域，表示重复了几次，也可以其他的数据结构</p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="如果节点有零个儿子（一片树叶）"><a href="#如果节点有零个儿子（一片树叶）" class="headerlink" title="如果节点有零个儿子（一片树叶）"></a>如果节点有零个儿子（一片树叶）</h4><p>立即删除</p><h4 id="如果节点有一个儿子"><a href="#如果节点有一个儿子" class="headerlink" title="如果节点有一个儿子"></a>如果节点有一个儿子</h4><p>把父亲指向该节点的儿子（指向孙子），然后free该节点</p><h4 id="如果节点有两个儿子"><a href="#如果节点有两个儿子" class="headerlink" title="如果节点有两个儿子"></a>如果节点有两个儿子</h4><ul><li>第一步：用其右子树的最小数据代替被删节点的数据，、</li><li>第二步：删除右子树的最小数据节点（将右子树的最小数据节点的父亲，指向最小节点数据的左子树。或者右子树本身就是树叶）</li><li><strong>通过上面的第二步可以看出，实际上是在递归的删除右子树，整个过程可以写成递归</strong></li><li>但是效率不高，所以可以考虑单独写一个删除右子树最小值的函数</li></ul><h3 id="懒惰删除"><a href="#懒惰删除" class="headerlink" title="懒惰删除"></a>懒惰删除</h3><p>做一个删除记号即可</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第四章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法公开课（三）</title>
    <link href="/2020/05/21/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/05/21/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天凑活听一听吧</p><a id="more"></a><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>STL中的函数</p><p>lower_bound ,返回第一个符合条件的元素的位置，第一个大于等于这个数的位置</p><p>upper_bound 返回最后一个符合条件的元素的位置，第一个大于这个数的位置</p><p>（返回的是指针</p><ul><li>取区间中点为了不爆int，应该l+（r-l）</li><li>为了不死循环，看【1，2】，【2，3】</li><li>关于浮点数误差，循环除二然后比较</li><li>当有些问题进行验证更简单的时候，就用二分来验证</li></ul><p><img src="https://i.loli.net/2020/05/21/bX34mARTNrykWKE.png" srcset="/img/loading.gif" alt="image-20200521201922883"></p><p>假设有一个ans的，小于ans的直接晾干，大于ans时列式子计算用时，然后加起来看跟ans的关系</p><h2 id="最大值的最小or最小值的最大值"><a href="#最大值的最小or最小值的最大值" class="headerlink" title="最大值的最小or最小值的最大值"></a>最大值的最小or最小值的最大值</h2><p>二分，或贪心。</p><h2 id="N行4列的数，每一列选一个数，问使他们的和为0的情况有多少种"><a href="#N行4列的数，每一列选一个数，问使他们的和为0的情况有多少种" class="headerlink" title="N行4列的数，每一列选一个数，问使他们的和为0的情况有多少种"></a>N行4列的数，每一列选一个数，问使他们的和为0的情况有多少种</h2><ol><li>暴力，n^4^</li><li>先加前三列，然后第四列排序，然后查找是否有前三列和的相反数，n^3^</li><li>两列，两两相加，然后一列排序，然后查找相反数，复杂度n^2^ logn，（可用两个指针，然后从两头开始往中间走，若和为负则xxxx，若和为正则xxxx）</li><li></li></ol><h2 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h2><p>求单峰，单谷函数，求极值点</p><p>将左右界切成三分，然后每次删1/3，</p><p>或者对导数二分，</p><p>而导数用两个点求k，Δx很小</p><h2 id="01分数规划"><a href="#01分数规划" class="headerlink" title="01分数规划"></a>01分数规划</h2><p>一堆物品，有一个收益，有一个代价，给出一个方案，使得收益/代价 最大。</p><ol><li>首先证明以单个的受益/代价 的贪心是错的</li><li>先假设最大值大于等于x</li><li>然后移项可得<ol><li>收益-x代价大于等于0</li><li>所以贪心应为收益-x代价必须全选正的，</li><li>所以二分x，看求和结果是不是大于x</li><li>若不成立，说明这个x取大了</li><li>x为和，为最后的结果</li></ol></li><li>若为不是若干个而是k个，则应该让大于零的数应该有k个 </li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>倍增：</p><p>a的b次方膜p的值</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>二分，三分，01分数规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法公开课（二）</title>
    <link href="/2020/05/18/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/05/18/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>突然发现，学习STL之后链表的各种C实现就不用费劲写了，只用好好想重点逻辑就好了</p><a id="more"></a><h2 id="分治求解问题"><a href="#分治求解问题" class="headerlink" title="分治求解问题"></a>分治求解问题</h2><p>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p><h2 id="递归求解"><a href="#递归求解" class="headerlink" title="递归求解"></a>递归求解</h2><p>写递归的时候要注意不能自己一个一个桃，就直接定好之后管tm</p><h3 id="例一汉诺塔"><a href="#例一汉诺塔" class="headerlink" title="例一汉诺塔"></a>例一汉诺塔</h3><ol><li>首先三个柱子进行分析</li><li>前n个从A到C<ol><li>则首先前n-1从A到B</li><li>然后第n个从A到C</li><li>最后前n-1个从B到C<ol><li>则（即进入递归）</li></ol></li></ol></li><li>数学表达式 f(n)=2f(n-1)+1</li></ol><h3 id="给出二叉树求前序中序和后序"><a href="#给出二叉树求前序中序和后序" class="headerlink" title="给出二叉树求前序中序和后序"></a>给出二叉树求前序中序和后序</h3><p>二叉树：每个节点最多有两个子树（节点分左右</p><p>满二叉树：除了最后一层无子节点，其他都满了</p><p>完全二叉树，除了最后一层外，每一层均达到最大值，最后一层值缺少右边的若干个</p><p>性质：左=根*2，右=根*2+1,这样的二叉树用数组就能直接存下来</p><p>先序遍历：首先访问根节点，然后遍历左子树，再遍历右子树</p><p>中序：左   根   右  //排序后就像从左往右写</p><p>后序： 左  右   根 </p><p>//以上三个序是考虑根的位置</p><p>层序：从上到下从左往右。</p><p><strong>题目实质</strong> 根据已知信息画出树的全貌</p><p>中序遍历给出从左往右怎么排序</p><p>前序遍历给出那些是根，从而得到树的全貌</p><p><em>已知前序后序，中序不唯一</em></p><p>具体实现的时候，先写出遍历函数，然后递归遍历左子树右子树，输出时先左后右。</p><p><strong><em>作为人类，只需要想一层</em></strong></p><h3 id="归并排序，快速排序"><a href="#归并排序，快速排序" class="headerlink" title="归并排序，快速排序"></a>归并排序，快速排序</h3><h4 id="再谈基数排序"><a href="#再谈基数排序" class="headerlink" title="再谈基数排序"></a>再谈基数排序</h4><p>当我们把桶竖着放的时候，顺序是显然的</p><p>所谓的增加的基数，可以开99个桶，然后塞进去</p><h4 id="初探计数排序"><a href="#初探计数排序" class="headerlink" title="初探计数排序"></a>初探计数排序</h4><p>对桶求前缀和，</p><p>可以轻松知道某个大小的数在第几位</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>待排子区间一分为二，讲子区间排序，然后讲已经排好序的两个序列合并</p><ul><li>怎么合并呢<ul><li>从首位比较，然后放好小的之后，小的那个指针后移，到所在序列的下一项</li></ul></li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>选择一个基准，小于基准放左边，大于基准放右边，然后对左右继续上述操作</p><p>复杂度均为nlog（n）</p><ul><li>每一次为n，然后有log（n）层。</li></ul><h3 id="求一个序列第k大数"><a href="#求一个序列第k大数" class="headerlink" title="求一个序列第k大数"></a>求一个序列第k大数</h3><p>先选一个基准，假设基准右边&lt;=k，则第k大一定在左边，则右边直接丢掉</p><p>复杂度logn，不断二分序列</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h3><p>_Tp min(_Tp a,_Tp b)</p><p>_Tp为模板类，传进去什么传出来什么</p><p>sort（a,a+10）,传进去的是指针，然后是左闭右开的a和a+10，</p><p>对结构体排序</p><ul><li>自定义比较函数，返回bool值，return a.x&lt;b.x; 无等号，</li><li>重定义&lt;运算符</li><li>写在结构体里面</li><li>bool operator &lt; (ty b)</li><li>{</li><li>return     x&lt;b;</li><li>}</li></ul><p>求下一个排列</p><p>把 123 变成 132 213</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>分治and递归&amp;&amp;STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客算法题解（二）</title>
    <link href="/2020/05/17/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/05/17/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>5月17号，补充了第一题的题解，放在了（一）里</p><a id="more"></a>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>鸽子记录</title>
    <link href="/2020/05/16/%E9%B8%BD%E5%AD%90%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/05/16/%E9%B8%BD%E5%AD%90%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>此处目前单纯记载我的鸽（断）子（更）记录</p><a id="more"></a><p>没有记录的断更记录可能是因为文章被隐藏了哦，找找看吧</p><p>2020年5月16日，周六，被迫断更</p><p>2020年5月20日，周三，再次断更</p><p>2020年5月23日，周六，只要我写了鸽子记录，就不算断更</p><p>2020年5月24日，周日，今天困了，早点睡吧</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（七）</title>
    <link href="/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>不能咕咕！树的预备知识</p><a id="more"></a><p>树的大部分操作的运行时间平均为O（logN）</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>树的递归定义：由根节点和多个子树构成，每个子树的根都被来自跟集结点的一条有向线段连接。一棵树实际上是N个结点和N-1条边的集合</p><p>名词定义</p><ul><li>root：根，根节点</li><li>edge：边，有向，为连接点的直线</li><li>child：根r的儿子，每一个子树的根叫做根r的儿子</li><li>parent：父亲，r是每一个子树的根的父亲 </li><li>leaf：树叶，没有儿子的节点</li><li>sibling：兄弟，具有相同父亲节点</li><li>grandparent：同上类似定义</li><li>grandchild：同上类似定义</li><li>path：路径，从节点n<del>1</del>到n<del>k</del>的路径定义为节点n<del>1</del>，n<del>2</del>,  n<del>3</del>   …………n<del>k</del>  的一个序列，使得对于1&lt;=i&lt;k，有节点n<del>i</del> 是n<del>i+1</del> 的父亲<ul><li>length：路径的长，edge的个数且=k-1</li></ul></li><li>depth：深度，从根到n<del>i</del>的唯一路径的长</li><li>height：高，节点n<del>i</del> 到一片树叶的最长路径的长，一颗树的高等于其根的高</li><li>ancestor：祖先，存在n<del>1</del> 到n<del>2</del>的一条路径，则n<del>1</del> 为n<del>2</del>的一位祖先</li><li>descendant：后裔，上文中n<del>2</del>为n<del>1</del>的后裔，n<del>1</del>！=n<del>2</del> 的时候为真祖先真后裔</li></ul><h1 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h1><p>假设用一个数据结构，在结构中有指向所有儿子的指针。这样不可行是因为每个节点的儿子的个数未知</p><p><strong>可行的方法</strong>是</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree</span></span><span class="hljs-class"></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> i;ptrToNode firstChild;ptrToNode nextSibling；&#125;</code></pre><p>并不直接连接各个儿子，而是只连接第一个儿子，然后让第一个儿子去找他的兄弟们</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第四章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客算法题解（一）</title>
    <link href="/2020/05/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/05/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>5.15号，第一题的暴力解法，优化过程，出过的错误，以及对拍随机数代码。</p><a id="more"></a><p>题目内容</p><p>/*</p><p><em>链接：<a href="https://ac.nowcoder.com/acm/problem/14583" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/14583</a></em></p><p><em>来源：牛客网</em></p><p><em>从前，有n只萌萌的糖糖，他们分成了两组一起玩游戏。他们会排成一排，第i只糖糖会随机得到一个能力值bi。从第i秒的时候，第i只糖糖就可以消灭掉所有排在他前面的和他不是同一组的且能力值小于他的糖糖。</em></p><p><em>为了使游戏更加有趣，糖糖的爸爸，娇姐，会发功m次，第i次发功的时间为ci，则在第ci秒结束后，b1,b2,…..,bci都会增加1.</em></p><p><em>现在，娇姐想知道在第n秒后，会有多少只糖糖存活下来。</em></p><p><em>*/</em></p><h1 id="我的暴力模拟法"><a href="#我的暴力模拟法" class="headerlink" title="我的暴力模拟法"></a>我的暴力模拟法</h1><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">int</span> T,n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span> (T&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">int</span> temp=n;        temp++;        <span class="hljs-keyword">int</span> t[n];  <span class="hljs-comment">//那一组</span>        <span class="hljs-keyword">int</span> ts[n]; <span class="hljs-comment">//能力值</span>        <span class="hljs-keyword">int</span> fg[m];        <span class="hljs-built_in">memset</span>(t,<span class="hljs-number">0</span>,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));        <span class="hljs-built_in">memset</span>(ts,<span class="hljs-number">0</span>,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));        <span class="hljs-built_in">memset</span>(fg,<span class="hljs-number">0</span>,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;        n++;        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)        &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;t[i], &amp;ts[i]);            i++;            n--;        &#125;        i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (m&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;fg[i]);            i++;            m--;        &#125;        i=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> fgs=<span class="hljs-number">0</span>;<span class="hljs-comment">//发功次数</span>        n=temp;        <span class="hljs-keyword">while</span> (i&lt;n)        &#123;            <span class="hljs-comment">//i为秒数</span>            <span class="hljs-keyword">int</span> temp1=i<span class="hljs-number">-1</span>;            <span class="hljs-keyword">while</span> (temp1&gt;=<span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span> (t[temp1]!=t[i])                &#123;                    ts[temp1]=ts[temp1]&gt;=ts[i]?ts[temp1]:<span class="hljs-number">0</span>;                &#125;                <span class="hljs-comment">//此处必然可以优化</span>                temp1--;            &#125;            <span class="hljs-comment">//以上在消灭灭糖糖</span>            <span class="hljs-comment">//一下是发功</span>            <span class="hljs-comment">//啊啊啊啊，这些本来都该用for循环来着</span>            temp=<span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (i==fg[fgs])            &#123;                <span class="hljs-keyword">while</span> (temp&lt;=i)                &#123;                    <span class="hljs-keyword">if</span> (ts[temp]!=<span class="hljs-number">0</span>)                    &#123;                        ts[temp]++;                    &#125;                                        temp++;                &#125;                fgs++;            &#125;            i++;                    &#125;        <span class="hljs-keyword">int</span> temp1=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (temp1&lt;n)        &#123;            <span class="hljs-keyword">if</span> (ts[temp1]!=<span class="hljs-number">0</span>)            &#123;                ans++;            &#125;            temp1++;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);        T--;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="在写的时候遇见的问题（按照恶心程度排序"><a href="#在写的时候遇见的问题（按照恶心程度排序" class="headerlink" title="在写的时候遇见的问题（按照恶心程度排序"></a>在写的时候遇见的问题（按照恶心程度排序</h2><ol><li>糖糖从1开始而不是从0开始</li><li>相等的时候不杀</li><li>没了</li></ol><p>但是这个debug用了我快1h，还是在有对拍的情况下。</p><p>说到对拍，结尾会附上这道题的对拍随机数代码</p><h2 id="开始挠头想优化"><a href="#开始挠头想优化" class="headerlink" title="开始挠头想优化"></a>开始挠头想优化</h2><h3 id="分析算法的复杂度"><a href="#分析算法的复杂度" class="headerlink" title="分析算法的复杂度"></a>分析算法的复杂度</h3><p>读入数据为n+m</p><p>消灭糖糖为1^2^+2^2^……=n^3^</p><p>给糖糖升级，为n^2^ </p><p>输出结果为n</p><p>题目的数据范围为1&lt;=n&lt;=50000，(5*10^4^ )^2^ =10^9^ ,明显是不可接受的算法</p><p>然后开始做优化。</p><p>当然是从消灭和升级入手</p><p>消灭的</p><pre><code class="hljs plain">while (temp1&gt;&#x3D;0)&#123;    if (t[temp1]!&#x3D;t[i])        &#123;            ts[temp1]&#x3D;ts[temp1]&gt;&#x3D;ts[i]?ts[temp1]:0;            &#125;        temp1--;&#125;</code></pre><p>这部分实际上是在通过一个O（n）的遍历来判断<code>ts[temp1]</code>前面的数据的大小如何。</p><h3 id="思想（并没有按照可行性排序"><a href="#思想（并没有按照可行性排序" class="headerlink" title="思想（并没有按照可行性排序"></a>思想（并没有按照可行性排序</h3><p>二维数组or结构体，不同的组放入不同的数组里，但是被放入的数组中仍保留着自己是第几个元素，这样的话平均，可以少遍历一半的内容,之后陷入僵局</p><h3 id="从另一个角度想（从后往前遍历"><a href="#从另一个角度想（从后往前遍历" class="headerlink" title="从另一个角度想（从后往前遍历"></a>从另一个角度想（从后往前遍历</h3><p>增加战力，实际上不改变第i个人与前面每个人的差值，所以我们先不让人死，同时加完战力</p><blockquote><p>举例:50,1,2,3,4,5,6,7,8,9,20,30,53.</p><p>同时50与后面不同组。在第3秒，第4秒，第5秒……都加了战力</p><p>正常而言，前面都杀不死他，到了53，自然杀不死。</p><p>而假如：50，49，48，47，53.</p><p>能通过加战力使得后面杀不死他的本身就确实是杀不死的，所以这种想法有可行性</p></blockquote><h4 id="分析复杂度"><a href="#分析复杂度" class="headerlink" title="分析复杂度"></a>分析复杂度</h4><p>读入为n+m，添加战力是m*n，然后从后往前比较</p><blockquote><p>如果第<em>i</em>个人的战力小于后面另一个队的最大战力值，则一定会死</p></blockquote><p>假如我可以写出O（1）的算法，知道i，立刻知道后面队的最大战力，就能把复杂度降低为n。</p><p>方法，在读入数据的时候用另一个数组直接存就ok了。</p><p>那这么看，添加战力这玩意好烦，</p><p>再优化。</p><p>所谓添加战力，实际上就是数列修改问题。</p><p>所以用一个数组维护差值，再对差分数组求前缀和就ok了。这样O（1）得到修改后的值。</p><h3 id="总结优化思路"><a href="#总结优化思路" class="headerlink" title="总结优化思路"></a>总结优化思路</h3><p>从后往前遍历最大值，一个数组维护最大值，一个数组求差分，一个数组求前缀后</p><h3 id="c的实现"><a href="#c的实现" class="headerlink" title="c的实现"></a>c的实现</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TANGTANG</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> zu;    <span class="hljs-keyword">int</span> power;    <span class="hljs-keyword">int</span> different;    <span class="hljs-keyword">int</span> sum;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>;    <span class="hljs-comment">//struct TANGTANG *nextDifferentPosition;</span>    <span class="hljs-keyword">int</span> nextDifferentPosition;&#125;tt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span> (T&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n为糖糖的个数，m为发功次数</span>        <span class="hljs-keyword">int</span>  temp;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        n=<span class="hljs-number">5</span>;        m=<span class="hljs-number">4</span>;<span class="hljs-comment">//测试用数据</span>        n++;        tt one[<span class="hljs-number">7</span>];        <span class="hljs-keyword">int</span> *next[n];        temp=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (temp&lt;n)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;one[temp].zu,&amp;one[temp].power);            <span class="hljs-keyword">if</span> (temp&gt;<span class="hljs-number">1</span>)            &#123;                one[temp].different=one[temp].power-one[temp<span class="hljs-number">-1</span>].power;                one[temp].sum=one[temp<span class="hljs-number">-1</span>].sum+one[temp].different;                 &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp==<span class="hljs-number">1</span>)            &#123;                one[temp].different=<span class="hljs-number">0</span>;                one[temp].sum=<span class="hljs-number">0</span>;            &#125;            <span class="hljs-comment">//sum,是在对差分数组求前缀和。此处不能求最大值，因为我要的最大值是从后往前</span>                                            temp++;        &#125;        temp=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-comment">//用于next</span>        <span class="hljs-keyword">int</span> changeNumeber[<span class="hljs-number">500</span>]=&#123;<span class="hljs-number">0</span>&#125;;        next[i]=&amp;changeNumeber[i];        i++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++)        &#123;            changeNumeber[i]=i;            next[i]=&amp;changeNumeber[i];        &#125;                <span class="hljs-keyword">while</span> (temp&lt;n<span class="hljs-number">-1</span>)        &#123;                        <span class="hljs-keyword">if</span> (one[temp].zu==one[temp+<span class="hljs-number">1</span>].zu)            &#123;                one[temp].nextDifferentPosition=*next[i];            &#125;<span class="hljs-keyword">else</span>            &#123;                changeNumeber[i]=temp+<span class="hljs-number">1</span>;                next[i]=&amp;changeNumeber[i];                i++;            &#125;            temp++;                    &#125;                temp=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> addpower[m];        <span class="hljs-keyword">while</span> (temp&lt;m)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;addpower[temp]);            temp++;        &#125;        temp=n;        <span class="hljs-keyword">while</span> (temp&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">if</span> (temp==n)            &#123;                one[temp].<span class="hljs-built_in">max</span>=one[temp].power;            &#125;<span class="hljs-keyword">else</span>            &#123;                one[temp].<span class="hljs-built_in">max</span>=one[temp+<span class="hljs-number">1</span>].<span class="hljs-built_in">max</span>&gt;one[temp].power?one[temp+<span class="hljs-number">1</span>].<span class="hljs-built_in">max</span>:one[temp].power;            &#125;            temp--;        &#125;                                T--;    &#125;    &#125;</code></pre><p>问题：爆空间了，没能处理好怎么加能力，没处理好分组的问题</p><h1 id="大佬的解法与学习"><a href="#大佬的解法与学习" class="headerlink" title="大佬的解法与学习"></a>大佬的解法与学习</h1><p>关于添加能力</p><blockquote><p>有影响的一定是1 - ci1，我们可以维护一个前缀和，Csum[i] 表示第i<em>i</em> 项前面有几次操作，这样做的意义是什么呢，对于Csum[j-1]-Csum[i-1]且j&gt;=i表示位置<em>i</em> 的糖糖比位置<em>j</em>多了几次赋值+1的操作。</p></blockquote><p>关于处理最大值</p><blockquote><p>当且仅当i+1&lt;=j&lt;=n位置存在和糖糖i不是一队且B[i]+Csum[j-1]-Csum[i-1]&lt;B[j]的时候，位置i的糖糖才会被击败，将式子移项即可发现，B[i]-Csum[i-1]&lt;B[j]-Csum[j-1]</p></blockquote><p>也就是比较B-Csum的值</p><p>关于分组</p><blockquote><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--)&#123;    <span class="hljs-keyword">int</span> sum = Max[team[i] ^ <span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span> (sum &lt;= B[i] - Csum[i - <span class="hljs-number">1</span>])        cnt++;    Max[team[i]] = <span class="hljs-built_in">max</span>(Max[team[i]], B[i] - Csum[i - <span class="hljs-number">1</span>]);&#125;</code></pre></blockquote><p>不用考虑分组？？用的倒序遍历，因为找到了要比较的东西。实际上我自己写的内容还没到比较的部分，也没想到再开一个单纯的数组存储最大值，异或1为取反，对每一个zu，直接取反就能得到另外组的最大值</p>]]></content>
    
    
    <categories>
      
      <category>算法题目</category>
      
      <category>牛客</category>
      
      <category>第一次</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法公开课（一）</title>
    <link href="/2020/05/14/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/05/14/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>内容包括：尺取法，前缀和，差分，贪心</p><a id="more"></a><ol><li>养成写题解的习惯</li><li>存在每日一题，要做，刷题不能手生。</li><li>至少独立思考半小时，不要对着别人的代码</li></ol><h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><h3 id="怎么评价一个算法"><a href="#怎么评价一个算法" class="headerlink" title="怎么评价一个算法"></a>怎么评价一个算法</h3><ol><li>正确性</li><li>可读性</li><li>容错性（不考虑）</li><li>时间复杂度</li><li>空间复杂度</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(1), 常数算法，与输入数据规模无关</p><p>O（logn）</p><p>O（根号n）</p><p>O（n）线性时间复杂度</p><p>将数据大小代入O中的n，得到的结果若10^8^ 级别的则时可以接受的算法，</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>512M 一个int类型的数组，这个数组最大能开到512×1024×1024×8/32 ==10^8^这么大数组，第一个1024时kb，第二个是字节，第三个8是位数，int为32位。得出结果</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ol><li>定义<ol><li>要点：不重复，不遗漏</li><li>一一列举</li></ol></li><li>优化枚举的思路——减少枚举次数<ol><li>选择合适的枚举对象（找人，先枚举班级，然后枚举）</li><li>选择合适的枚举方向（从前往后or从后往前）</li><li>选择合适的数据维护方法（数据结构）</li></ol></li><li>例题</li></ol><h3 id="例题1：最大正方形"><a href="#例题1：最大正方形" class="headerlink" title="例题1：最大正方形"></a>例题1：最大正方形</h3><p><img src="https://i.loli.net/2020/05/14/adi9EWp74lToxFq.png" srcset="/img/loading.gif" alt="image-20200514202949847"></p><ul><li>思考，几个点确定一个正方形：两个点即可，所以可以枚举两个点，然后计算出另外两个坐标，将另外两个点比较是否为‘#’</li></ul><h3 id="例题2：数列求和（前缀和）"><a href="#例题2：数列求和（前缀和）" class="headerlink" title="例题2：数列求和（前缀和）"></a>例题2：数列求和（前缀和）</h3><p><img src="C:%5CUsers%5C%E7%8E%8B%E5%96%86%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200514203431390.png" srcset="/img/loading.gif" alt="image-20200514203431390"></p><ul><li><p>想法：先考虑暴力怎么做。</p></li><li><p>优化</p><ul><li><p>主要时间复杂度瓶颈在哪里？</p></li><li><blockquote><p>每次求和都要遍历区间</p></blockquote></li><li><p>所以可以用sum[i]存储前n个数的和，sum[i]=sum[i-1]+a[i]</p></li><li><p>sum[i]称为<strong>前缀和</strong>，单次查询的复杂度优化为O（1）</p></li><li><p>能够用前缀xx的都要满足一个类似于“sum[i]=sum[i-1]+a[i]”的条件</p></li></ul></li></ul><h3 id="例题3：数列修改问题（差分法）"><a href="#例题3：数列修改问题（差分法）" class="headerlink" title="例题3：数列修改问题（差分法）"></a>例题3：数列修改问题（差分法）</h3><p><img src="https://i.loli.net/2020/05/14/XzaRwjklZ4W9SEI.png" srcset="/img/loading.gif" alt="image-20200514204033460"></p><ul><li><p>优化：</p><ul><li><p>将对区间的修改变为对区间端点的修改（因为时间复杂度来自对区间的遍历）</p><ul><li><p>具体思考：考虑区间加的过程中什么值是区间段点处发生了变化，而区间内没有变化的</p></li><li><blockquote><p>每个数与前面的差值</p></blockquote></li></ul></li><li><p>具体实现为用一个数组维护第i个数和前一个数的差值</p><ul><li>重点：还要再对delta数组做一个前缀和，才能O（1）后得到修改后的值</li></ul></li><li><p>这种方法叫做<strong>差分</strong></p></li></ul></li></ul><h3 id="例题4：校门外的树（离散化操作）"><a href="#例题4：校门外的树（离散化操作）" class="headerlink" title="例题4：校门外的树（离散化操作）"></a>例题4：校门外的树（离散化操作）</h3><p><img src="https://i.loli.net/2020/05/14/1KTVApWtOlPYqBj.png" srcset="/img/loading.gif" alt="image-20200514204627106"></p><ul><li>暴力算法 easy</li><li>计算每个节点被多少区间覆盖了。然后节点为0的个数</li><li>第三种算法：<ul><li>离散化操作</li><li>区间为[1，100],[1000,2000],[5,110].</li><li>并不用开2000大小的数组，而是将上面的数组重新编号，变成连续的数组</li></ul></li></ul><h3 id="例题5类似于最大子序列和（尺取法）"><a href="#例题5类似于最大子序列和（尺取法）" class="headerlink" title="例题5类似于最大子序列和（尺取法）"></a>例题5类似于最大子序列和（尺取法）</h3><p><img src="https://i.loli.net/2020/05/14/XlwgxE4UKp32DbF.png" srcset="/img/loading.gif" alt="image-20200514205604877"></p><ul><li>暴力的算法是n^3^</li><li>用前缀和可以减去求和，变成n^2^</li><li>用和<strong>最大子序列和的算法四</strong>相同的思想，发现<ul><li>用区间和作为尺子，不断地向后平移。</li><li>首先确定一个L，然后得到一个R，当L向后再平移的时候，R必然不能往前移动，只能往后面移动or原地不动</li><li><strong>Two-pointer/尺取法/追逐法</strong></li></ul></li></ul><h3 id="例题6：按灯泡开关"><a href="#例题6：按灯泡开关" class="headerlink" title="例题6：按灯泡开关"></a>例题6：按灯泡开关</h3><p><img src="https://i.loli.net/2020/05/14/JPTXMYO4sEopRWF.png" srcset="/img/loading.gif" alt="image-20200514210645631"></p><ul><li>每个灯只按一次（因为2次恢复原样，3次同1次）</li><li>仔细分析，发现第一列开关怎么按确定后，后面的所有的灯怎么按动已经确定了。因为第二列的开关可以弥补第一列开关的操作，但是最后一列不行。没有再后面一列弥补了。<ul><li>得到，枚举对象应该为第一列的灯的按动方法</li></ul></li><li>计算时间复杂度</li><li>第一列开关按法为2^n^然后再×N×M，</li><li>具体枚举方法，将亮灭看为2进制字符串，然后转化为十进制整数，然后枚举整数</li><li>名字叫<strong>状态压缩</strong></li></ul><h2 id="位运算介绍"><a href="#位运算介绍" class="headerlink" title="位运算介绍"></a>位运算介绍</h2><p>左移右移等价于*/2 </p><p>| 或</p><p>&amp; 与</p><p>~ 取反</p><p>^ 异或 是不是不一样，相同为0，不同为1，可以视为不带进位的加法。异或0，为本身，异或1，为取反</p><p>应该达到的水平，对int进行位运算的时候，眼中只有01串，看为01串，不用管本身是什么。</p><p>去掉二进制最后一位，右移一位</p><p>最后一位加0，左移一位</p><p>最后加一个1，左移一位+1</p><p>最后一位变成1，或1</p><p>最后一位变成0，先或1，再减掉1</p><p>最后一位取反，异或1</p><p>右数第k位变成1，先把1左移k-1位，然后或1</p><p>右数第k位变成0</p><pre><code class="hljs x&(~(1<<(k-1)))```">右数第k位取反&#96;&#96;&#96;x^(1&lt;&lt;(k-1))</code></pre><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>简而言之，每次都选局部最优解</p><p>能够使用贪心算法的问题都能严格证明局部最优解就是全局最优解</p><h3 id="第一题（没听全，应该很简单）"><a href="#第一题（没听全，应该很简单）" class="headerlink" title="第一题（没听全，应该很简单）"></a>第一题（没听全，应该很简单）</h3><p><img src="https://i.loli.net/2020/05/14/JLrp1k2AvK6zysm.png" srcset="/img/loading.gif" alt="image-20200514213918707"></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><img src="https://i.loli.net/2020/05/14/1emXREjvYl4zDTK.png" srcset="/img/loading.gif" alt="image-20200514214126456"></p><p>按照字典序排序。但这个不是正确的  3 31 39. 最大为 39 33 1.对于这种情况的，先连接起来，再比较大小也就是比较331 313的大小。</p><h3 id="第三题-区间覆盖（工作安排）"><a href="#第三题-区间覆盖（工作安排）" class="headerlink" title="第三题 -区间覆盖（工作安排）"></a>第三题 -区间覆盖（工作安排）</h3><p><img src="https://i.loli.net/2020/05/14/5XGu2vfFcbUYNkE.png" srcset="/img/loading.gif" alt="image-20200514214744728"></p><p>贪心策略：选择结束时间尽量早的。</p><p>证明：离散数学课本</p><h3 id="第四题-活动安排"><a href="#第四题-活动安排" class="headerlink" title="第四题 活动安排"></a>第四题 活动安排</h3><p><img src="https://i.loli.net/2020/05/14/cEevu5jfbVBHiJg.png" srcset="/img/loading.gif" alt="image-20200514215441725"></p><p>先取两件事AB</p><p>当A在B前面，求出A的扣分，B 的扣分</p><p>当B在A前面，求出B的扣分，A的扣分</p><p>假设A在B前是最优解，解出要求</p><h3 id="第五题-国王游戏"><a href="#第五题-国王游戏" class="headerlink" title="第五题 国王游戏"></a>第五题 国王游戏</h3><p><img src="https://i.loli.net/2020/05/14/89Oedhx7ZszHQmk.png" srcset="/img/loading.gif" alt="image-20200514220239896"></p><p><img src="https://i.loli.net/2020/05/14/BSyZX4oYTraGmQ5.png" srcset="/img/loading.gif" alt="image-20200514220312802"></p><p>同理，取AB两个人，交换这两个人的顺序不影响结果</p><p>A在B前面，表示出A获得的奖赏①，B获得的奖赏②</p><p>A在B前面，表示出A获得的奖赏③，B获得的奖赏④</p><p>max(①，②)&lt;=max(③，④)</p><p>则 max(③，④)=③，且③&gt;=max(①，②)</p><p>解方程得到贪心的方法。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>枚举贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（六）</title>
    <link href="/2020/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2020/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>关于栈的其他运用，后缀表达式，函数调用,以及队列ADT</p><a id="more"></a><h1 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h1><h2 id="计算后缀表达式的c实现"><a href="#计算后缀表达式的c实现" class="headerlink" title="计算后缀表达式的c实现"></a>计算后缀表达式的c实现</h2><ul><li><input disabled="" type="checkbox"> 再次待办</li></ul><h2 id="将中缀表达式变为后缀表达式的c实现"><a href="#将中缀表达式变为后缀表达式的c实现" class="headerlink" title="将中缀表达式变为后缀表达式的c实现"></a>将中缀表达式变为后缀表达式的c实现</h2><ul><li><input disabled="" type="checkbox"> 再次待办</li></ul><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>一个奇妙的想法，函数调用类似于平衡符号，因为都是又开放括号（进入函数）封闭括号（return）</p><ul><li>栈溢出为什么会无法调试，程序崩溃。因为栈的信息被冲毁了，返回地址凉凉了，找不到了。</li></ul><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>定义：最后一行的递归调用，可以通过将递归调用变成goto语句并且在其前方加上对函数每个参数的赋值语句而手动消除</p><p class="note note-waring">不要这么做，编译器会帮你这么优化的# 队列ADT<p>没什么好说的</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（五）</title>
    <link href="/2020/05/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2020/05/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天啊，今天是奋力不咕咕的一天,虽然创建文档的时间是晚上十一点，但真正开始动笔已经是第二天0点12分了。今天的内容，关于栈。</p><a id="more"></a><h1 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h1><p>进栈，出栈。是后进先出的ADT</p><ul><li>一个特性：<strong>唯一可见元素是首元素</strong></li></ul><h1 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h1><p>栈这种结构本身是一个表，所以数组，链表（指针），都可以用于实现栈。一个是顺序，一个非顺序</p><p class="note note-warning"> 对于栈来说，顺序or非顺序存储，没有区别，但是数组的栈的总大小是确定的 </p><p>具体的c代码实现……再次列入待办事项中</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>栈的各种操作都是常数时间，但是栈超出界限的时候，就会程序崩溃，所以仔细检查是有必要的。</p><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="符号配对"><a href="#符号配对" class="headerlink" title="符号配对"></a>符号配对</h2><p>检测是否每个 “{” ，都有对应的 “}”，同时我联想到，/* 与 */ 也可这样判定。只用将两个符号组成的结构体压入栈中，并且处理好前进后退</p><h3 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h3><p>自然语言实现</p><p>做一个空栈，读入字符直到文件末尾，读入的过程是这样的，从首字符开始，读入栈中，做判断，判断是保留还是弹出。</p><p>更实际的描述为开放的符号比如  <em>(、{、[、</em> ，push到栈里，如果字符为封闭字符 <em>）、}、]</em> ，且为空栈，则报错。若非空栈，则pop出栈里面的这个开放字符，跟封闭符号进行比较。若不配对，报错。当读到文件尾巴时，若非空栈，仍报错。</p><p class="note note-warning">栈中只有开放符号！<p>c语言实现</p><p class="note note-primary">进入待办事项吃灰吧</p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>待办事项们</title>
    <link href="/2020/05/12/%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%E4%BB%AC/"/>
    <url>/2020/05/12/%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%E4%BB%AC/</url>
    
    <content type="html"><![CDATA[<p>我期待的事情，等待||正在发生</p><a id="more"></a><ul><li><input disabled="" type="checkbox"> 多项式的链表实现</li></ul><ul><li><input disabled="" type="checkbox"> 基数排序的链表实现</li></ul><ul><li><input disabled="" type="checkbox"> 多重表的链表实现</li><li><input disabled="" type="checkbox"> 栈的c语言实现，包括链表和数组</li><li><input disabled="" type="checkbox"> 算法第一题优化后的c实现</li><li><input disabled="" type="checkbox"> 后缀表达式的c实现</li><li><input disabled="" type="checkbox"> 中缀表达式变为后缀表达式</li><li><input checked="" disabled="" type="checkbox"> 牛客题目</li></ul><hr><p>备忘的一些写法</p><pre><code class="hljs markdown">&#123;% cb text, checked?, incline? %&#125;//默认后面就直接换行</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"label label-primary"</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"note note-primary"</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>/*可选的有primarysecondarysuccessdangerwarninginfolight*/</code></pre>]]></content>
    
    
    <categories>
      
      <category>我期待的</category>
      
    </categories>
    
    
    <tags>
      
      <tag>待办事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（四）</title>
    <link href="/2020/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2020/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第四天学习的内容，实现桶排序，看了多重表，跳过游标实现链表</p><a id="more"></a><h1 id="关于桶排序"><a href="#关于桶排序" class="headerlink" title="关于桶排序"></a>关于桶排序</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bucketsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> count)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//桶排序，空间占用极大</span>    <span class="hljs-keyword">int</span> b[count];    <span class="hljs-keyword">int</span> count2;<span class="hljs-comment">//此为整数的个数</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;count2);    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,count*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count2; i++)    &#123;        <span class="hljs-keyword">int</span> temp;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;temp);        b[temp]+=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> t = <span class="hljs-number">0</span>; t &lt; b[i]; t++)        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,i);<span class="hljs-comment">//i就是temp，b[i]的值为有多少个temp</span>        &#125;    &#125;&#125;</code></pre><p>对于桶排序，我认为最好的方式是读入的同时就往桶里塞，这样有两个好处</p><ol><li>减小空间占用</li><li>减少读入数组的时间</li></ol><p>需要注意的是memset函数的最后一项参数，要有sizeof（int），因为memset的原理是把指定的空间变成指定值，这个空间需要我们自己来算。</p><h2 id="桶排序的问题"><a href="#桶排序的问题" class="headerlink" title="桶排序的问题"></a>桶排序的问题</h2><p>占用空间大，桶排序的桶的个数是由待排序数组的最大项决定的，也就是说即便是给0，1，99这样的三个数排序，也需要构建99个桶，这是无法忍受的。</p><blockquote><p>每种算法都有适合自己发光发热的地方，比如稠密的多项式用数组实现就很好，稠密的待排序序列用桶也很好。</p><p>比如对单词进行排序<del>然而我们直接有strcmp</del></p></blockquote><h2 id="桶排序的时间复杂度"><a href="#桶排序的时间复杂度" class="headerlink" title="桶排序的时间复杂度"></a>桶排序的时间复杂度</h2><p>O（M+N），M为整数的范围，N为整数的个数，</p><p>证明：N为填入桶中用的时间，下面的两重循环的值最大超不过M，超不过整数的范围</p><p class="note note-warning">    暂时存疑</p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>目前对于基数排序，我做到是基本理解其过程，但是还没有想到怎么用链表实现。</p><p>基数排序从最低位开始，填入基数个桶中。也就是说我们需要将待排序的数拆分成好几个基构成的。</p><p>比如十进制的数，天然以10为基，所以先按照个位填入桶中，然后，再按照十位填入桶中，填入桶的顺序是刚刚按照个位填入桶的顺序。</p><p><strong>举例子</strong> </p><p>​            512 216 第二次都应该投入1这个桶中，按照什么顺序投入呢，因为2&lt;6 所以先投入512，再投入216</p><p><strong>具体使用</strong></p><p>​            三十二位计算机，2<sup>11</sup> 个桶，给该计算机能表示的所有整数排序，最多三趟就能排完。 先按照前11位，再中间，最后结尾11位</p><div class="note note-success">            <p>暂时存疑too. </p>          </div><p><strong>代码实现</strong> </p><p>​            还存在一丢丢困难</p><p>​            放入代办中吧先。</p><h1 id="多重表"><a href="#多重表" class="headerlink" title="多重表"></a>多重表</h1><p>没什么好说的，非常奇技淫巧，同样期待着我的代码实现</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于项目的思考，包括计算器和雏燕</title>
    <link href="/2020/05/12/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E5%92%8C%E9%9B%8F%E7%87%95/"/>
    <url>/2020/05/12/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E5%92%8C%E9%9B%8F%E7%87%95/</url>
    
    <content type="html"><![CDATA[<p>闲下来的（大学英语课上），早就想写的关于项目的策划</p><a id="more"></a><h1 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h1><h2 id="首先要做的"><a href="#首先要做的" class="headerlink" title="首先要做的"></a>首先要做的</h2><p>手绘出GUI，然后使用tkinter或者其他的python图形化的库，绘制好按钮，安排好按钮的位置，也就是在视觉上实现GUI</p><blockquote><p>这是较为轻松的操作，但是wsl不好操作，还是需要图形化的系统才能简单实现………………比如Windows下………………因为黑框框的wsl跟GUI天然不兼容…………虽然能够通过pip3经过一系列操作安装上tkinter库，但是…………难以调出GUI…………</p></blockquote><h2 id="然后要做的"><a href="#然后要做的" class="headerlink" title="然后要做的"></a>然后要做的</h2><p>给每一个按钮写自己的方法。此处分工完成就好了。<strong><em>感觉应该同时包括把结果输出在屏幕上。</em></strong></p><p>难点：大量数据的计算必然要用的算法，人类直觉想到的算法一般时间复杂度为O（n^3），或者n^2，复杂度极高，<del>甚至满足不了也不是不能用</del>，所以需要善用搜素引擎，寻找诸如求幂，排序等的快速算法，快排啊，快速幂啊什么的。当然，python中也是有已经实现好了的算法库的。可以用pip3 install 库名 来安装</p><h2 id="最后要做的"><a href="#最后要做的" class="headerlink" title="最后要做的"></a>最后要做的</h2><p>封装成一般用户可以使用的样子</p><p>此处内容在书中的第十八章程序打包有相关的描述</p><h1 id="我的雏燕计划"><a href="#我的雏燕计划" class="headerlink" title="我的雏燕计划"></a>我的雏燕计划</h1><p>按照相同的处理思想，模块化的来写。</p><h2 id="先写出底部三个页面的接口，然后写三个页面的内容"><a href="#先写出底部三个页面的接口，然后写三个页面的内容" class="headerlink" title="先写出底部三个页面的接口，然后写三个页面的内容"></a>先写出底部三个页面的接口，然后写三个页面的内容</h2><h3 id="正经的写法"><a href="#正经的写法" class="headerlink" title="正经的写法"></a>正经的写法</h3><p>学习html，css，xml等内容，or 读微信开发者文档，强行上手，</p><p>我们的目标是，只写出按钮，并不实现按下按钮后能够做什么</p><h3 id="不正经的写法"><a href="#不正经的写法" class="headerlink" title="不正经的写法"></a>不正经的写法</h3><p>直接PS绘制出图形然后直接html 用img标签放进去就完事</p><h2 id="结束了……"><a href="#结束了……" class="headerlink" title="结束了……"></a>结束了……</h2><p>反正暂缓结题了，就在学习算法数据结构之余，随便写写得了</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>项目策划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（三）</title>
    <link href="/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第三天学习的内容，链表的复习，多项式ADT</p><a id="more"></a><h1 id="需要注意的内容"><a href="#需要注意的内容" class="headerlink" title="需要注意的内容"></a>需要注意的内容</h1><ol><li>声明指向一个结构体的指针并不能创造该结构体，只是给了足够的空间来容纳该指针。所以必须要malloc</li><li>而对于free而言，free之后，指针指向的地址没变，但是此处的内容已经无意义了，不再受到保护，随时都会发现值被改变</li><li>malloc的sizeof应该是结构体的大小，而不是指针的大小</li><li>对于删除操作，删除前应该先记下下一个节点的位置</li></ol><h1 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h1><h2 id="多项式ADT"><a href="#多项式ADT" class="headerlink" title="多项式ADT"></a>多项式ADT</h2><p><strong><em>多项式可以用于实现大整数的四则运算</em></strong></p><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> coedffArray[maxDegree+<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> highPower;&#125;  * polynomial;</code></pre><p>在数组中存储多项式各项的系数，然后进行加减乘除即可</p><p>其中maxDegree是已知的多项式可能存在的最大的次数，而highPower为目前一个特定多项式的最大项的次数。</p><h4 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h4><p>这样对多项式做加减法之前，先将数组赋值为0之后再给每一个特定的多项式赋值。然后进行加减的途中先比较最大项那个更大一些。然后加减</p><h4 id="乘除"><a href="#乘除" class="headerlink" title="乘除"></a>乘除</h4><p>乘除法需要注意</p><ol><li>是否超过了可能存在的最大次数</li><li>乘除认为做了分配律，第一个多项式的每一项 ÷ || ×  第二个多项式，具体的实现就是两个套着的循环</li></ol><h4 id="数组实现的问题"><a href="#数组实现的问题" class="headerlink" title="数组实现的问题"></a>数组实现的问题</h4><p>对于稠密的多项式，数组非常ok，但是对于不稠密的，大量的时间用在了乘0，效率极低。</p><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><ul><li><input disabled="" type="checkbox"> 等待之后几天做练习题的时候再实现</li></ul><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="前提：桶排序"><a href="#前提：桶排序" class="headerlink" title="前提：桶排序"></a>前提：桶排序</h3><ul><li><input disabled="" type="checkbox"> 等待实现的数组桶排序</li><li><input disabled="" type="checkbox"> 等待实现的基数排序</li></ul><h2 id="多重表"><a href="#多重表" class="headerlink" title="多重表"></a>多重表</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（二）</title>
    <link href="/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第二天学习的内容，关于欧几里得算法求最大公因数，以及快速幂</p><a id="more"></a><h1 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m ,<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> rem;    <span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>)    &#123;        rem=m%n;        m=n;        n=rem;    &#125;    <span class="hljs-keyword">return</span> m;&#125;</code></pre><p>称之为辗转相除法也可。时间复杂度为logn</p><p>通过定理</p><blockquote><p>如果M&gt;N,则M mod N &lt; M/2</p><p>分两种情况证明</p></blockquote><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qiumi</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//复杂度为log（n）</span>    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">if</span> (n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">//偶数</span>    &#123;        <span class="hljs-keyword">return</span> qiumi(x*x,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//求x方的n/2次幂。然后x的四次方的n/4次幂，以此类推，得到x的n次幂。</span>    &#125;<span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> qiumi(x*x,(n)/<span class="hljs-number">2</span>)*x;    &#125;&#125;</code></pre><p>时间复杂度为 logn</p><p>一般的循环做法时间复杂度为n</p><p>求2^10次方，可以变为2^5 *2 ^5 </p><p>然后2^5 可以为2 ^2 *2^2 *2</p><p>也就是先计算2×2，然后 4×4×2，然后32×32，总共四次乘法</p><p>然后写递推的思路，求x^n，若n为偶数，则先求 x^(n/2) ，然后对其 平方。</p><p>然后如果n为奇数，则求x的n-1次方，再乘x</p><p>下面按照此思路再写一遍代码</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kuaisumi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b==<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> kuaisumi(a,n/<span class="hljs-number">2</span>)*kuaisumi(a,n/<span class="hljs-number">2</span>);    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> kuaisumi(a,n<span class="hljs-number">-1</span>)*a;&#125;</code></pre><p>我们发现第六行与正确答案不一样，我们应该用正确答案的写法。</p><p>因为</p><pre><code class="hljs c">kuaisumi(a,n/<span class="hljs-number">2</span>)*kuaisumi(a,n/<span class="hljs-number">2</span>);</code></pre><p>会造成调用两个递归，而不是一个递归。影响效率</p><h1 id="明天的学习目标"><a href="#明天的学习目标" class="headerlink" title="明天的学习目标"></a>明天的学习目标</h1><p>学习完3.1，3.2</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第二章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（一）</title>
    <link href="/2020/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第一天学习的内容，关于最大子序列的和四种算法</p><a id="more"></a><h1 id="一般能想到的算法"><a href="#一般能想到的算法" class="headerlink" title="一般能想到的算法"></a>一般能想到的算法</h1><h2 id="O（n-3）的算法"><a href="#O（n-3）的算法" class="headerlink" title="O（n^3）的算法"></a>O（n^3）的算法</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nOfCubed</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *a*[],<span class="hljs-keyword">int</span> *n*)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  *<span class="hljs-comment">//从第0项开始加，0，01，012，0123，012……n，1，12，123，这样遍历*</span>  <span class="hljs-keyword">int</span> sum,maxsum,j,k;  maxsum=<span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  &#123;​    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> t = i; t &lt; n; t++)​    &#123;​      sum=<span class="hljs-number">0</span>;​      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> k = i; k &lt;=t; k++)​      &#123;​        sum+=a[k];​      &#125;​      <span class="hljs-keyword">if</span> (sum&gt;maxsum)​      &#123;​        maxsum=sum;​      &#125;​      ​      ​    &#125;​      &#125;  <span class="hljs-keyword">return</span> maxsum;  &#125;</code></pre><h2 id="O（n-2）的算法"><a href="#O（n-2）的算法" class="headerlink" title="O（n^2）的算法"></a>O（n^2）的算法</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//0然后比较，01，比较，0123，比较，也就是在一次循环中同时做了加和比较两件事情，使得立方运行时间变成了平方</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  sum,<span class="hljs-built_in">max</span>;    <span class="hljs-built_in">max</span>=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> t = i; t &lt; n; t++)        &#123;            sum+=a[t];            <span class="hljs-keyword">if</span> (sum&gt;<span class="hljs-built_in">max</span>)            &#123;                <span class="hljs-built_in">max</span>=sum;            &#125;                &#125;            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;   &#125;</code></pre><h2 id="n-2与n-3-算法的区别"><a href="#n-2与n-3-算法的区别" class="headerlink" title="n^2与n^3 算法的区别"></a>n^2与n^3 算法的区别</h2><p>对于n^3的算法，每次计算子序列的和需要重新从首项开始加，耗费了大量时间，所以在n^2的算法里，我们在每一次求出和之后立马进行比较，少了一次从首项开始加，从而成功减小时间复杂度。</p><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fenzhi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> maxOfLeft=<span class="hljs-number">0</span>,maxOfRight=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxLeftB=<span class="hljs-number">0</span>,maxRightB=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> leftBSum=<span class="hljs-number">0</span>,rightBSum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> center=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;    <span class="hljs-comment">//下面为基准情形，用于退出递归</span>    <span class="hljs-keyword">if</span> (left==right)    &#123;        <span class="hljs-keyword">if</span> (a[left])        &#123;            <span class="hljs-keyword">return</span> a[left];        &#125;<span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    center=(left+right)/<span class="hljs-number">2</span>;    maxOfLeft=fenzhi(a,left,center);<span class="hljs-comment">//通过递归求出纯左边的最大子序列</span>    maxOfRight=fenzhi(a,center+<span class="hljs-number">1</span>,right);<span class="hljs-comment">//通过递归求出纯右边的最大子序列</span>    maxLeftB=<span class="hljs-number">0</span>;    leftBSum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( i = center; i &gt;= left; i--)    &#123;        leftBSum+=a[i];        <span class="hljs-keyword">if</span> (leftBSum&gt;maxLeftB)        &#123;            maxLeftB=leftBSum;        &#125;    &#125;    maxRightB=<span class="hljs-number">0</span>;    rightBSum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( i = center+<span class="hljs-number">1</span>; i &lt;= right; i++)    &#123;        rightBSum+=a[i];        <span class="hljs-keyword">if</span> (rightBSum&gt;maxRightB)        &#123;            maxRightB=rightBSum;        &#125;    &#125;   <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxOfLeft,maxOfRight,maxRightB+maxLeftB) ;<span class="hljs-comment">//此处需要注意，每次返回的值应该是左边的or右边or中间的最大值，此处的左边右边中间指的是进入此函数的数组a，也是进行二分之后的数组的那部分。</span>&#125;</code></pre><p>分治算法，分而治之。</p><h2 id="分"><a href="#分" class="headerlink" title="分"></a>分</h2><p>将问题分为两个大致相等的子问题</p><h2 id="治"><a href="#治" class="headerlink" title="治"></a>治</h2><p>将两个子问题的解合在一起，附加少量工作，得到答案</p><h2 id="在本问题的表现"><a href="#在本问题的表现" class="headerlink" title="在本问题的表现"></a>在本问题的表现</h2><p>最大子序列只能在输入数据的左边，右边，中间三部分出现。然后左边，右边可以递归求解。中间可以变成特别的左边右边的最大子序列的和。</p><blockquote><p>特别的左边右边子序列指的是，包含左边最后一个元素的子序列，包含右边第一个元素的子序列</p></blockquote><h1 id="线性时间的算法"><a href="#线性时间的算法" class="headerlink" title="线性时间的算法"></a>线性时间的算法</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xianxingjiansuanfa</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,<span class="hljs-built_in">max</span>=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        sum+=a[i];        <span class="hljs-keyword">if</span> (sum&gt;<span class="hljs-built_in">max</span>)        &#123;            <span class="hljs-built_in">max</span>=sum;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&lt;<span class="hljs-number">0</span>)        &#123;            sum=<span class="hljs-number">0</span>;        &#125;                    &#125;    &#125;</code></pre><p>此算法正确性的推导</p><p>一个最大和的子序列，必然不能负数作为开头的，因为负数只会减少和。同时，最大子序列，也不能是由一个负的和的子序列作为开头的。</p><p>假设某个子序列是由负的和的子序列作为开头，则我们删除掉这个开头，得到的是更大的子序列</p><p>通过反证法，得到结果</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第二章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给小小白的python3安装说明</title>
    <link href="/2020/04/27/%E7%BB%99%E5%B0%8F%E5%B0%8F%E7%99%BD%E7%9A%84python3%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/"/>
    <url>/2020/04/27/%E7%BB%99%E5%B0%8F%E5%B0%8F%E7%99%BD%E7%9A%84python3%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>给小小的，白白的，python3包教包会指南。</p><a id="more"></a><h2 id="第一步，开启并且配置wsl"><a href="#第一步，开启并且配置wsl" class="headerlink" title="第一步，开启并且配置wsl"></a>第一步，开启并且配置wsl</h2><h3 id="为什么使用wsl"><a href="#为什么使用wsl" class="headerlink" title="为什么使用wsl"></a>为什么使用wsl</h3><ol><li>自带python3，和git。</li><li>易于解决因为GFW，导致下载速度过慢的bug</li></ol><h3 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h3><ol><li><p>win+q，输入控制面板，</p></li><li><p>打开控制面板，点击程序</p></li><li><p>在程序和功能一栏，可以看见启用或关闭Windows功能，点击它</p></li><li><p>选择适用于Linux的Windows子系统</p></li><li><p>重启电脑</p></li><li><p>win+q，输入应用商店，回车</p></li><li><p>选择Ubuntu，安装</p></li><li><p>win+q，输入wsl，回车。设置基本信息<strong>注意，输入密码是看不见东西是Linux系统的正常现象</strong></p></li></ol><h3 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a>注意！！</h3><p>此时你已经可以使用命令 </p><pre><code class="hljs bash">python3</code></pre><p>来进行python3的学习了，</p><p>若想要退出输入exit(),即可<br>下面的内容是后期调包，安装vscode等操作要用到的</p><h3 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h3><p><em>目的是避免GFW</em></p><p>输入命令</p><pre><code class="hljs bash">sudo vim /etc/apt/sources.list</code></pre><p>然后输入刚刚的密码<br>进入文件后，莫慌。<br>注意自己的输入法是不是在英文模式。<br>不是，就先调成是<br>先观察文件里有没有aliyun的字样<strong>也可以输入gg/aliyun 回车。看有没有选中文字</strong><br>如果有，请跳到下一部分。<br>如果没有，请看下文<br>输入ggdG<strong>注意大小写，用于清空文件</strong><br>之后按esc</p><p>之后复制下面这段文字</p><pre><code class="hljs bash">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>然后在wsl里按‘i’，接着右键，之后 输入<br>之后按esc</p><pre><code class="hljs bash">:wq</code></pre><p>接着输入命令</p><pre><code class="hljs bash">sudo apt-get update</code></pre><h3 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h3><pre><code class="hljs bash">sudo apt-get install code <span class="hljs-comment">#安装VScode</span></code></pre><pre><code class="hljs bash">sudo apt-get install python3-pip <span class="hljs-comment">#安装包管理器</span></code></pre><pre><code class="hljs bash">sudo mkdir ~/.pip<span class="hljs-built_in">cd</span> ~/.pipvim pip.conf</code></pre><p>复制下面内容</p><pre><code class="hljs bsah">[global]index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple[install]trusted-host&#x3D;mirrors.aliyun.com</code></pre><p>在wsl里右键</p><p>然后esc，之后输入</p><pre><code class="hljs bash">:wq</code></pre><p>之后//此步大该可以跳过吧……</p><pre><code class="hljs bash">pip3 install flake8pip3 install yapf</code></pre><p>安装两个插件</p><p>下一步为</p><pre><code class="hljs bash">code</code></pre><p>进入vscode界面后<br>Ctrl+Shift+X</p><p>若界面为汉语，则在搜索栏输入python<br>若为英语，则先zh-CN，安装，再搜索python<br>安装python。</p><p>Ctrl+Shift+E</p><p>新建一个文件夹。<br>然后应该能看到settings.json这个文件，</p><p>输入以下内容</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"python.linting.flake8Enabled"</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">"python.formatting.provider"</span>: <span class="hljs-string">"yapf"</span>,    <span class="hljs-attr">"python.linting.flake8Args"</span>: [<span class="hljs-string">"--max-line-length=248"</span>],    <span class="hljs-attr">"python.linting.pylintEnabled"</span>: <span class="hljs-literal">false</span>&#125;</code></pre><p>然后在 .vscode 文件夹外 <em>也就是你新建的这个文件夹</em>新建一个 .py文件<br>此时python插件会提醒你少几项配置，你选择分别yapf和flake8即可。若跳过了前面的那步，也是选择yapf和flake8，它会自动通过pip下载。如果下载失败……你可以考虑复制他的命令然后改成pip3试试……。</p><p>之后就可以开心写py文件了，代码补全啊，实时纠错也都有了，报错不知道怎么改把鼠标移动上去有错误代码，然后浏览器搜索一下就可以了。<br>Alt+Shift+F是自动格式化代码。</p><p>(ง •_•)ง</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>python3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python3</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
