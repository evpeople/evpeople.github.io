<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法公开课（二）</title>
    <link href="/2020/05/18/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/05/18/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>突然发现，学习STL之后链表的各种C实现就不用费劲写了，只用好好想重点逻辑就好了</p><a id="more"></a><h2 id="分治求解问题"><a href="#分治求解问题" class="headerlink" title="分治求解问题"></a>分治求解问题</h2><p>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p><h2 id="递归求解"><a href="#递归求解" class="headerlink" title="递归求解"></a>递归求解</h2><p>写递归的时候要注意不能自己一个一个桃，就直接定好之后管tm</p><h3 id="例一汉诺塔"><a href="#例一汉诺塔" class="headerlink" title="例一汉诺塔"></a>例一汉诺塔</h3><ol><li>首先三个柱子进行分析</li><li>前n个从A到C<ol><li>则首先前n-1从A到B</li><li>然后第n个从A到C</li><li>最后前n-1个从B到C<ol><li>则（即进入递归）</li></ol></li></ol></li><li>数学表达式 f(n)=2f(n-1)+1</li></ol><h3 id="给出二叉树求前序中序和后序"><a href="#给出二叉树求前序中序和后序" class="headerlink" title="给出二叉树求前序中序和后序"></a>给出二叉树求前序中序和后序</h3><p>二叉树：每个节点最多有两个子树（节点分左右</p><p>满二叉树：除了最后一层无子节点，其他都满了</p><p>完全二叉树，除了最后一层外，每一层均达到最大值，最后一层值缺少右边的若干个</p><p>性质：左=根*2，右=根*2+1,这样的二叉树用数组就能直接存下来</p><p>先序遍历：首先访问根节点，然后遍历左子树，再遍历右子树</p><p>中序：左   根   右  //排序后就像从左往右写</p><p>后序： 左  右   根 </p><p>//以上三个序是考虑根的位置</p><p>层序：从上到下从左往右。</p><p><strong>题目实质</strong> 根据已知信息画出树的全貌</p><p>中序遍历给出从左往右怎么排序</p><p>前序遍历给出那些是根，从而得到树的全貌</p><p><em>已知前序后序，中序不唯一</em></p><p>具体实现的时候，先写出遍历函数，然后递归遍历左子树右子树，输出时先左后右。</p><p><strong><em>作为人类，只需要想一层</em></strong></p><h3 id="归并排序，快速排序"><a href="#归并排序，快速排序" class="headerlink" title="归并排序，快速排序"></a>归并排序，快速排序</h3><h4 id="再谈基数排序"><a href="#再谈基数排序" class="headerlink" title="再谈基数排序"></a>再谈基数排序</h4><p>当我们把桶竖着放的时候，顺序是显然的</p><p>所谓的增加的基数，可以开99个桶，然后塞进去</p><h4 id="初探计数排序"><a href="#初探计数排序" class="headerlink" title="初探计数排序"></a>初探计数排序</h4><p>对桶求前缀和，</p><p>可以轻松知道某个大小的数在第几位</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>待排子区间一分为二，讲子区间排序，然后讲已经排好序的两个序列合并</p><ul><li>怎么合并呢<ul><li>从首位比较，然后放好小的之后，小的那个指针后移，到所在序列的下一项</li></ul></li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>选择一个基准，小于基准放左边，大于基准放右边，然后对左右继续上述操作</p><p>复杂度均为nlog（n）</p><ul><li>每一次为n，然后有log（n）层。</li></ul><h3 id="求一个序列第k大数"><a href="#求一个序列第k大数" class="headerlink" title="求一个序列第k大数"></a>求一个序列第k大数</h3><p>先选一个基准，假设基准右边&lt;=k，则第k大一定在左边，则右边直接丢掉</p><p>复杂度logn，不断二分序列</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h3><p>_Tp min(_Tp a,_Tp b)</p><p>_Tp为模板类，传进去什么传出来什么</p><p>sort（a,a+10）,传进去的是指针，然后是左闭右开的a和a+10，</p><p>对结构体排序</p><ul><li>自定义比较函数，返回bool值，return a.x&lt;b.x; 无等号，</li><li>重定义&lt;运算符</li><li>写在结构体里面</li><li>bool operator &lt; (ty b)</li><li>{</li><li>return     x&lt;b;</li><li>}</li></ul><p>求下一个排列</p><p>把 123 变成 132 213</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>分治and递归&amp;&amp;STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客算法题解（二）</title>
    <link href="/2020/05/17/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/05/17/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>5月17号，补充了第一题的题解，放在了（一）里</p><a id="more"></a>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>鸽子记录</title>
    <link href="/2020/05/16/%E9%B8%BD%E5%AD%90%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/05/16/%E9%B8%BD%E5%AD%90%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>此处目前单纯记载我的鸽（断）子（更）记录</p><a id="more"></a><p>2020年5月16日，周六，被迫断更</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（七）</title>
    <link href="/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>不能咕咕！树的预备知识</p><a id="more"></a><p>树的大部分操作的运行时间平均为O（logN）</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>树的递归定义：由根节点和多个子树构成，每个子树的根都被来自跟集结点的一条有向线段连接。一棵树实际上是N个结点和N-1条边的集合</p><p>名词定义</p><ul><li>root：根，根节点</li><li>edge：边，有向，为连接点的直线</li><li>child：根r的儿子，每一个子树的根叫做根r的儿子</li><li>parent：父亲，r是每一个子树的根的父亲 </li><li>leaf：树叶，没有儿子的节点</li><li>sibling：兄弟，具有相同父亲节点</li><li>grandparent：同上类似定义</li><li>grandchild：同上类似定义</li><li>path：路径，从节点n<del>1</del>到n<del>k</del>的路径定义为节点n<del>1</del>，n<del>2</del>,  n<del>3</del>   …………n<del>k</del>  的一个序列，使得对于1&lt;=i&lt;k，有节点n<del>i</del> 是n<del>i+1</del> 的父亲<ul><li>length：路径的长，edge的个数且=k-1</li></ul></li><li>depth：深度，从根到n<del>i</del>的唯一路径的长</li><li>height：高，节点n<del>i</del> 到一片树叶的最长路径的长，一颗树的高等于其根的高</li><li>ancestor：祖先，存在n<del>1</del> 到n<del>2</del>的一条路径，则n<del>1</del> 为n<del>2</del>的一位祖先</li><li>descendant：后裔，上文中n<del>2</del>为n<del>1</del>的后裔，n<del>1</del>！=n<del>2</del> 的时候为真祖先真后裔</li></ul><h1 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h1><p>假设用一个数据结构，在结构中有指向所有儿子的指针。这样不可行是因为每个节点的儿子的个数未知</p><p><strong>可行的方法</strong>是</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree</span></span><span class="hljs-class"></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> i;ptrToNode firstChild;ptrToNode nextSibling；&#125;</code></pre><p>并不直接连接各个儿子，而是只连接第一个儿子，然后让第一个儿子去找他的兄弟们</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第四章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客算法题解（一）</title>
    <link href="/2020/05/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/05/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>5.15号，第一题的暴力解法，优化过程，出过的错误，以及对拍随机数代码。</p><a id="more"></a><p>题目内容</p><p>/*</p><p><em>链接：<a href="https://ac.nowcoder.com/acm/problem/14583" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/14583</a></em></p><p><em>来源：牛客网</em></p><p><em>从前，有n只萌萌的糖糖，他们分成了两组一起玩游戏。他们会排成一排，第i只糖糖会随机得到一个能力值bi。从第i秒的时候，第i只糖糖就可以消灭掉所有排在他前面的和他不是同一组的且能力值小于他的糖糖。</em></p><p><em>为了使游戏更加有趣，糖糖的爸爸，娇姐，会发功m次，第i次发功的时间为ci，则在第ci秒结束后，b1,b2,…..,bci都会增加1.</em></p><p><em>现在，娇姐想知道在第n秒后，会有多少只糖糖存活下来。</em></p><p><em>*/</em></p><h1 id="我的暴力模拟法"><a href="#我的暴力模拟法" class="headerlink" title="我的暴力模拟法"></a>我的暴力模拟法</h1><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">int</span> T,n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span> (T&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">int</span> temp=n;        temp++;        <span class="hljs-keyword">int</span> t[n];  <span class="hljs-comment">//那一组</span>        <span class="hljs-keyword">int</span> ts[n]; <span class="hljs-comment">//能力值</span>        <span class="hljs-keyword">int</span> fg[m];        <span class="hljs-built_in">memset</span>(t,<span class="hljs-number">0</span>,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));        <span class="hljs-built_in">memset</span>(ts,<span class="hljs-number">0</span>,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));        <span class="hljs-built_in">memset</span>(fg,<span class="hljs-number">0</span>,n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;        n++;        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span>)        &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;t[i], &amp;ts[i]);            i++;            n--;        &#125;        i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (m&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;fg[i]);            i++;            m--;        &#125;        i=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> fgs=<span class="hljs-number">0</span>;<span class="hljs-comment">//发功次数</span>        n=temp;        <span class="hljs-keyword">while</span> (i&lt;n)        &#123;            <span class="hljs-comment">//i为秒数</span>            <span class="hljs-keyword">int</span> temp1=i<span class="hljs-number">-1</span>;            <span class="hljs-keyword">while</span> (temp1&gt;=<span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span> (t[temp1]!=t[i])                &#123;                    ts[temp1]=ts[temp1]&gt;=ts[i]?ts[temp1]:<span class="hljs-number">0</span>;                &#125;                <span class="hljs-comment">//此处必然可以优化</span>                temp1--;            &#125;            <span class="hljs-comment">//以上在消灭灭糖糖</span>            <span class="hljs-comment">//一下是发功</span>            <span class="hljs-comment">//啊啊啊啊，这些本来都该用for循环来着</span>            temp=<span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (i==fg[fgs])            &#123;                <span class="hljs-keyword">while</span> (temp&lt;=i)                &#123;                    <span class="hljs-keyword">if</span> (ts[temp]!=<span class="hljs-number">0</span>)                    &#123;                        ts[temp]++;                    &#125;                                        temp++;                &#125;                fgs++;            &#125;            i++;                    &#125;        <span class="hljs-keyword">int</span> temp1=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (temp1&lt;n)        &#123;            <span class="hljs-keyword">if</span> (ts[temp1]!=<span class="hljs-number">0</span>)            &#123;                ans++;            &#125;            temp1++;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);        T--;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="在写的时候遇见的问题（按照恶心程度排序"><a href="#在写的时候遇见的问题（按照恶心程度排序" class="headerlink" title="在写的时候遇见的问题（按照恶心程度排序"></a>在写的时候遇见的问题（按照恶心程度排序</h2><ol><li>糖糖从1开始而不是从0开始</li><li>相等的时候不杀</li><li>没了</li></ol><p>但是这个debug用了我快1h，还是在有对拍的情况下。</p><p>说到对拍，结尾会附上这道题的对拍随机数代码</p><h2 id="开始挠头想优化"><a href="#开始挠头想优化" class="headerlink" title="开始挠头想优化"></a>开始挠头想优化</h2><h3 id="分析算法的复杂度"><a href="#分析算法的复杂度" class="headerlink" title="分析算法的复杂度"></a>分析算法的复杂度</h3><p>读入数据为n+m</p><p>消灭糖糖为1^2^+2^2^……=n^3^</p><p>给糖糖升级，为n^2^ </p><p>输出结果为n</p><p>题目的数据范围为1&lt;=n&lt;=50000，(5*10^4^ )^2^ =10^9^ ,明显是不可接受的算法</p><p>然后开始做优化。</p><p>当然是从消灭和升级入手</p><p>消灭的</p><pre><code class="hljs plain">while (temp1&gt;&#x3D;0)&#123;    if (t[temp1]!&#x3D;t[i])        &#123;            ts[temp1]&#x3D;ts[temp1]&gt;&#x3D;ts[i]?ts[temp1]:0;            &#125;        temp1--;&#125;</code></pre><p>这部分实际上是在通过一个O（n）的遍历来判断<code>ts[temp1]</code>前面的数据的大小如何。</p><h3 id="思想（并没有按照可行性排序"><a href="#思想（并没有按照可行性排序" class="headerlink" title="思想（并没有按照可行性排序"></a>思想（并没有按照可行性排序</h3><p>二维数组or结构体，不同的组放入不同的数组里，但是被放入的数组中仍保留着自己是第几个元素，这样的话平均，可以少遍历一半的内容,之后陷入僵局</p><h3 id="从另一个角度想（从后往前遍历"><a href="#从另一个角度想（从后往前遍历" class="headerlink" title="从另一个角度想（从后往前遍历"></a>从另一个角度想（从后往前遍历</h3><p>增加战力，实际上不改变第i个人与前面每个人的差值，所以我们先不让人死，同时加完战力</p><blockquote><p>举例:50,1,2,3,4,5,6,7,8,9,20,30,53.</p><p>同时50与后面不同组。在第3秒，第4秒，第5秒……都加了战力</p><p>正常而言，前面都杀不死他，到了53，自然杀不死。</p><p>而假如：50，49，48，47，53.</p><p>能通过加战力使得后面杀不死他的本身就确实是杀不死的，所以这种想法有可行性</p></blockquote><h4 id="分析复杂度"><a href="#分析复杂度" class="headerlink" title="分析复杂度"></a>分析复杂度</h4><p>读入为n+m，添加战力是m*n，然后从后往前比较</p><blockquote><p>如果第<em>i</em>个人的战力小于后面另一个队的最大战力值，则一定会死</p></blockquote><p>假如我可以写出O（1）的算法，知道i，立刻知道后面队的最大战力，就能把复杂度降低为n。</p><p>方法，在读入数据的时候用另一个数组直接存就ok了。</p><p>那这么看，添加战力这玩意好烦，</p><p>再优化。</p><p>所谓添加战力，实际上就是数列修改问题。</p><p>所以用一个数组维护差值，再对差分数组求前缀和就ok了。这样O（1）得到修改后的值。</p><h3 id="总结优化思路"><a href="#总结优化思路" class="headerlink" title="总结优化思路"></a>总结优化思路</h3><p>从后往前遍历最大值，一个数组维护最大值，一个数组求差分，一个数组求前缀后</p><h3 id="c的实现"><a href="#c的实现" class="headerlink" title="c的实现"></a>c的实现</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TANGTANG</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> zu;    <span class="hljs-keyword">int</span> power;    <span class="hljs-keyword">int</span> different;    <span class="hljs-keyword">int</span> sum;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>;    <span class="hljs-comment">//struct TANGTANG *nextDifferentPosition;</span>    <span class="hljs-keyword">int</span> nextDifferentPosition;&#125;tt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span> (T&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n为糖糖的个数，m为发功次数</span>        <span class="hljs-keyword">int</span>  temp;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        n=<span class="hljs-number">5</span>;        m=<span class="hljs-number">4</span>;<span class="hljs-comment">//测试用数据</span>        n++;        tt one[<span class="hljs-number">7</span>];        <span class="hljs-keyword">int</span> *next[n];        temp=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (temp&lt;n)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;one[temp].zu,&amp;one[temp].power);            <span class="hljs-keyword">if</span> (temp&gt;<span class="hljs-number">1</span>)            &#123;                one[temp].different=one[temp].power-one[temp<span class="hljs-number">-1</span>].power;                one[temp].sum=one[temp<span class="hljs-number">-1</span>].sum+one[temp].different;                 &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp==<span class="hljs-number">1</span>)            &#123;                one[temp].different=<span class="hljs-number">0</span>;                one[temp].sum=<span class="hljs-number">0</span>;            &#125;            <span class="hljs-comment">//sum,是在对差分数组求前缀和。此处不能求最大值，因为我要的最大值是从后往前</span>                                            temp++;        &#125;        temp=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-comment">//用于next</span>        <span class="hljs-keyword">int</span> changeNumeber[<span class="hljs-number">500</span>]=&#123;<span class="hljs-number">0</span>&#125;;        next[i]=&amp;changeNumeber[i];        i++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++)        &#123;            changeNumeber[i]=i;            next[i]=&amp;changeNumeber[i];        &#125;                <span class="hljs-keyword">while</span> (temp&lt;n<span class="hljs-number">-1</span>)        &#123;                        <span class="hljs-keyword">if</span> (one[temp].zu==one[temp+<span class="hljs-number">1</span>].zu)            &#123;                one[temp].nextDifferentPosition=*next[i];            &#125;<span class="hljs-keyword">else</span>            &#123;                changeNumeber[i]=temp+<span class="hljs-number">1</span>;                next[i]=&amp;changeNumeber[i];                i++;            &#125;            temp++;                    &#125;                temp=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> addpower[m];        <span class="hljs-keyword">while</span> (temp&lt;m)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;addpower[temp]);            temp++;        &#125;        temp=n;        <span class="hljs-keyword">while</span> (temp&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">if</span> (temp==n)            &#123;                one[temp].<span class="hljs-built_in">max</span>=one[temp].power;            &#125;<span class="hljs-keyword">else</span>            &#123;                one[temp].<span class="hljs-built_in">max</span>=one[temp+<span class="hljs-number">1</span>].<span class="hljs-built_in">max</span>&gt;one[temp].power?one[temp+<span class="hljs-number">1</span>].<span class="hljs-built_in">max</span>:one[temp].power;            &#125;            temp--;        &#125;                                T--;    &#125;    &#125;</code></pre><p>问题：爆空间了，没能处理好怎么加能力，没处理好分组的问题</p><h1 id="大佬的解法与学习"><a href="#大佬的解法与学习" class="headerlink" title="大佬的解法与学习"></a>大佬的解法与学习</h1><p>关于添加能力</p><blockquote><p>有影响的一定是1 - ci1，我们可以维护一个前缀和，Csum[i] 表示第i<em>i</em> 项前面有几次操作，这样做的意义是什么呢，对于Csum[j-1]-Csum[i-1]且j&gt;=i表示位置<em>i</em> 的糖糖比位置<em>j</em>多了几次赋值+1的操作。</p></blockquote><p>关于处理最大值</p><blockquote><p>当且仅当i+1&lt;=j&lt;=n位置存在和糖糖i不是一队且B[i]+Csum[j-1]-Csum[i-1]&lt;B[j]的时候，位置i的糖糖才会被击败，将式子移项即可发现，B[i]-Csum[i-1]&lt;B[j]-Csum[j-1]</p></blockquote><p>也就是比较B-Csum的值</p><p>关于分组</p><blockquote><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--)&#123;    <span class="hljs-keyword">int</span> sum = Max[team[i] ^ <span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span> (sum &lt;= B[i] - Csum[i - <span class="hljs-number">1</span>])        cnt++;    Max[team[i]] = <span class="hljs-built_in">max</span>(Max[team[i]], B[i] - Csum[i - <span class="hljs-number">1</span>]);&#125;</code></pre></blockquote><p>不用考虑分组？？用的倒序遍历，因为找到了要比较的东西。实际上我自己写的内容还没到比较的部分，也没想到再开一个单纯的数组存储最大值，异或1为取反，对每一个zu，直接取反就能得到另外组的最大值</p>]]></content>
    
    
    <categories>
      
      <category>算法题目</category>
      
      <category>牛客</category>
      
      <category>第一次</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法公开课（一）</title>
    <link href="/2020/05/14/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/05/14/%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>内容包括：尺取法，前缀和，差分，贪心</p><a id="more"></a><ol><li>养成写题解的习惯</li><li>存在每日一题，要做，刷题不能手生。</li><li>至少独立思考半小时，不要对着别人的代码</li></ol><h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><h3 id="怎么评价一个算法"><a href="#怎么评价一个算法" class="headerlink" title="怎么评价一个算法"></a>怎么评价一个算法</h3><ol><li>正确性</li><li>可读性</li><li>容错性（不考虑）</li><li>时间复杂度</li><li>空间复杂度</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(1), 常数算法，与输入数据规模无关</p><p>O（logn）</p><p>O（根号n）</p><p>O（n）线性时间复杂度</p><p>将数据大小代入O中的n，得到的结果若10^8^ 级别的则时可以接受的算法，</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>512M 一个int类型的数组，这个数组最大能开到512×1024×1024×8/32 ==10^8^这么大数组，第一个1024时kb，第二个是字节，第三个8是位数，int为32位。得出结果</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ol><li>定义<ol><li>要点：不重复，不遗漏</li><li>一一列举</li></ol></li><li>优化枚举的思路——减少枚举次数<ol><li>选择合适的枚举对象（找人，先枚举班级，然后枚举）</li><li>选择合适的枚举方向（从前往后or从后往前）</li><li>选择合适的数据维护方法（数据结构）</li></ol></li><li>例题</li></ol><h3 id="例题1：最大正方形"><a href="#例题1：最大正方形" class="headerlink" title="例题1：最大正方形"></a>例题1：最大正方形</h3><p><img src="https://i.loli.net/2020/05/14/adi9EWp74lToxFq.png" srcset="/img/loading.gif" alt="image-20200514202949847"></p><ul><li>思考，几个点确定一个正方形：两个点即可，所以可以枚举两个点，然后计算出另外两个坐标，将另外两个点比较是否为‘#’</li></ul><h3 id="例题2：数列求和（前缀和）"><a href="#例题2：数列求和（前缀和）" class="headerlink" title="例题2：数列求和（前缀和）"></a>例题2：数列求和（前缀和）</h3><p><img src="C:%5CUsers%5C%E7%8E%8B%E5%96%86%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200514203431390.png" srcset="/img/loading.gif" alt="image-20200514203431390"></p><ul><li><p>想法：先考虑暴力怎么做。</p></li><li><p>优化</p><ul><li><p>主要时间复杂度瓶颈在哪里？</p></li><li><blockquote><p>每次求和都要遍历区间</p></blockquote></li><li><p>所以可以用sum[i]存储前n个数的和，sum[i]=sum[i-1]+a[i]</p></li><li><p>sum[i]称为<strong>前缀和</strong>，单次查询的复杂度优化为O（1）</p></li><li><p>能够用前缀xx的都要满足一个类似于“sum[i]=sum[i-1]+a[i]”的条件</p></li></ul></li></ul><h3 id="例题3：数列修改问题（差分法）"><a href="#例题3：数列修改问题（差分法）" class="headerlink" title="例题3：数列修改问题（差分法）"></a>例题3：数列修改问题（差分法）</h3><p><img src="https://i.loli.net/2020/05/14/XzaRwjklZ4W9SEI.png" srcset="/img/loading.gif" alt="image-20200514204033460"></p><ul><li><p>优化：</p><ul><li><p>将对区间的修改变为对区间端点的修改（因为时间复杂度来自对区间的遍历）</p><ul><li><p>具体思考：考虑区间加的过程中什么值是区间段点处发生了变化，而区间内没有变化的</p></li><li><blockquote><p>每个数与前面的差值</p></blockquote></li></ul></li><li><p>具体实现为用一个数组维护第i个数和前一个数的差值</p><ul><li>重点：还要再对delta数组做一个前缀和，才能O（1）后得到修改后的值</li></ul></li><li><p>这种方法叫做<strong>差分</strong></p></li></ul></li></ul><h3 id="例题4：校门外的树（离散化操作）"><a href="#例题4：校门外的树（离散化操作）" class="headerlink" title="例题4：校门外的树（离散化操作）"></a>例题4：校门外的树（离散化操作）</h3><p><img src="https://i.loli.net/2020/05/14/1KTVApWtOlPYqBj.png" srcset="/img/loading.gif" alt="image-20200514204627106"></p><ul><li>暴力算法 easy</li><li>计算每个节点被多少区间覆盖了。然后节点为0的个数</li><li>第三种算法：<ul><li>离散化操作</li><li>区间为[1，100],[1000,2000],[5,110].</li><li>并不用开2000大小的数组，而是将上面的数组重新编号，变成连续的数组</li></ul></li></ul><h3 id="例题5类似于最大子序列和（尺取法）"><a href="#例题5类似于最大子序列和（尺取法）" class="headerlink" title="例题5类似于最大子序列和（尺取法）"></a>例题5类似于最大子序列和（尺取法）</h3><p><img src="https://i.loli.net/2020/05/14/XlwgxE4UKp32DbF.png" srcset="/img/loading.gif" alt="image-20200514205604877"></p><ul><li>暴力的算法是n^3^</li><li>用前缀和可以减去求和，变成n^2^</li><li>用和<strong>最大子序列和的算法四</strong>相同的思想，发现<ul><li>用区间和作为尺子，不断地向后平移。</li><li>首先确定一个L，然后得到一个R，当L向后再平移的时候，R必然不能往前移动，只能往后面移动or原地不动</li><li><strong>Two-pointer/尺取法/追逐法</strong></li></ul></li></ul><h3 id="例题6：按灯泡开关"><a href="#例题6：按灯泡开关" class="headerlink" title="例题6：按灯泡开关"></a>例题6：按灯泡开关</h3><p><img src="https://i.loli.net/2020/05/14/JPTXMYO4sEopRWF.png" srcset="/img/loading.gif" alt="image-20200514210645631"></p><ul><li>每个灯只按一次（因为2次恢复原样，3次同1次）</li><li>仔细分析，发现第一列开关怎么按确定后，后面的所有的灯怎么按动已经确定了。因为第二列的开关可以弥补第一列开关的操作，但是最后一列不行。没有再后面一列弥补了。<ul><li>得到，枚举对象应该为第一列的灯的按动方法</li></ul></li><li>计算时间复杂度</li><li>第一列开关按法为2^n^然后再×N×M，</li><li>具体枚举方法，将亮灭看为2进制字符串，然后转化为十进制整数，然后枚举整数</li><li>名字叫<strong>状态压缩</strong></li></ul><h2 id="位运算介绍"><a href="#位运算介绍" class="headerlink" title="位运算介绍"></a>位运算介绍</h2><p>左移右移等价于*/2 </p><p>| 或</p><p>&amp; 与</p><p>~ 取反</p><p>^ 异或 是不是不一样，相同为0，不同为1，可以视为不带进位的加法。异或0，为本身，异或1，为取反</p><p>应该达到的水平，对int进行位运算的时候，眼中只有01串，看为01串，不用管本身是什么。</p><p>去掉二进制最后一位，右移一位</p><p>最后一位加0，左移一位</p><p>最后加一个1，左移一位+1</p><p>最后一位变成1，或1</p><p>最后一位变成0，先或1，再减掉1</p><p>最后一位取反，异或1</p><p>右数第k位变成1，先把1左移k-1位，然后或1</p><p>右数第k位变成0</p><pre><code class="hljs x&(~(1<<(k-1)))```">右数第k位取反&#96;&#96;&#96;x^(1&lt;&lt;(k-1))</code></pre><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>简而言之，每次都选局部最优解</p><p>能够使用贪心算法的问题都能严格证明局部最优解就是全局最优解</p><h3 id="第一题（没听全，应该很简单）"><a href="#第一题（没听全，应该很简单）" class="headerlink" title="第一题（没听全，应该很简单）"></a>第一题（没听全，应该很简单）</h3><p><img src="https://i.loli.net/2020/05/14/JLrp1k2AvK6zysm.png" srcset="/img/loading.gif" alt="image-20200514213918707"></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><img src="https://i.loli.net/2020/05/14/1emXREjvYl4zDTK.png" srcset="/img/loading.gif" alt="image-20200514214126456"></p><p>按照字典序排序。但这个不是正确的  3 31 39. 最大为 39 33 1.对于这种情况的，先连接起来，再比较大小也就是比较331 313的大小。</p><h3 id="第三题-区间覆盖（工作安排）"><a href="#第三题-区间覆盖（工作安排）" class="headerlink" title="第三题 -区间覆盖（工作安排）"></a>第三题 -区间覆盖（工作安排）</h3><p><img src="https://i.loli.net/2020/05/14/5XGu2vfFcbUYNkE.png" srcset="/img/loading.gif" alt="image-20200514214744728"></p><p>贪心策略：选择结束时间尽量早的。</p><p>证明：离散数学课本</p><h3 id="第四题-活动安排"><a href="#第四题-活动安排" class="headerlink" title="第四题 活动安排"></a>第四题 活动安排</h3><p><img src="https://i.loli.net/2020/05/14/cEevu5jfbVBHiJg.png" srcset="/img/loading.gif" alt="image-20200514215441725"></p><p>先取两件事AB</p><p>当A在B前面，求出A的扣分，B 的扣分</p><p>当B在A前面，求出B的扣分，A的扣分</p><p>假设A在B前是最优解，解出要求</p><h3 id="第五题-国王游戏"><a href="#第五题-国王游戏" class="headerlink" title="第五题 国王游戏"></a>第五题 国王游戏</h3><p><img src="https://i.loli.net/2020/05/14/89Oedhx7ZszHQmk.png" srcset="/img/loading.gif" alt="image-20200514220239896"></p><p><img src="https://i.loli.net/2020/05/14/BSyZX4oYTraGmQ5.png" srcset="/img/loading.gif" alt="image-20200514220312802"></p><p>同理，取AB两个人，交换这两个人的顺序不影响结果</p><p>A在B前面，表示出A获得的奖赏①，B获得的奖赏②</p><p>A在B前面，表示出A获得的奖赏③，B获得的奖赏④</p><p>max(①，②)&lt;=max(③，④)</p><p>则 max(③，④)=③，且③&gt;=max(①，②)</p><p>解方程得到贪心的方法。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
      <category>枚举贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（六）</title>
    <link href="/2020/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2020/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>关于栈的其他运用，后缀表达式，函数调用,以及队列ADT</p><a id="more"></a><h1 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h1><h2 id="计算后缀表达式的c实现"><a href="#计算后缀表达式的c实现" class="headerlink" title="计算后缀表达式的c实现"></a>计算后缀表达式的c实现</h2><ul><li><input disabled="" type="checkbox"> 再次待办</li></ul><h2 id="将中缀表达式变为后缀表达式的c实现"><a href="#将中缀表达式变为后缀表达式的c实现" class="headerlink" title="将中缀表达式变为后缀表达式的c实现"></a>将中缀表达式变为后缀表达式的c实现</h2><ul><li><input disabled="" type="checkbox"> 再次待办</li></ul><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>一个奇妙的想法，函数调用类似于平衡符号，因为都是又开放括号（进入函数）封闭括号（return）</p><ul><li>栈溢出为什么会无法调试，程序崩溃。因为栈的信息被冲毁了，返回地址凉凉了，找不到了。</li></ul><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>定义：最后一行的递归调用，可以通过将递归调用变成goto语句并且在其前方加上对函数每个参数的赋值语句而手动消除</p><p class="note note-waring">不要这么做，编译器会帮你这么优化的# 队列ADT<p>没什么好说的</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（五）</title>
    <link href="/2020/05/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2020/05/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天啊，今天是奋力不咕咕的一天,虽然创建文档的时间是晚上十一点，但真正开始动笔已经是第二天0点12分了。今天的内容，关于栈。</p><a id="more"></a><h1 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h1><p>进栈，出栈。是后进先出的ADT</p><ul><li>一个特性：<strong>唯一可见元素是首元素</strong></li></ul><h1 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h1><p>栈这种结构本身是一个表，所以数组，链表（指针），都可以用于实现栈。一个是顺序，一个非顺序</p><p class="note note-warning"> 对于栈来说，顺序or非顺序存储，没有区别，但是数组的栈的总大小是确定的 </p><p>具体的c代码实现……再次列入待办事项中</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>栈的各种操作都是常数时间，但是栈超出界限的时候，就会程序崩溃，所以仔细检查是有必要的。</p><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="符号配对"><a href="#符号配对" class="headerlink" title="符号配对"></a>符号配对</h2><p>检测是否每个 “{” ，都有对应的 “}”，同时我联想到，/* 与 */ 也可这样判定。只用将两个符号组成的结构体压入栈中，并且处理好前进后退</p><h3 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h3><p>自然语言实现</p><p>做一个空栈，读入字符直到文件末尾，读入的过程是这样的，从首字符开始，读入栈中，做判断，判断是保留还是弹出。</p><p>更实际的描述为开放的符号比如  <em>(、{、[、</em> ，push到栈里，如果字符为封闭字符 <em>）、}、]</em> ，且为空栈，则报错。若非空栈，则pop出栈里面的这个开放字符，跟封闭符号进行比较。若不配对，报错。当读到文件尾巴时，若非空栈，仍报错。</p><p class="note note-warning">栈中只有开放符号！<p>c语言实现</p><p class="note note-primary">进入待办事项吃灰吧</p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>待办事项们</title>
    <link href="/2020/05/12/%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%E4%BB%AC/"/>
    <url>/2020/05/12/%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%E4%BB%AC/</url>
    
    <content type="html"><![CDATA[<p>我期待的事情，等待||正在发生</p><a id="more"></a><ul><li><input disabled="" type="checkbox"> 多项式的链表实现</li></ul><ul><li><input disabled="" type="checkbox"> 基数排序的链表实现</li></ul><ul><li><input disabled="" type="checkbox"> 多重表的链表实现</li><li><input disabled="" type="checkbox"> 栈的c语言实现，包括链表和数组</li><li><input disabled="" type="checkbox"> 算法第一题优化后的c实现</li><li><input disabled="" type="checkbox"> 后缀表达式的c实现</li><li><input disabled="" type="checkbox"> 中缀表达式变为后缀表达式</li><li><input checked="" disabled="" type="checkbox"> 牛客题目</li></ul><hr><p>备忘的一些写法</p><pre><code class="hljs markdown">&#123;% cb text, checked?, incline? %&#125;//默认后面就直接换行</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"label label-primary"</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"note note-primary"</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>/*可选的有primarysecondarysuccessdangerwarninginfolight*/</code></pre>]]></content>
    
    
    <categories>
      
      <category>我期待的</category>
      
    </categories>
    
    
    <tags>
      
      <tag>待办事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（四）</title>
    <link href="/2020/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2020/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第四天学习的内容，实现桶排序，看了多重表，跳过游标实现链表</p><a id="more"></a><h1 id="关于桶排序"><a href="#关于桶排序" class="headerlink" title="关于桶排序"></a>关于桶排序</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bucketsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> count)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//桶排序，空间占用极大</span>    <span class="hljs-keyword">int</span> b[count];    <span class="hljs-keyword">int</span> count2;<span class="hljs-comment">//此为整数的个数</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;count2);    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,count*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count2; i++)    &#123;        <span class="hljs-keyword">int</span> temp;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;temp);        b[temp]+=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> t = <span class="hljs-number">0</span>; t &lt; b[i]; t++)        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,i);<span class="hljs-comment">//i就是temp，b[i]的值为有多少个temp</span>        &#125;    &#125;&#125;</code></pre><p>对于桶排序，我认为最好的方式是读入的同时就往桶里塞，这样有两个好处</p><ol><li>减小空间占用</li><li>减少读入数组的时间</li></ol><p>需要注意的是memset函数的最后一项参数，要有sizeof（int），因为memset的原理是把指定的空间变成指定值，这个空间需要我们自己来算。</p><h2 id="桶排序的问题"><a href="#桶排序的问题" class="headerlink" title="桶排序的问题"></a>桶排序的问题</h2><p>占用空间大，桶排序的桶的个数是由待排序数组的最大项决定的，也就是说即便是给0，1，99这样的三个数排序，也需要构建99个桶，这是无法忍受的。</p><blockquote><p>每种算法都有适合自己发光发热的地方，比如稠密的多项式用数组实现就很好，稠密的待排序序列用桶也很好。</p><p>比如对单词进行排序<del>然而我们直接有strcmp</del></p></blockquote><h2 id="桶排序的时间复杂度"><a href="#桶排序的时间复杂度" class="headerlink" title="桶排序的时间复杂度"></a>桶排序的时间复杂度</h2><p>O（M+N），M为整数的范围，N为整数的个数，</p><p>证明：N为填入桶中用的时间，下面的两重循环的值最大超不过M，超不过整数的范围</p><p class="note note-warning">    暂时存疑</p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>目前对于基数排序，我做到是基本理解其过程，但是还没有想到怎么用链表实现。</p><p>基数排序从最低位开始，填入基数个桶中。也就是说我们需要将待排序的数拆分成好几个基构成的。</p><p>比如十进制的数，天然以10为基，所以先按照个位填入桶中，然后，再按照十位填入桶中，填入桶的顺序是刚刚按照个位填入桶的顺序。</p><p><strong>举例子</strong> </p><p>​            512 216 第二次都应该投入1这个桶中，按照什么顺序投入呢，因为2&lt;6 所以先投入512，再投入216</p><p><strong>具体使用</strong></p><p>​            三十二位计算机，2<sup>11</sup> 个桶，给该计算机能表示的所有整数排序，最多三趟就能排完。 先按照前11位，再中间，最后结尾11位</p><div class="note note-success">            <p>暂时存疑too. </p>          </div><p><strong>代码实现</strong> </p><p>​            还存在一丢丢困难</p><p>​            放入代办中吧先。</p><h1 id="多重表"><a href="#多重表" class="headerlink" title="多重表"></a>多重表</h1><p>没什么好说的，非常奇技淫巧，同样期待着我的代码实现</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机械波</title>
    <link href="/2020/05/12/%E6%9C%BA%E6%A2%B0%E6%B3%A2/"/>
    <url>/2020/05/12/%E6%9C%BA%E6%A2%B0%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<p>关于波动的笔记</p><a id="more"></a><h1 id="机械波"><a href="#机械波" class="headerlink" title="机械波"></a>机械波</h1><h2 id="波的分类与描述"><a href="#波的分类与描述" class="headerlink" title="波的分类与描述"></a>波的分类与描述</h2><h3 id="波动现象"><a href="#波动现象" class="headerlink" title="波动现象"></a>波动现象</h3><ul><li>机械波，需介质</li><li>电磁波，真空</li><li>物质波，微观粒子的波粒二象性</li><li>引力波，时空结构的扰动的传播</li></ul><p><strong>另一种分类方法</strong></p><ul><li>横波，振动方向与传播方向垂直，有偏振（不学），波峰波谷，为振动相位为0orΠ</li><li>纵波，振动方向与传播方向平行，疏部，密部，振动相位为 Π/2</li></ul><h3 id="描述波动的物理量"><a href="#描述波动的物理量" class="headerlink" title="描述波动的物理量"></a>描述波动的物理量</h3><ul><li>波速u，取决于媒质性质and波的类型，</li><li>波长λ</li><li>周期T，向前传播一个波长所需时间，等于振动的周期，只与振动源有关</li></ul><h3 id="波的几何描述"><a href="#波的几何描述" class="headerlink" title="波的几何描述"></a>波的几何描述</h3><ul><li>波面： 任一时刻相位相同的点组成的面，又称为<strong>同向面</strong></li><li>波前：某一时刻传到最前面的波面</li><li>波线：指向波传播方向的有向线段，（在各向同性介质中）垂直于波面</li></ul><h3 id="波的分类"><a href="#波的分类" class="headerlink" title="波的分类"></a>波的分类</h3><h4 id="振动方向"><a href="#振动方向" class="headerlink" title="振动方向"></a>振动方向</h4><p>横波纵波</p><h4 id="波面形状"><a href="#波面形状" class="headerlink" title="波面形状"></a>波面形状</h4><p>平面波 面源</p><p>柱面波 线源</p><p>球面波 点源</p><h4 id="持续时间"><a href="#持续时间" class="headerlink" title="持续时间"></a>持续时间</h4><p>脉冲波</p><p>连续波</p><h4 id="是否传播"><a href="#是否传播" class="headerlink" title="是否传播"></a>是否传播</h4><p>行波</p><p>驻波</p><h4 id="复杂程度"><a href="#复杂程度" class="headerlink" title="复杂程度"></a>复杂程度</h4><p>简谐波</p><p>复波</p><h2 id="简谐波的波函数（重点）"><a href="#简谐波的波函数（重点）" class="headerlink" title="简谐波的波函数（重点）"></a>简谐波的波函数（重点）</h2><ul><li>简谐波：简谐振动传播形成的波，只有单一的频率，是单色波</li><li>右行波：往右边跑的波，对t求导后，振动速度，再次求导是加速度</li><li>角波数k=2Π/λ：2Π长度内所含波长个数</li></ul><p><img src="https://i.loli.net/2020/05/12/k9OMhZKS8Ado2av.png" srcset="/img/loading.gif" alt="image-20200512180122861"></p><p>注意u=λ/T  u=w/k</p><blockquote><p>当向右为x正向时，左行为加，右行为减</p></blockquote><p><img src="https://i.loli.net/2020/05/12/oqk9fbT2cmWdXih.png" srcset="/img/loading.gif" alt="image-20200512181229394"></p><p>在t<del>0</del> 时刻，相位差φ<del>1</del> -φ<del>2</del> 体现为路程差就是k（x<del>2</del> -x<del>1</del> ）</p><ul><li>波函数的时间空间双重周期性</li><li>波动微分方程，任何物理量与坐标，时间的关系满足波动方程，就是以波的形式传播 </li></ul><h2 id="波的能量与能流"><a href="#波的能量与能流" class="headerlink" title="波的能量与能流"></a>波的能量与能流</h2><h3 id="波的能量及能量密度"><a href="#波的能量及能量密度" class="headerlink" title="波的能量及能量密度"></a>波的能量及能量密度</h3><p>使用微元法 </p><ul><li>计算一通，得到结论，光强和势能平方正比</li><li><img src="https://i.loli.net/2020/05/15/kSWLsfpT47qgAub.png" srcset="/img/loading.gif" alt="image-20200515133029949"></li><li>首先固定X，考察动能密度，势能密度随时间的变化<ul><li>随时间同相位变化</li><li>同时最大，同时最小，没有转化</li><li>随时间变化，能量不守恒</li></ul></li><li>固定t<ul><li>y=0时，动能密度，势能密度最大</li><li>y最大的时候，都为0 </li></ul></li></ul><blockquote><p>对于振动，振动本身是孤立的振子，而波这里是各个质元相互作用，振动的势能只取决于弹簧形变量，而波这里取决于各个质元之间作用的情况。看作橡皮筋</p></blockquote><p>能量是一包一包的传播</p><h3 id="能流密度，波的强度"><a href="#能流密度，波的强度" class="headerlink" title="能流密度，波的强度"></a>能流密度，波的强度</h3><ul><li><p>能流（能通量）标量</p><ul><li>定义：单位时间内垂直通过S面的能量</li><li>用能量/Δt</li><li>P=wus<ul><li>w是能量密度</li><li>u是波速</li><li>s是横截面积大小</li></ul></li></ul></li><li><p>能流密度，矢量</p><ul><li>定义：单位时间内垂直通过单位面积的能量</li><li>P/s=wu</li></ul></li><li><p>平均能流密度（波的强度）矢量</p><ul><li>能流密度的时间平均值</li><li>对于任意简谐波，波的强度与振幅平方正比</li><li>在同性介质中，方向与波速方向相同</li></ul></li><li><p>介质的特性阻抗</p><ul><li><p>Z=ρu，反映介质的特性</p></li><li><p>两介质比较，Z小叫波疏介质</p></li><li><blockquote><p>对于光波，折射率小叫光疏介质——光速大</p></blockquote></li></ul></li></ul><h3 id="柱面波与球面波的波函数"><a href="#柱面波与球面波的波函数" class="headerlink" title="柱面波与球面波的波函数"></a>柱面波与球面波的波函数</h3><p>振幅会减小，但不是因为能量少了，而是因为能量分布的更散了</p><h2 id="惠更斯原理（了解）"><a href="#惠更斯原理（了解）" class="headerlink" title="惠更斯原理（了解）"></a>惠更斯原理（了解）</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>用惠更斯作图法定性处理波的传播方向</p><p>把波前的每一点看作发射子波的波源</p><ul><li>不足 ，不能说明为什么指向前传播</li><li>不能解释强度问题，不能解释干涉</li></ul><h3 id="用惠更斯作图法导出光的折射定律"><a href="#用惠更斯作图法导出光的折射定律" class="headerlink" title="用惠更斯作图法导出光的折射定律"></a>用惠更斯作图法导出光的折射定律</h3><h2 id="波的叠加与干涉"><a href="#波的叠加与干涉" class="headerlink" title="波的叠加与干涉"></a>波的叠加与干涉</h2><h3 id="波的叠加原理"><a href="#波的叠加原理" class="headerlink" title="波的叠加原理"></a>波的叠加原理</h3><ul><li>几列波可以保持各自的特点，同时通过同一介质并且不改变自身</li></ul><h3 id="波的干涉"><a href="#波的干涉" class="headerlink" title="波的干涉"></a>波的干涉</h3><ul><li>在空间出现稳定的正东加强和减弱的分布</li><li>相干条件<ul><li>频率相同</li><li>振动方向相同（比如都上下振来振去）</li><li>有固定的相位差</li></ul></li><li>相干波：能产生干涉的两列波</li><li>相干波源：相干波的波源</li><li>相长和相消</li></ul><p>相长的条件 相位差2nΠ</p><p>相消 （2n+1）Π</p><p>初相位相同的时Δφ=2Π/λ  × 波程差    即</p><p><img src="https://i.loli.net/2020/05/15/oiBzxV2AglukypO.png" srcset="/img/loading.gif" alt="image-20200515144148146"></p><p> 相长为波程差的整数倍</p><p>相消为半波程差的奇数倍</p><h2 id="驻波（重点）"><a href="#驻波（重点）" class="headerlink" title="驻波（重点）"></a>驻波（重点）</h2>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
      <category>振动与波动</category>
      
      <category>机械波</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理科</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于项目的思考，包括计算器和雏燕</title>
    <link href="/2020/05/12/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E5%92%8C%E9%9B%8F%E7%87%95/"/>
    <url>/2020/05/12/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E5%92%8C%E9%9B%8F%E7%87%95/</url>
    
    <content type="html"><![CDATA[<p>闲下来的（大学英语课上），早就想写的关于项目的策划</p><a id="more"></a><h1 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h1><h2 id="首先要做的"><a href="#首先要做的" class="headerlink" title="首先要做的"></a>首先要做的</h2><p>手绘出GUI，然后使用tkinter或者其他的python图形化的库，绘制好按钮，安排好按钮的位置，也就是在视觉上实现GUI</p><blockquote><p>这是较为轻松的操作，但是wsl不好操作，还是需要图形化的系统才能简单实现………………比如Windows下………………因为黑框框的wsl跟GUI天然不兼容…………虽然能够通过pip3经过一系列操作安装上tkinter库，但是…………难以调出GUI…………</p></blockquote><h2 id="然后要做的"><a href="#然后要做的" class="headerlink" title="然后要做的"></a>然后要做的</h2><p>给每一个按钮写自己的方法。此处分工完成就好了。<strong><em>感觉应该同时包括把结果输出在屏幕上。</em></strong></p><p>难点：大量数据的计算必然要用的算法，人类直觉想到的算法一般时间复杂度为O（n^3），或者n^2，复杂度极高，<del>甚至满足不了也不是不能用</del>，所以需要善用搜素引擎，寻找诸如求幂，排序等的快速算法，快排啊，快速幂啊什么的。当然，python中也是有已经实现好了的算法库的。可以用pip3 install 库名 来安装</p><h2 id="最后要做的"><a href="#最后要做的" class="headerlink" title="最后要做的"></a>最后要做的</h2><p>封装成一般用户可以使用的样子</p><p>此处内容在书中的第十八章程序打包有相关的描述</p><h1 id="我的雏燕计划"><a href="#我的雏燕计划" class="headerlink" title="我的雏燕计划"></a>我的雏燕计划</h1><p>按照相同的处理思想，模块化的来写。</p><h2 id="先写出底部三个页面的接口，然后写三个页面的内容"><a href="#先写出底部三个页面的接口，然后写三个页面的内容" class="headerlink" title="先写出底部三个页面的接口，然后写三个页面的内容"></a>先写出底部三个页面的接口，然后写三个页面的内容</h2><h3 id="正经的写法"><a href="#正经的写法" class="headerlink" title="正经的写法"></a>正经的写法</h3><p>学习html，css，xml等内容，or 读微信开发者文档，强行上手，</p><p>我们的目标是，只写出按钮，并不实现按下按钮后能够做什么</p><h3 id="不正经的写法"><a href="#不正经的写法" class="headerlink" title="不正经的写法"></a>不正经的写法</h3><p>直接PS绘制出图形然后直接html 用img标签放进去就完事</p><h2 id="结束了……"><a href="#结束了……" class="headerlink" title="结束了……"></a>结束了……</h2><p>反正暂缓结题了，就在学习算法数据结构之余，随便写写得了</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>项目策划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（三）</title>
    <link href="/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第三天学习的内容，链表的复习，多项式ADT</p><a id="more"></a><h1 id="需要注意的内容"><a href="#需要注意的内容" class="headerlink" title="需要注意的内容"></a>需要注意的内容</h1><ol><li>声明指向一个结构体的指针并不能创造该结构体，只是给了足够的空间来容纳该指针。所以必须要malloc</li><li>而对于free而言，free之后，指针指向的地址没变，但是此处的内容已经无意义了，不再受到保护，随时都会发现值被改变</li><li>malloc的sizeof应该是结构体的大小，而不是指针的大小</li><li>对于删除操作，删除前应该先记下下一个节点的位置</li></ol><h1 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h1><h2 id="多项式ADT"><a href="#多项式ADT" class="headerlink" title="多项式ADT"></a>多项式ADT</h2><p><strong><em>多项式可以用于实现大整数的四则运算</em></strong></p><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> coedffArray[maxDegree+<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> highPower;&#125;  * polynomial;</code></pre><p>在数组中存储多项式各项的系数，然后进行加减乘除即可</p><p>其中maxDegree是已知的多项式可能存在的最大的次数，而highPower为目前一个特定多项式的最大项的次数。</p><h4 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h4><p>这样对多项式做加减法之前，先将数组赋值为0之后再给每一个特定的多项式赋值。然后进行加减的途中先比较最大项那个更大一些。然后加减</p><h4 id="乘除"><a href="#乘除" class="headerlink" title="乘除"></a>乘除</h4><p>乘除法需要注意</p><ol><li>是否超过了可能存在的最大次数</li><li>乘除认为做了分配律，第一个多项式的每一项 ÷ || ×  第二个多项式，具体的实现就是两个套着的循环</li></ol><h4 id="数组实现的问题"><a href="#数组实现的问题" class="headerlink" title="数组实现的问题"></a>数组实现的问题</h4><p>对于稠密的多项式，数组非常ok，但是对于不稠密的，大量的时间用在了乘0，效率极低。</p><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><ul><li><input disabled="" type="checkbox"> 等待之后几天做练习题的时候再实现</li></ul><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="前提：桶排序"><a href="#前提：桶排序" class="headerlink" title="前提：桶排序"></a>前提：桶排序</h3><ul><li><input disabled="" type="checkbox"> 等待实现的数组桶排序</li><li><input disabled="" type="checkbox"> 等待实现的基数排序</li></ul><h2 id="多重表"><a href="#多重表" class="headerlink" title="多重表"></a>多重表</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第三章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（二）</title>
    <link href="/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第二天学习的内容，关于欧几里得算法求最大公因数，以及快速幂</p><a id="more"></a><h1 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m ,<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> rem;    <span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>)    &#123;        rem=m%n;        m=n;        n=rem;    &#125;    <span class="hljs-keyword">return</span> m;&#125;</code></pre><p>称之为辗转相除法也可。时间复杂度为logn</p><p>通过定理</p><blockquote><p>如果M&gt;N,则M mod N &lt; M/2</p><p>分两种情况证明</p></blockquote><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qiumi</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//复杂度为log（n）</span>    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">if</span> (n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">//偶数</span>    &#123;        <span class="hljs-keyword">return</span> qiumi(x*x,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//求x方的n/2次幂。然后x的四次方的n/4次幂，以此类推，得到x的n次幂。</span>    &#125;<span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> qiumi(x*x,(n)/<span class="hljs-number">2</span>)*x;    &#125;&#125;</code></pre><p>时间复杂度为 logn</p><p>一般的循环做法时间复杂度为n</p><p>求2^10次方，可以变为2^5 *2 ^5 </p><p>然后2^5 可以为2 ^2 *2^2 *2</p><p>也就是先计算2×2，然后 4×4×2，然后32×32，总共四次乘法</p><p>然后写递推的思路，求x^n，若n为偶数，则先求 x^(n/2) ，然后对其 平方。</p><p>然后如果n为奇数，则求x的n-1次方，再乘x</p><p>下面按照此思路再写一遍代码</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kuaisumi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b==<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> kuaisumi(a,n/<span class="hljs-number">2</span>)*kuaisumi(a,n/<span class="hljs-number">2</span>);    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> kuaisumi(a,n<span class="hljs-number">-1</span>)*a;&#125;</code></pre><p>我们发现第六行与正确答案不一样，我们应该用正确答案的写法。</p><p>因为</p><pre><code class="hljs c">kuaisumi(a,n/<span class="hljs-number">2</span>)*kuaisumi(a,n/<span class="hljs-number">2</span>);</code></pre><p>会造成调用两个递归，而不是一个递归。影响效率</p><h1 id="明天的学习目标"><a href="#明天的学习目标" class="headerlink" title="明天的学习目标"></a>明天的学习目标</h1><p>学习完3.1，3.2</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第二章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（一）</title>
    <link href="/2020/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第一天学习的内容，关于最大子序列的和四种算法</p><a id="more"></a><h1 id="一般能想到的算法"><a href="#一般能想到的算法" class="headerlink" title="一般能想到的算法"></a>一般能想到的算法</h1><h2 id="O（n-3）的算法"><a href="#O（n-3）的算法" class="headerlink" title="O（n^3）的算法"></a>O（n^3）的算法</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nOfCubed</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *a*[],<span class="hljs-keyword">int</span> *n*)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  *<span class="hljs-comment">//从第0项开始加，0，01，012，0123，012……n，1，12，123，这样遍历*</span>  <span class="hljs-keyword">int</span> sum,maxsum,j,k;  maxsum=<span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  &#123;​    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> t = i; t &lt; n; t++)​    &#123;​      sum=<span class="hljs-number">0</span>;​      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> k = i; k &lt;=t; k++)​      &#123;​        sum+=a[k];​      &#125;​      <span class="hljs-keyword">if</span> (sum&gt;maxsum)​      &#123;​        maxsum=sum;​      &#125;​      ​      ​    &#125;​      &#125;  <span class="hljs-keyword">return</span> maxsum;  &#125;</code></pre><h2 id="O（n-2）的算法"><a href="#O（n-2）的算法" class="headerlink" title="O（n^2）的算法"></a>O（n^2）的算法</h2><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//0然后比较，01，比较，0123，比较，也就是在一次循环中同时做了加和比较两件事情，使得立方运行时间变成了平方</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  sum,<span class="hljs-built_in">max</span>;    <span class="hljs-built_in">max</span>=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> t = i; t &lt; n; t++)        &#123;            sum+=a[t];            <span class="hljs-keyword">if</span> (sum&gt;<span class="hljs-built_in">max</span>)            &#123;                <span class="hljs-built_in">max</span>=sum;            &#125;                &#125;            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;   &#125;</code></pre><h2 id="n-2与n-3-算法的区别"><a href="#n-2与n-3-算法的区别" class="headerlink" title="n^2与n^3 算法的区别"></a>n^2与n^3 算法的区别</h2><p>对于n^3的算法，每次计算子序列的和需要重新从首项开始加，耗费了大量时间，所以在n^2的算法里，我们在每一次求出和之后立马进行比较，少了一次从首项开始加，从而成功减小时间复杂度。</p><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fenzhi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> maxOfLeft=<span class="hljs-number">0</span>,maxOfRight=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxLeftB=<span class="hljs-number">0</span>,maxRightB=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> leftBSum=<span class="hljs-number">0</span>,rightBSum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> center=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;    <span class="hljs-comment">//下面为基准情形，用于退出递归</span>    <span class="hljs-keyword">if</span> (left==right)    &#123;        <span class="hljs-keyword">if</span> (a[left])        &#123;            <span class="hljs-keyword">return</span> a[left];        &#125;<span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    center=(left+right)/<span class="hljs-number">2</span>;    maxOfLeft=fenzhi(a,left,center);<span class="hljs-comment">//通过递归求出纯左边的最大子序列</span>    maxOfRight=fenzhi(a,center+<span class="hljs-number">1</span>,right);<span class="hljs-comment">//通过递归求出纯右边的最大子序列</span>    maxLeftB=<span class="hljs-number">0</span>;    leftBSum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( i = center; i &gt;= left; i--)    &#123;        leftBSum+=a[i];        <span class="hljs-keyword">if</span> (leftBSum&gt;maxLeftB)        &#123;            maxLeftB=leftBSum;        &#125;    &#125;    maxRightB=<span class="hljs-number">0</span>;    rightBSum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( i = center+<span class="hljs-number">1</span>; i &lt;= right; i++)    &#123;        rightBSum+=a[i];        <span class="hljs-keyword">if</span> (rightBSum&gt;maxRightB)        &#123;            maxRightB=rightBSum;        &#125;    &#125;   <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxOfLeft,maxOfRight,maxRightB+maxLeftB) ;<span class="hljs-comment">//此处需要注意，每次返回的值应该是左边的or右边or中间的最大值，此处的左边右边中间指的是进入此函数的数组a，也是进行二分之后的数组的那部分。</span>&#125;</code></pre><p>分治算法，分而治之。</p><h2 id="分"><a href="#分" class="headerlink" title="分"></a>分</h2><p>将问题分为两个大致相等的子问题</p><h2 id="治"><a href="#治" class="headerlink" title="治"></a>治</h2><p>将两个子问题的解合在一起，附加少量工作，得到答案</p><h2 id="在本问题的表现"><a href="#在本问题的表现" class="headerlink" title="在本问题的表现"></a>在本问题的表现</h2><p>最大子序列只能在输入数据的左边，右边，中间三部分出现。然后左边，右边可以递归求解。中间可以变成特别的左边右边的最大子序列的和。</p><blockquote><p>特别的左边右边子序列指的是，包含左边最后一个元素的子序列，包含右边第一个元素的子序列</p></blockquote><h1 id="线性时间的算法"><a href="#线性时间的算法" class="headerlink" title="线性时间的算法"></a>线性时间的算法</h1><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xianxingjiansuanfa</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,<span class="hljs-built_in">max</span>=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        sum+=a[i];        <span class="hljs-keyword">if</span> (sum&gt;<span class="hljs-built_in">max</span>)        &#123;            <span class="hljs-built_in">max</span>=sum;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&lt;<span class="hljs-number">0</span>)        &#123;            sum=<span class="hljs-number">0</span>;        &#125;                    &#125;    &#125;</code></pre><p>此算法正确性的推导</p><p>一个最大和的子序列，必然不能负数作为开头的，因为负数只会减少和。同时，最大子序列，也不能是由一个负的和的子序列作为开头的。</p><p>假设某个子序列是由负的和的子序列作为开头，则我们删除掉这个开头，得到的是更大的子序列</p><p>通过反证法，得到结果</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>第二章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电磁</title>
    <link href="/2020/05/08/%E7%94%B5%E7%A3%81/"/>
    <url>/2020/05/08/%E7%94%B5%E7%A3%81/</url>
    
    <content type="html"><![CDATA[<p>关于电磁学的笔记</p><a id="more"></a><h1 id="圆盘"><a href="#圆盘" class="headerlink" title="圆盘"></a>圆盘</h1><h2 id="半径超大，无限大薄板"><a href="#半径超大，无限大薄板" class="headerlink" title="半径超大，无限大薄板"></a>半径超大，无限大薄板</h2><p>E=σ/2ε0</p><h1 id="平行板电容器"><a href="#平行板电容器" class="headerlink" title="平行板电容器"></a>平行板电容器</h1><p>两板间，E=σ/ε0<br>两版外场强，为0</p><h1 id="带电厚板"><a href="#带电厚板" class="headerlink" title="带电厚板"></a>带电厚板</h1><p>处理方法，切片后积分</p><p>板外  ρe/2ε0<br>板内 不匀强</p><h1 id="补偿法"><a href="#补偿法" class="headerlink" title="补偿法"></a>补偿法</h1><p>具体表述，大减小。</p><h1 id="叠加原理"><a href="#叠加原理" class="headerlink" title="叠加原理"></a>叠加原理</h1><p>点电荷 圆环 圆盘 大平板<br>点电荷 圆环 球面 球体<br>点电荷 直导线 柱面 柱体<br>点电荷 直导线 大平面</p><h1 id="理想模型"><a href="#理想模型" class="headerlink" title="理想模型"></a>理想模型</h1><p>点电荷<br>电偶极子<br>无限长直线<br>无限大平面</p><h1 id="电通量-高斯定理"><a href="#电通量-高斯定理" class="headerlink" title="电通量 高斯定理"></a>电通量 高斯定理</h1><p>有对称性<br>第二种计算场强的办法</p><h2 id="电通量"><a href="#电通量" class="headerlink" title="电通量"></a>电通量</h2><h3 id="电场线"><a href="#电场线" class="headerlink" title="电场线"></a>电场线</h3><p>切线方向是场强方向<br>疏密是大小<br>不能相交<br>不会在没有电荷的地方中断</p><h4 id="电场线密度"><a href="#电场线密度" class="headerlink" title="电场线密度"></a>电场线密度</h4><p>穿过垂直于电场线的面积元的条数/面积，反应电场线疏密程度，反应场强大小。</p><h4 id="静电场电场线"><a href="#静电场电场线" class="headerlink" title="静电场电场线"></a>静电场电场线</h4><p>有头有尾，起始于正，终结于负.</p><h3 id="电场强度通量"><a href="#电场强度通量" class="headerlink" title="电场强度通量"></a>电场强度通量</h3><p>面积矢量，大小是面积，方向是法向<br>Φ=E·S。</p><p>Φ为标量，有正负。</p><h4 id="非均匀电场的电通量"><a href="#非均匀电场的电通量" class="headerlink" title="非均匀电场的电通量"></a>非均匀电场的电通量</h4><p>dΦ=E·dS</p><p>非闭合曲面方向自选<br>闭合曲面方向，外法线方向为正。<br>穿入为负，穿出为正。</p><p>穿过闭合曲面体的电通量为0.</p><blockquote><p><em>穿过闭合曲面的电通量，等于该曲面所包围的电荷代数和除以ε。与曲面外电荷无关，当写成 EdS的时候，E是由所有电荷产生的场强，是面上的场强</em></p></blockquote><p>上为静电场的高斯定理。</p><blockquote><p>Φ为0，但E不一定为0.<br>Φ&gt;0,有净传出，内部有正电荷。<br>Φ&lt;0，有净传入，内部有负电荷。</p></blockquote><h4 id="高斯定理的导出"><a href="#高斯定理的导出" class="headerlink" title="高斯定理的导出"></a>高斯定理的导出</h4><p>库仑定律+场强叠加原理。</p><ul><li>单个点电荷<br>q在球心处。<br>Φ=q/ε</li><li>点电荷系</li><li>连续分布的源电荷</li></ul><h4 id="高斯定理的应用"><a href="#高斯定理的应用" class="headerlink" title="高斯定理的应用"></a>高斯定理的应用</h4><h5 id="计算带电体周围的电场强度"><a href="#计算带电体周围的电场强度" class="headerlink" title="计算带电体周围的电场强度"></a>计算带电体周围的电场强度</h5><p>选取适当高斯面</p><blockquote><p>适当高斯面一号：高斯面上各面元的法线方向与场强方向平行，且E的大小处处相等。</p></blockquote><p>此时Φ=ES</p><blockquote><p>适当高斯面二号：部分垂直，部分平行且大小处处相等。</p></blockquote><p>此时Φ=ES平行</p><p><strong><em>有对称性才能用高斯定理</em></strong></p><ol><li>球对称 均匀带电的球面球体多层同心球壳</li><li>轴对称 无限长均匀带电的直线，圆柱面，圆柱体</li><li>面对称 无限大的均匀带电的平面平板</li></ol><p>3月27日</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>无限大均匀带电平面 σ/2ε0<br>用高斯定理做</p><blockquote><p><em>穿过闭合曲面的电通量，等于该曲面所包围的电荷代数和除以ε。与曲面外电荷无关，当写成 EdS的时候，E是由所有电荷产生的场强，是面上的场强</em></p></blockquote><ol><li>对称性分析，判断出方向垂直平面。</li><li>画适当高斯面，柱形高斯面。（满足高斯面二号</li><li>计算，侧面高斯面垂直，为0，左底面，右底面直接等于ES，和等于2ES。</li><li>φ=2ES，由高斯定理得到2ES=σS/ε0，得出答案。</li><li>平面上，为0</li></ol><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>无限大带电厚板。</p><ol><li>分为板外板内的场强</li><li>板外E=ρd/2ε0</li><li>板内E=ρx/ε0</li></ol><h2 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h2><p>均匀带电球面</p><ol><li>分析场强方向</li><li>画高斯面 同心球面半径r</li><li>E4Πr^2=q总/ε0</li><li>分为球面内，球面外</li><li>球面外，等效为点电荷</li><li>球面内，q=0 E=0</li><li>球面上，同无限大平面</li></ol><h2 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h2><p>均匀带电球体</p><p>同面，但内部由电场 球外E=ρ/3ε0  *R^3/r^2<br>球内E=ρ/3ε0  *r</p><h2 id="例五"><a href="#例五" class="headerlink" title="例五"></a>例五</h2><p>无限长带电直线  E=λ/2Πεr<br>适当高斯面为圆柱面，只用侧面</p><h2 id="例六"><a href="#例六" class="headerlink" title="例六"></a>例六</h2><p>半径为r的无限长均匀带电圆柱体 λ为线密度<br>体内λr/2Πε0R^2<br>体外  λ/2Πε0r</p><h1 id="静电场的环路定理-电势"><a href="#静电场的环路定理-电势" class="headerlink" title="静电场的环路定理 电势"></a>静电场的环路定理 电势</h1><p>静电场力也是保守力<br>所以沿着闭合路径移动，做功为0</p><p>在静电场中，电场强度的环流为0</p><p>高斯定理得到静电场是有源场，环路定理知静电场是无旋场。<br>环路定理可以检验一个电场是不是静电场，做一个环路，求电势是不是0</p><p>电势能，电势</p><p>Wab=Ea-Eb</p><p>求某一点的电势就从该点搬到0点</p><p>零点的选择，</p><ol><li>无穷远处（源电荷有限范围</li><li>无限大，无限长时，零点选在有限远处。</li><li>实际选大地，仪器外壳。</li></ol><p>电势能不能描述电场本身性质<br>电势可以。</p><p>电势为从所求点搬到电势零点，选零点同电势能</p><p>电势差就是电压，v表示电势，u表示电压。谁减谁的差就是从谁搬到谁<br>dv=Edl</p><p>1v=1j/c</p><h2 id="电势的计算"><a href="#电势的计算" class="headerlink" title="电势的计算"></a>电势的计算</h2><h3 id="点电荷-q-4Πε0r-无穷远为0电"><a href="#点电荷-q-4Πε0r-无穷远为0电" class="headerlink" title="点电荷  q/4Πε0r (无穷远为0电)"></a>点电荷  q/4Πε0r (无穷远为0电)</h3><h3 id="点电荷系的电势-总场强矢量叠加后对l积分等同于单独的电势的代数和"><a href="#点电荷系的电势-总场强矢量叠加后对l积分等同于单独的电势的代数和" class="headerlink" title="点电荷系的电势  总场强矢量叠加后对l积分等同于单独的电势的代数和"></a>点电荷系的电势  总场强矢量叠加后对l积分等同于单独的电势的代数和</h3><h3 id="连续分布的电势-对dq积分"><a href="#连续分布的电势-对dq积分" class="headerlink" title="连续分布的电势 对dq积分"></a>连续分布的电势 对dq积分</h3><h3 id="已知场强分布，用定义式，已知电荷分布，用电势叠加原理"><a href="#已知场强分布，用定义式，已知电荷分布，用电势叠加原理" class="headerlink" title="已知场强分布，用定义式，已知电荷分布，用电势叠加原理"></a>已知场强分布，用定义式，已知电荷分布，用电势叠加原理</h3><p>3月31日</p><h1 id="均匀带电圆环在圆心场强为零电势不为零"><a href="#均匀带电圆环在圆心场强为零电势不为零" class="headerlink" title="均匀带电圆环在圆心场强为零电势不为零"></a>均匀带电圆环在圆心场强为零电势不为零</h1><h2 id="非均匀带电圆环环心得电势仍未q-4ΠεR，任取P点也同均匀。"><a href="#非均匀带电圆环环心得电势仍未q-4ΠεR，任取P点也同均匀。" class="headerlink" title="非均匀带电圆环环心得电势仍未q/4ΠεR，任取P点也同均匀。"></a>非均匀带电圆环环心得电势仍未q/4ΠεR，任取P点也同均匀。</h2><h1 id="均匀分布的带电圆盘，将圆环积分从0积分到R，无穷远同圆盘"><a href="#均匀分布的带电圆盘，将圆环积分从0积分到R，无穷远同圆盘" class="headerlink" title="均匀分布的带电圆盘，将圆环积分从0积分到R，无穷远同圆盘"></a>均匀分布的带电圆盘，将圆环积分从0积分到R，无穷远同圆盘</h1><h1 id="均匀带电球面球面内为等势的等于q-4Πεr"><a href="#均匀带电球面球面内为等势的等于q-4Πεr" class="headerlink" title="均匀带电球面球面内为等势的等于q/4Πεr"></a>均匀带电球面球面内为等势的等于q/4Πεr</h1><h1 id="非均匀带电球面的球心处的电势也为q-4Πεr。"><a href="#非均匀带电球面的球心处的电势也为q-4Πεr。" class="headerlink" title="非均匀带电球面的球心处的电势也为q/4Πεr。"></a>非均匀带电球面的球心处的电势也为q/4Πεr。</h1><h1 id="均匀带电球体，非导体，因为导体内部没有电荷。"><a href="#均匀带电球体，非导体，因为导体内部没有电荷。" class="headerlink" title="均匀带电球体，非导体，因为导体内部没有电荷。"></a>均匀带电球体，非导体，因为导体内部没有电荷。</h1><h1 id="无限长均匀带电直线-不能去无穷远作为势能零点"><a href="#无限长均匀带电直线-不能去无穷远作为势能零点" class="headerlink" title="无限长均匀带电直线 不能去无穷远作为势能零点"></a>无限长均匀带电直线 不能去无穷远作为势能零点</h1><h1 id="场强与电势的关系"><a href="#场强与电势的关系" class="headerlink" title="场强与电势的关系"></a>场强与电势的关系</h1><h2 id="等势面与电场线处处正交。电场线方向指向电势降落的方向"><a href="#等势面与电场线处处正交。电场线方向指向电势降落的方向" class="headerlink" title="等势面与电场线处处正交。电场线方向指向电势降落的方向"></a>等势面与电场线处处正交。电场线方向指向电势降落的方向</h2><h2 id="可以用电势求场强分布"><a href="#可以用电势求场强分布" class="headerlink" title="可以用电势求场强分布"></a>可以用电势求场强分布</h2><h1 id="静电场中的电偶极子"><a href="#静电场中的电偶极子" class="headerlink" title="静电场中的电偶极子"></a>静电场中的电偶极子</h1><h2 id="力矩r×f（矢量）"><a href="#力矩r×f（矢量）" class="headerlink" title="力矩r×f（矢量）"></a>力矩r×f（矢量）</h2><p>电偶极子所受力矩M=p×E<br>有稳定平衡与非稳定平衡<br>在非匀强电场中有转动有平动<br>p=ql<br>电势能E=-p点乘E<br>90° 电势能为0  力矩最大<br>0° 电势能最底  力矩为0<br>180° 电势能最高 力矩为0 非稳定平衡</p><h1 id="静电场中的导体"><a href="#静电场中的导体" class="headerlink" title="静电场中的导体"></a>静电场中的导体</h1><h2 id="静电感应-静电平衡"><a href="#静电感应-静电平衡" class="headerlink" title="静电感应 静电平衡"></a>静电感应 静电平衡</h2><h3 id="静电感应，金属中电子自己跑"><a href="#静电感应，金属中电子自己跑" class="headerlink" title="静电感应，金属中电子自己跑"></a>静电感应，金属中电子自己跑</h3><h3 id="静电平衡-内部场强为0，且表面电势为0-表面没有电荷的宏观定向移动。"><a href="#静电平衡-内部场强为0，且表面电势为0-表面没有电荷的宏观定向移动。" class="headerlink" title="静电平衡 内部场强为0，且表面电势为0 表面没有电荷的宏观定向移动。"></a>静电平衡 内部场强为0，且表面电势为0 表面没有电荷的宏观定向移动。</h3><h3 id="静电平衡的时候导体是等势体，表面是等势面"><a href="#静电平衡的时候导体是等势体，表面是等势面" class="headerlink" title="静电平衡的时候导体是等势体，表面是等势面"></a>静电平衡的时候导体是等势体，表面是等势面</h3><h3 id="静电平衡时导体上的电荷分布"><a href="#静电平衡时导体上的电荷分布" class="headerlink" title="静电平衡时导体上的电荷分布"></a>静电平衡时导体上的电荷分布</h3><ol><li>实心导体</li></ol><blockquote><p>内部场强为0，用高斯定理得到，内部电荷的代数和为0所以内部处处没有净电荷。所以电荷只能分布在表面上。所以导体不可能是均匀带电体，只能是带电面</p></blockquote><blockquote><p>形状简单的孤立导体（其他导体或带电体离他足够远，对他没有影响），表面各处电荷面密度与该处表面的曲率有关</p><blockquote><p>凸出 曲率为正 大 面密度大<br>平坦 曲率小 面密度小<br>凹进 曲率为负 面密度更小</p></blockquote></blockquote><h3 id="导体表面外附近的电场"><a href="#导体表面外附近的电场" class="headerlink" title="导体表面外附近的电场"></a>导体表面外附近的电场</h3><p>内部为0 上垂直</p><p>用高斯定理，用柱形高斯面 En=σ/ε0  σ是局域处电荷面密度 虽然σ为局域面密度，但与其他各处电荷分布有关<br>表面上的电场为En的一半</p><p>4月3日</p><h4 id="尖端放电"><a href="#尖端放电" class="headerlink" title="尖端放电"></a>尖端放电</h4><p>场强可以大到使空气电离。金属元件做成球形光滑为了避免尖端放电</p><h3 id="空腔导体与静电屏蔽"><a href="#空腔导体与静电屏蔽" class="headerlink" title="空腔导体与静电屏蔽"></a>空腔导体与静电屏蔽</h3><h4 id="空腔内无电荷"><a href="#空腔内无电荷" class="headerlink" title="空腔内无电荷"></a>空腔内无电荷</h4><p>假设有某处为正，则必然有一处为负。则可以画电场线，则有了电势差，则矛盾，则假设不成立，所以内表面不存在净电荷，且空腔内无电场。</p><h4 id="空腔内有电荷"><a href="#空腔内有电荷" class="headerlink" title="空腔内有电荷"></a>空腔内有电荷</h4><p>则内表面有了等量异号的电荷</p><blockquote><p>总结，内表面的电荷由内部电荷感应出来，外表面电荷由外部电荷感应出来。内外互不影响</p></blockquote><blockquote><p>空腔内表面的电荷与腔内电荷在腔外，导体外产生的电场也相互抵消</p></blockquote><p><strong>若空腔导体接地，则导体与大地接通，外表面的电荷会重新分布</strong></p><p>接地腔内腔外互不影响</p><p>不接地，腔内有电荷，腔内电荷回影响腔外电荷大小  +q</p><h3 id="有导体时静电场的计算"><a href="#有导体时静电场的计算" class="headerlink" title="有导体时静电场的计算"></a>有导体时静电场的计算</h3><blockquote><p>一般用到导体静电平衡的条件，静电场的高斯定理，电荷守恒定律，场强叠加原理。</p></blockquote><ol><li>任取两点，列静电平衡条件</li><li>列经典守恒定律</li><li>根据已知解题</li></ol><p>注！！！！接地只意味着电势为0，不意味着电荷都没了</p><p>4月7号</p><h1 id="静电场的能量"><a href="#静电场的能量" class="headerlink" title="静电场的能量"></a>静电场的能量</h1><h2 id="电容器的电能"><a href="#电容器的电能" class="headerlink" title="电容器的电能"></a>电容器的电能</h2><p>w=Q^2/2C. 为放完电or充完电的情况<br>上式为电容器的储能公式，还有1/2 CU^2，  1/2 QU<br>要看一下哪个物理量的变化，电源连接和电源断开。<br>W=1/2 εE^2V, w与介质，电场强度，体积V有关，能量储存在电场中。<br>能量密度，w=1/2 εE^2,非匀强电场则对体积元积分。积分区域，遍布电场分布的区域。</p><h2 id="带点体系的静电能"><a href="#带点体系的静电能" class="headerlink" title="带点体系的静电能"></a>带点体系的静电能</h2><p>不详细说明</p><h3 id="总静电能-每个带电体单独存在时的自能＋带电体之间的-互作用能"><a href="#总静电能-每个带电体单独存在时的自能＋带电体之间的-互作用能" class="headerlink" title="总静电能=每个带电体单独存在时的自能＋带电体之间的  互作用能"></a>总静电能=每个带电体单独存在时的自能＋带电体之间的  互作用能</h3><h1 id="磁"><a href="#磁" class="headerlink" title="磁"></a>磁</h1><h2 id="磁与电的发现"><a href="#磁与电的发现" class="headerlink" title="磁与电的发现"></a>磁与电的发现</h2><ol><li>分子电流</li><li>电流的磁现象</li></ol><h2 id="磁场-磁感应强度"><a href="#磁场-磁感应强度" class="headerlink" title="磁场 磁感应强度"></a>磁场 磁感应强度</h2><h3 id="磁场"><a href="#磁场" class="headerlink" title="磁场"></a>磁场</h3><p>运动电荷电流磁体周围存在磁场，磁场对磁体运动电荷 电流有磁场力的作用，磁场具有能量。</p><h3 id="磁感应强度"><a href="#磁感应强度" class="headerlink" title="磁感应强度"></a>磁感应强度</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>F=qv×b，B的单位是特斯拉，高斯,1T=10^4G</p><h2 id="毕奥-萨伐尔定律"><a href="#毕奥-萨伐尔定律" class="headerlink" title="毕奥-萨伐尔定律"></a>毕奥-萨伐尔定律</h2><h3 id="毕奥-萨伐尔定律详细内容"><a href="#毕奥-萨伐尔定律详细内容" class="headerlink" title="毕奥-萨伐尔定律详细内容"></a>毕奥-萨伐尔定律详细内容</h3><h4 id="电流元所产生的磁场的公式"><a href="#电流元所产生的磁场的公式" class="headerlink" title="电流元所产生的磁场的公式"></a>电流元所产生的磁场的公式</h4><p>电流元的方向，为电流的方向<br>B=μ/4Π idl × r/r^3<br>右手定则判断方向 l到r，r为电流元处到所求点的直线，×为向内，·为向外，类似射箭</p><blockquote><p>本定律是由实验抽象出来，不能实验直接证明</p></blockquote><h3 id="比萨定律应用举例"><a href="#比萨定律应用举例" class="headerlink" title="比萨定律应用举例"></a>比萨定律应用举例</h3><h4 id="载流长直导线"><a href="#载流长直导线" class="headerlink" title="载流长直导线"></a>载流长直导线</h4><p>方向，右手螺旋，直接握住</p><ol><li>无限长直线电流的磁场<br>B=μi/2Πr<br>E=λ/2Πεr</li><li>半无限长 Π到Π/2 or 0到Π/2<br>B=μi/4Πr</li><li>点再导线延长线上，B=0</li></ol><p>4月10号</p><p>载流圆线圈，其轴上的磁场仅延轴的方向，环心处为B=μI/2R，注意，无Π，<br>x&gt;&gt;R时，B=μIR^2/2x^3<br>磁矩m=is，s面积矢量的方向是右手螺旋的方向<br>B=μ/2Π  m/x^3</p><p><strong>无限长载流螺线管</strong><br>B=μnl，<br>管口处为0.5μnl</p><h3 id="运动电荷的磁场"><a href="#运动电荷的磁场" class="headerlink" title="运动电荷的磁场"></a>运动电荷的磁场</h3><p>B=μ/4Π · q×r/r^3,叉乘时方向用电流方向</p><h2 id="磁通量-磁场高斯定理"><a href="#磁通量-磁场高斯定理" class="headerlink" title="磁通量 磁场高斯定理"></a>磁通量 磁场高斯定理</h2><h3 id="磁感应线"><a href="#磁感应线" class="headerlink" title="磁感应线"></a>磁感应线</h3><ol><li>不相交，</li><li>无头无尾的闭合曲线（无限远到无限远也算）</li><li>与电流仙湖套连，服从右手螺旋。</li><li>曲线切线方向为磁感应强度方向</li><li>磁场强度由磁感应线的疏密来表示</li></ol><h3 id="磁通量"><a href="#磁通量" class="headerlink" title="磁通量"></a>磁通量</h3><p>Φ=B·S。<br>传入为负，传出为正</p><h3 id="磁场高斯定理"><a href="#磁场高斯定理" class="headerlink" title="磁场高斯定理"></a>磁场高斯定理</h3><p>通过任意闭合曲面的磁通量必定为0<br>磁感线为平行直线的空间，磁感应线上的各点磁感强度相等</p><h2 id="安培环路定理"><a href="#安培环路定理" class="headerlink" title="安培环路定理"></a>安培环路定理</h2><h3 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h3><p>稳恒电流产生的磁感应强度沿任意闭合环路L的线积分，等于穿过该环路的电流强度的<strong>代数和</strong>的μ倍。</p><ol><li>B的环流只有穿过环路的电流有关</li><li>环路上个点的磁场为所有电流的贡献</li><li>磁场有旋场，电流为磁场涡旋的中心。</li><li>与积分环路方向成右手螺旋的电流为正，反之为负</li><li>穿过积分的环电流必须和环路铰链（必须要套在一起）</li><li>稳恒电流必须是闭合的，安培环路定理只适用于闭合电路（无限长的直电流为闭合）</li><li>无电流空间区域内，磁感应线平行直线，那么磁场一定是匀强磁场</li></ol><p>4月14号</p><h2 id="安培环路定理的应用"><a href="#安培环路定理的应用" class="headerlink" title="安培环路定理的应用"></a>安培环路定理的应用</h2><p>条件：稳恒电流对称分布</p><h3 id="例一，无限长均匀载流圆柱面半径为R"><a href="#例一，无限长均匀载流圆柱面半径为R" class="headerlink" title="例一，无限长均匀载流圆柱面半径为R"></a>例一，无限长均匀载流圆柱面半径为R</h3><p>第一步，判断磁场方向，圆柱面同心圆的切线方向。<br>第二步，选取逆时针为环流方向。<br>第三步，求环路定理左边，磁感应强度沿闭合环路的线积分<br>第四步，分条件求右边。<br>圆柱面外，则电流为I，则为μI。<br>圆柱面内，则小同心圆里无电流，则B=0，无限长均匀载流圆柱面内磁场处处为0</p><h3 id="例二，同轴电缆（圆柱体）"><a href="#例二，同轴电缆（圆柱体）" class="headerlink" title="例二，同轴电缆（圆柱体）"></a>例二，同轴电缆（圆柱体）</h3><h3 id="例三，无限大均匀载流平面，周围磁场"><a href="#例三，无限大均匀载流平面，周围磁场" class="headerlink" title="例三，无限大均匀载流平面，周围磁场"></a>例三，无限大均匀载流平面，周围磁场</h3><blockquote><p>电流密度，I/截面面积，为体密度<br>I/l,为面密度，单位长度上。<br>将载流直线看成无限直线，<br>用矩形环路</p></blockquote><h3 id="例四，载流无限长直螺线管内任一点的磁场"><a href="#例四，载流无限长直螺线管内任一点的磁场" class="headerlink" title="例四，载流无限长直螺线管内任一点的磁场"></a>例四，载流无限长直螺线管内任一点的磁场</h3><p>右手定则判断方向 l到r，r为电流元处到所求点的直线，×为向内，·为向外，类似射箭</p><h4 id="例五，载流螺旋管（环形螺线管内的磁场）"><a href="#例五，载流螺旋管（环形螺线管内的磁场）" class="headerlink" title="例五，载流螺旋管（环形螺线管内的磁场）"></a>例五，载流螺旋管（环形螺线管内的磁场）</h4><h2 id="磁场对运动电荷的作用"><a href="#磁场对运动电荷的作用" class="headerlink" title="磁场对运动电荷的作用"></a>磁场对运动电荷的作用</h2><h3 id="洛伦兹力"><a href="#洛伦兹力" class="headerlink" title="洛伦兹力"></a>洛伦兹力</h3><p>F=qv×B</p><blockquote><p>记得负电荷</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>只对运动电荷有作用力</li><li>始终不做功</li></ol><h3 id="带电粒子在磁场中的运动"><a href="#带电粒子在磁场中的运动" class="headerlink" title="带电粒子在磁场中的运动"></a>带电粒子在磁场中的运动</h3><h4 id="速度方向鱼磁场方向平行"><a href="#速度方向鱼磁场方向平行" class="headerlink" title="速度方向鱼磁场方向平行"></a>速度方向鱼磁场方向平行</h4><p>粒子做匀速直线运动</p><h4 id="速度方向与磁场方向垂直"><a href="#速度方向与磁场方向垂直" class="headerlink" title="速度方向与磁场方向垂直"></a>速度方向与磁场方向垂直</h4><p>粒子做匀速圆周运动</p><h4 id="速度方向与磁场方向有夹角"><a href="#速度方向与磁场方向有夹角" class="headerlink" title="速度方向与磁场方向有夹角"></a>速度方向与磁场方向有夹角</h4><p>螺旋线向前运动，将速度适量分解。</p><blockquote><p>磁约束效应，强磁场可把带电粒子约束<br>螺距-粒子回转一周所前进的距离：与vy无关  </p></blockquote><h3 id="霍尔效应"><a href="#霍尔效应" class="headerlink" title="霍尔效应"></a>霍尔效应</h3><p>载流导体版，垂直于版面施加磁场，则版面两侧微弱电势差<br>霍尔系数Rh=1/nq<br>量子霍尔效应，低温，强磁<br>分数霍尔效应</p><ol><li>霍尔效应的应用。<br>Uab=1/nq   *IB/d</li></ol><blockquote><p>n为载流子浓度<br>通过测量电压判断载流子类型，求B I n  </p></blockquote><p>磁流体发电</p><h2 id="磁场对电流的作用"><a href="#磁场对电流的作用" class="headerlink" title="磁场对电流的作用"></a>磁场对电流的作用</h2><h3 id="磁场对载流导线的作用"><a href="#磁场对载流导线的作用" class="headerlink" title="磁场对载流导线的作用"></a>磁场对载流导线的作用</h3><p>电流元在磁场中收到的力等于体积内所有载流子受到的力，由此可以推出安培力公式<br>dF=Idl×B</p><blockquote><p>I=nqvs<br>对于一段载流导线，为积分<br>若磁场为匀强磁场，则B可以提出来<br>匀强磁场，闭合电流，则为F=0（匀强磁场中的线圈）</p></blockquote><blockquote><p>弯弯曲曲的一条先矢量积分就是a指向b的直线<br>电流同向相吸。</p></blockquote><p>4月17日</p><h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><p>通有电流的矩形线框 旁边是载流直线，求受力</p><blockquote><p>方法一：分别求左右两条对称边，上下两条对称边，得到结果<br>方法二：定性分析。</p></blockquote><h3 id="均匀磁场对平面载流线圈的作用"><a href="#均匀磁场对平面载流线圈的作用" class="headerlink" title="均匀磁场对平面载流线圈的作用"></a>均匀磁场对平面载流线圈的作用</h3><p>合力为0，无平动<br>力矩和不为0，有转动，力矩=F×r矢量叉乘</p><blockquote><p>M=m×B。磁力矩 等于磁偶极矩×磁通量<br>M=p×M</p></blockquote><h3 id="磁场力的功"><a href="#磁场力的功" class="headerlink" title="磁场力的功"></a>磁场力的功</h3><ol><li>磁场对载流导线的功，easy。<br>磁场力的功等于电流强度乘穿过回路的磁通量的增量or电流强度×导线切割磁力线的条数。</li><li>磁场对对载流线圈。同上</li><li>磁偶极子的势能，设磁矩与磁感应强度B相互垂直时为势能零点。 </li></ol><h1 id="变化电磁场"><a href="#变化电磁场" class="headerlink" title="变化电磁场"></a>变化电磁场</h1><h2 id="法拉第电磁感应定律"><a href="#法拉第电磁感应定律" class="headerlink" title="法拉第电磁感应定律"></a>法拉第电磁感应定律</h2><h3 id="总结实验现象得到，磁通量变化，会产生电动势"><a href="#总结实验现象得到，磁通量变化，会产生电动势" class="headerlink" title="总结实验现象得到，磁通量变化，会产生电动势"></a>总结实验现象得到，磁通量变化，会产生电动势</h3><p>电动势可以从非闭合，介质中产生。<br>感应电动势的大小来自磁通量变化率，方向要考虑磁通量时要增加还是减少。</p><h3 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h3><p>E=-dΦ/dt</p><blockquote><p>规定电动势方向与回路绕行方向一致时为正<br>S,与回路绕行方向成右手螺旋。即通过对回路绕行方向右手螺旋得到S的正方向</p></blockquote><h3 id="回路与环路的区别"><a href="#回路与环路的区别" class="headerlink" title="回路与环路的区别"></a>回路与环路的区别</h3><p>环路是人为画的，回路是确实存在的</p><h3 id="楞次定律"><a href="#楞次定律" class="headerlink" title="楞次定律"></a>楞次定律</h3><p>电磁学中的惯性定理，电磁学中的能量守恒定律</p><h3 id="全磁通"><a href="#全磁通" class="headerlink" title="全磁通"></a>全磁通</h3><p>总电动势等于各匝线圈磁通量的综合。<br>E=-dφ/dt<br> =-NdΦ/dt</p><h3 id="交流电"><a href="#交流电" class="headerlink" title="交流电"></a>交流电</h3><p>E=NBSwsinwt</p><h2 id="动生电动势"><a href="#动生电动势" class="headerlink" title="动生电动势"></a>动生电动势</h2><ol><li>导线运动引起的交动生电动势</li><li>切割磁感线才产生电动势</li><li>V×B,方向为搬用正电荷的方向</li></ol><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><ol><li>补全法（形状特殊的，补全成一个回路，则回路电动势为0</li><li>法拉第电机，圆盘切割磁感线等价于一个半径切磁感线</li></ol><h3 id="功能关系"><a href="#功能关系" class="headerlink" title="功能关系"></a>功能关系</h3><blockquote><p>实际洛伦兹力只传递能量。</p></blockquote><h2 id="感生电动势"><a href="#感生电动势" class="headerlink" title="感生电动势"></a>感生电动势</h2><h3 id="感生电场"><a href="#感生电场" class="headerlink" title="感生电场"></a>感生电场</h3><ol><li>变化的磁场激发感生电场，电场作用于电荷，引起感生电动势</li><li>磁棒插入非金属环，也能产生 电动势，但无电流.</li></ol><h3 id="感生电场及感生电动势的计算"><a href="#感生电场及感生电动势的计算" class="headerlink" title="感生电场及感生电动势的计算"></a>感生电场及感生电动势的计算</h3><ol><li>长直螺线管，管内和管外的感生电场</li></ol><blockquote><p>管内 E=r/2  dB/dt</p></blockquote><blockquote><p>管外 E=R^2/2r  dB/dt</p></blockquote><ol start="2"><li>无限长圆柱内有一根导体棒，求导体棒的感生电动势</li></ol><p>感生电动势=感生电场×dl（线元）<br>因而可得在圆柱的半径方向的感生电动势=0<br>不在半径方向的导体棒，连接成一个回路，则回路电动势=棒的电动势<br>螺线管外则变成扇形区域的面积。</p><h3 id="涡电流"><a href="#涡电流" class="headerlink" title="涡电流"></a>涡电流</h3><ol><li>热效应,电磁炉</li><li>机械效应 电磁阻尼</li><li>防止涡流的方法减小电流截面，增大电阻，插入绝缘薄片</li></ol><h3 id="电子感应加速器"><a href="#电子感应加速器" class="headerlink" title="电子感应加速器"></a>电子感应加速器</h3><h2 id="自感、互感"><a href="#自感、互感" class="headerlink" title="自感、互感"></a>自感、互感</h2><h3 id="自感"><a href="#自感" class="headerlink" title="自感"></a>自感</h3><h4 id="自感定义"><a href="#自感定义" class="headerlink" title="自感定义"></a>自感定义</h4><p>当线圈中的自身电流发生变化时产生感应电动势<br>单位为H 亨利</p><p>B=μnI，无限长螺线管，没有铁磁质<br>B正比于I，φ也正比于B（=bs），所以φ正比于I<br>则φ=LI，L为线圈回路的自感系数</p><h4 id="自感电动势计算"><a href="#自感电动势计算" class="headerlink" title="自感电动势计算"></a>自感电动势计算</h4><p>自感电动势E=-dφ/dt=-LdI/dt，此时自感系数为常熟，若自感系数也为变量，则需对两边同时求导</p><h4 id="电磁惯性"><a href="#电磁惯性" class="headerlink" title="电磁惯性"></a>电磁惯性</h4><p>自感具有保持原电流状态的能力，叫做电磁惯性</p><p>L是这种能力大小的量度</p><h4 id="自感系数的计算"><a href="#自感系数的计算" class="headerlink" title="自感系数的计算"></a>自感系数的计算</h4><p>L与回路的大小形状匝数磁介质有关<br>L=φ/I<br>L=dφ/dI=-E/（dI/dt）（实质为前面那个式子上下对t求导）</p><h4 id="自感例题"><a href="#自感例题" class="headerlink" title="自感例题"></a>自感例题</h4><ol><li>螺线管L=μn^2Sl<br>插入铁芯可以增大μ</li><li>圆柱面<br>单位长度的自感L=μ0μr/2Π  lnR2/R1</li></ol><h3 id="互感"><a href="#互感" class="headerlink" title="互感"></a>互感</h3><p>基本与自感一致</p><p>方便计算可用下式<br>M=根号下L1L2 （彼此磁场完全穿过）</p><p>M=k根号L1L2<br>k为耦合系数<br>k与线圈的相对位置有关<br>    无限远or垂直时，k=0，M=0</p><h2 id="磁场的能量"><a href="#磁场的能量" class="headerlink" title="磁场的能量"></a>磁场的能量</h2><p>电源转换为线圈中的储能</p><p>线圈 1/2 L I^2<br>电容 1/2 C U^2<br>Wm(单位体积内的磁场能量)= 1/2 BH<br>所以可以对体积元积分<br>和电场完全对称<br>W总=0.5DE +0.5BH</p><h2 id="位移电流"><a href="#位移电流" class="headerlink" title="位移电流"></a>位移电流</h2><p>原因：安培环路不成立</p><p>使用电流连续方程（电荷守恒定律）</p><p>全电流=传导电流＋位移电流<br>位移电流=电位移通量的导数<br>I=dφD/dt=S* dD/dt<br>I=ΠR^2 ε0 dE/dt<br>因为D=εE<br>B=μH<br>感应电动势=磁通量的导数</p><p>位移电流的本质是变化的电场</p><p>推广得到全电流环路定理</p><h2 id="麦克斯韦方程组"><a href="#麦克斯韦方程组" class="headerlink" title="麦克斯韦方程组"></a>麦克斯韦方程组</h2><p>静电场</p><p>静电场的高斯定理 DS=q<br>静电场的环路定理 El=0</p><p>稳恒磁场<br>磁场的高斯定理 BS=0<br>安培环路定理 Hl =Ic（传导电流）</p><p>对一切而言</p><p>环路定理 El=dB/dt  *S<br>H</p>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
      <category>电磁</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理科</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>振动</title>
    <link href="/2020/05/08/%E6%8C%AF%E5%8A%A8/"/>
    <url>/2020/05/08/%E6%8C%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>关于振动的笔记</p><a id="more"></a><h1 id="机械振动"><a href="#机械振动" class="headerlink" title="机械振动"></a>机械振动</h1><h2 id="什么是简谐振动"><a href="#什么是简谐振动" class="headerlink" title="什么是简谐振动"></a>什么是简谐振动</h2><h3 id="任何一个物理量在某一数值附近反复变化叫振动"><a href="#任何一个物理量在某一数值附近反复变化叫振动" class="headerlink" title="任何一个物理量在某一数值附近反复变化叫振动"></a>任何一个物理量在某一数值附近反复变化叫振动</h3><ol><li>受迫振动：受外力驱动产生的振动，带来共振</li><li>自由振动</li><li>1 阻尼振动 收到阻力</li><li>2 无阻尼自由振动</li><li>2.1 无阻尼自由非谐振动</li><li>2.2 无阻尼自由谐振动（简谐振动）</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol><li>弹簧振子</li></ol><p><em>注意，以平衡位置作为坐标原点</em><br>2. 单摆<br><em>默认逆时针为在</em></p><h3 id="简谐振动的特点"><a href="#简谐振动的特点" class="headerlink" title="简谐振动的特点"></a>简谐振动的特点</h3><p>运动方程由谐函数描述</p><ol><li>运动学：Q（t）=Qcos（）……Q为任何物理量</li><li>动力学：Q对t二阶导+w^2Q=0</li><li>线性恢复力：弹簧振子，单摆</li><li>振动能量 Ep+Ek时，总能量不变<br>满足上述四条之一就是简谐振动</li></ol><h3 id="振动例题"><a href="#振动例题" class="headerlink" title="振动例题"></a>振动例题</h3><p>以平衡位置坐标原点</p><h3 id="简谐运动的描述解析以及真的去"><a href="#简谐运动的描述解析以及真的去" class="headerlink" title="简谐运动的描述解析以及真的去"></a>简谐运动的描述解析以及真的去</h3><h2 id="简谐振动的特征量"><a href="#简谐振动的特征量" class="headerlink" title="简谐振动的特征量"></a>简谐振动的特征量</h2><p>振幅A，由初始条件确定<br>角频率， 系统固有的性质<br>相位、初相位 相位描写t时刻的振动状态。<br>初相位，为开始计时时刻的振动状态</p><p>初相位不等同于摆角。<br>相位对时间的导数为角频率，不为角速度<br>摆角对时间的导数为角速度</p><p>第一象限 x&gt;0,v&lt;0 0到90<br>第二象限 x,v 均小于0 90到180<br>第三象限 x&lt;0 v&gt;0 180到270<br>第四象限 x,v 均大于0 270到360</p><h2 id="旋转矢量法"><a href="#旋转矢量法" class="headerlink" title="旋转矢量法"></a>旋转矢量法</h2><p>将振幅看作矢量，以角速度w绕0逆时针旋转，则在x轴的投影p即代表简谐振动<br>相位差，对相位相减。（同频率<br>取小于Π的夹角<br>Δφ&gt;0 则x2比x1领先<br>Δφ&lt;0 则x2比x1落后<br>==2kΠ，同相<br>==(2k-1)Π，反相</p><h2 id="简谐振动的能量"><a href="#简谐振动的能量" class="headerlink" title="简谐振动的能量"></a>简谐振动的能量</h2><p>动能和弹性势能<br>公式易知<br>且k=mΩ^2<br>E总=1/2 k A^2<br>能量与振幅的平方成正比<br>平均动能，平均势能为最大值的一半<br>平衡位置动能max，势能min<br>最大位移，相反<br><strong>势能最低点附近的微小振动为简谐振动</strong></p><h2 id="简谐振动的合成"><a href="#简谐振动的合成" class="headerlink" title="简谐振动的合成"></a>简谐振动的合成</h2><h3 id="分震动在一条直线上"><a href="#分震动在一条直线上" class="headerlink" title="分震动在一条直线上"></a>分震动在一条直线上</h3><h4 id="同频率"><a href="#同频率" class="headerlink" title="同频率"></a>同频率</h4><h5 id="两个-干涉-双缝"><a href="#两个-干涉-双缝" class="headerlink" title="两个 干涉 双缝"></a>两个 干涉 双缝</h5><ol><li>解析法<br>x=x1+x2</li><li>旋转矢量法<br>合成了一个不变形的平行四边形</li><li>讨论干涉</li><li>1 振动同相时<br>此时合振幅最大，光学中为亮条纹中心，干涉相长</li><li>2 振动反相时<br>此时合振幅最小，暗条纹，干涉相消</li><li>3 非整数倍时<br>亮纹中心和暗纹之间</li></ol><h5 id="多个-衍射-单缝-光栅"><a href="#多个-衍射-单缝-光栅" class="headerlink" title="多个 衍射 单缝 光栅"></a>多个 衍射 单缝 光栅</h5><ol><li>仍然是简谐振动</li><li>同振幅，初相位等差数列时</li><li>1 此时构成正多边形的一部分,连接外接圆圆心，则顶角为公差的值</li><li>讨论 多光束干涉</li><li>1 各个分振动同向，主极大<br>δ=2kΠ</li><li>2 各个分振动闭合，极小值<br>Nδ=2kΠ k!=0 k!=mN（k不是n的整数倍）</li><li>3 合矢量为外接圆直径，次级大<br>Nδ=Π的奇数倍</li></ol><h4 id="不同频率-拍频"><a href="#不同频率-拍频" class="headerlink" title="不同频率 拍频"></a>不同频率 拍频</h4><p>矢量合成为变化的平行四边形，则振幅有变化，则非平行四边形<br>合振动的周期性的强弱变化称为拍<br>拍频：单位时间内振动强弱变化的次数<br>应用： 音叉校准乐器 ，测量超声波频率，测量无线电电波</p><h3 id="分震动在垂直方向上"><a href="#分震动在垂直方向上" class="headerlink" title="分震动在垂直方向上"></a>分震动在垂直方向上</h3><h4 id="同频率-偏振-线偏振-圆偏振-椭圆偏振"><a href="#同频率-偏振-线偏振-圆偏振-椭圆偏振" class="headerlink" title="同频率 偏振 线偏振 圆偏振 椭圆偏振"></a>同频率 偏振 线偏振 圆偏振 椭圆偏振</h4><p>呈现出椭圆形状<br>相位差为y-x<br>右旋（顺时针）<br>左旋（逆时针）<br>椭圆会被卡在矩形区域内<br>在正负A1，正负A2内</p><p>在正负A1，正负A2内，A1，A2分别为两个分运动的振幅</p><p><img src="https://i.loli.net/2020/05/12/BSGmKCtx8Tf2MuW.png" srcset="/img/loading.gif" alt="image-20200512165642623"></p><p>下面基于不同相位差来讨论，该讨论为偏振光的基础，但是我们不学偏振光</p><ol><li><p>同向的时候，（相位差为0时）</p><ol><li><p>轨迹为过原点斜率为正的的直线</p></li><li><p>运动为简谐振动，振幅为矢量和，初相位不变，角频率不变</p></li></ol></li><li><p>反相的时候</p><ol><li>轨迹为过原点，斜率为负的直线</li><li>运动为简谐振动，振幅为A<del>1</del> -A<del>2</del>矢量差，初相位为Φ<del>1</del>，角频率不变</li></ol></li><li><p>y比x领先Π/2 </p><ol><li><p>正椭圆方程，焦点再y轴上</p></li><li><p>右旋（顺时针），转一圈的周期等于分振动的周期</p></li></ol></li><li><p>y比x落后Π/2</p><ol><li>正椭圆，焦点仍在y轴上</li><li>左旋</li></ol></li></ol><blockquote><p>总结，y比x领先0，Π，右旋</p><p>反之，左旋</p></blockquote><h5 id="两个"><a href="#两个" class="headerlink" title="两个"></a>两个</h5><ol><li>两个频率相差很小时，近似为同频率，逐渐从直线变为椭圆再变成直线</li><li>相差大，但是有<strong>简单</strong>整数比的关系，闭合曲线   李萨如图</li></ol>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
      <category>振动与波动</category>
      
      <category>机械振动</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理科</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给小小白的python3安装说明</title>
    <link href="/2020/04/27/%E7%BB%99%E5%B0%8F%E5%B0%8F%E7%99%BD%E7%9A%84python3%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/"/>
    <url>/2020/04/27/%E7%BB%99%E5%B0%8F%E5%B0%8F%E7%99%BD%E7%9A%84python3%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>给小小的，白白的，python3包教包会指南。</p><a id="more"></a><h2 id="第一步，开启并且配置wsl"><a href="#第一步，开启并且配置wsl" class="headerlink" title="第一步，开启并且配置wsl"></a>第一步，开启并且配置wsl</h2><h3 id="为什么使用wsl"><a href="#为什么使用wsl" class="headerlink" title="为什么使用wsl"></a>为什么使用wsl</h3><ol><li>自带python3，和git。</li><li>易于解决因为GFW，导致下载速度过慢的bug</li></ol><h3 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h3><ol><li><p>win+q，输入控制面板，</p></li><li><p>打开控制面板，点击程序</p></li><li><p>在程序和功能一栏，可以看见启用或关闭Windows功能，点击它</p></li><li><p>选择适用于Linux的Windows子系统</p></li><li><p>重启电脑</p></li><li><p>win+q，输入应用商店，回车</p></li><li><p>选择Ubuntu，安装</p></li><li><p>win+q，输入wsl，回车。设置基本信息<strong>注意，输入密码是看不见东西是Linux系统的正常现象</strong></p></li></ol><h3 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a>注意！！</h3><p>此时你已经可以使用命令 </p><pre><code class="hljs bash">python3</code></pre><p>来进行python3的学习了，</p><p>若想要退出输入exit(),即可<br>下面的内容是后期调包，安装vscode等操作要用到的</p><h3 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h3><p><em>目的是避免GFW</em></p><p>输入命令</p><pre><code class="hljs bash">sudo vim /etc/apt/sources.list</code></pre><p>然后输入刚刚的密码<br>进入文件后，莫慌。<br>注意自己的输入法是不是在英文模式。<br>不是，就先调成是<br>先观察文件里有没有aliyun的字样<strong>也可以输入gg/aliyun 回车。看有没有选中文字</strong><br>如果有，请跳到下一部分。<br>如果没有，请看下文<br>输入ggdG<strong>注意大小写，用于清空文件</strong><br>之后按esc</p><p>之后复制下面这段文字</p><pre><code class="hljs bash">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><p>然后在wsl里按‘i’，接着右键，之后 输入<br>之后按esc</p><pre><code class="hljs bash">:wq</code></pre><p>接着输入命令</p><pre><code class="hljs bash">sudo apt-get update</code></pre><h3 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h3><pre><code class="hljs bash">sudo apt-get install code <span class="hljs-comment">#安装VScode</span></code></pre><pre><code class="hljs bash">sudo apt-get install python3-pip <span class="hljs-comment">#安装包管理器</span></code></pre><pre><code class="hljs bash">sudo mkdir ~/.pip<span class="hljs-built_in">cd</span> ~/.pipvim pip.conf</code></pre><p>复制下面内容</p><pre><code class="hljs bsah">[global]index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple[install]trusted-host&#x3D;mirrors.aliyun.com</code></pre><p>在wsl里右键</p><p>然后esc，之后输入</p><pre><code class="hljs bash">:wq</code></pre><p>之后//此步大该可以跳过吧……</p><pre><code class="hljs bash">pip3 install flake8pip3 install yapf</code></pre><p>安装两个插件</p><p>下一步为</p><pre><code class="hljs bash">code</code></pre><p>进入vscode界面后<br>Ctrl+Shift+X</p><p>若界面为汉语，则在搜索栏输入python<br>若为英语，则先zh-CN，安装，再搜索python<br>安装python。</p><p>Ctrl+Shift+E</p><p>新建一个文件夹。<br>然后应该能看到settings.json这个文件，</p><p>输入以下内容</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"python.linting.flake8Enabled"</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">"python.formatting.provider"</span>: <span class="hljs-string">"yapf"</span>,    <span class="hljs-attr">"python.linting.flake8Args"</span>: [<span class="hljs-string">"--max-line-length=248"</span>],    <span class="hljs-attr">"python.linting.pylintEnabled"</span>: <span class="hljs-literal">false</span>&#125;</code></pre><p>然后在 .vscode 文件夹外 <em>也就是你新建的这个文件夹</em>新建一个 .py文件<br>此时python插件会提醒你少几项配置，你选择分别yapf和flake8即可。若跳过了前面的那步，也是选择yapf和flake8，它会自动通过pip下载。如果下载失败……你可以考虑复制他的命令然后改成pip3试试……。</p><p>之后就可以开心写py文件了，代码补全啊，实时纠错也都有了，报错不知道怎么改把鼠标移动上去有错误代码，然后浏览器搜索一下就可以了。<br>Alt+Shift+F是自动格式化代码。</p><p>(ง •_•)ง</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>python3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python3</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
